<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Forensic Legal Analyzer</title><!-- React Dependencies - MUST load first --><script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script><script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script><script src="https://unpkg.com/@babel/standalone/babel.min.js"></script><!-- Forensic Analyzer Configuration - loads after React --><script src="forensic-analyzer-config.js"></script><!-- OCR and PDF Processing Libraries --><script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script><!-- Export Libraries --><script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script><script> if (typeof pdfjsLib !== 'undefined') { pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; } </script><style>:root{--color-primary:#2563eb;--color-primary-dark:#1d4ed8;--color-primary-light:#eff6ff;--color-secondary:#f59e0b;--color-secondary-light:#fef3c7;--color-success:#16a34a;--color-success-light:#dcfce7;--color-warning:#f59e0b;--color-warning-light:#fef3c7;--color-error:#dc2626;--color-error-light:#fee2e2;--color-info:#0284c7;--color-info-light:#e0f2fe;--color-gray-50:#f9fafb;--color-gray-100:#f3f4f6;--color-gray-200:#e5e7eb;--color-gray-300:#d1d5db;--color-gray-400:#9ca3af;--color-gray-500:#6b7280;--color-gray-600:#4b5563;--color-gray-700:#374151;--color-gray-800:#1f2937;--color-gray-900:#111827;--color-critical:#fecaca;--color-critical-text:#991b1b;--color-high:#fcd34d;--color-high-text:#92400e;--color-medium:#a5f3fc;--color-medium-text:#0e7490;--color-low:#bbf7d0;--color-low-text:#166534;--spacing-xs:4px;--spacing-sm:8px;--spacing-md:16px;--spacing-lg:24px;--spacing-xl:32px;--spacing-2xl:48px;--radius-sm:4px;--radius-md:8px;--radius-lg:12px;--radius-xl:16px;--radius-full:9999px;--shadow-sm:0 1px 2px rgba(0,0,0,0.05);--shadow-md:0 4px 6px rgba(0,0,0,0.1);--shadow-lg:0 10px 15px rgba(0,0,0,0.1);--shadow-xl:0 20px 25px rgba(0,0,0,0.15);--font-size-xs:11px;--font-size-sm:12px;--font-size-base:14px;--font-size-lg:16px;--font-size-xl:18px;--font-size-2xl:24px;--font-size-3xl:30px;--font-size-4xl:36px;--transition-fast:150ms ease-in-out;--transition-base:250ms ease-in-out;--transition-slow:350ms ease-in-out;--z-dropdown:1000;--z-modal:2000;--z-tooltip:3000;--bg-primary:#ffffff;--bg-secondary:#f9fafb;--text-primary:#111827;--text-secondary:#6b7280;--border-color:#e5e7eb}[data-theme="dark"]{--color-primary:#3b82f6;--color-primary-dark:#2563eb;--color-primary-light:#1e3a8a;--color-gray-50:#1f2937;--color-gray-100:#374151;--color-gray-200:#4b5563;--color-gray-300:#6b7280;--color-gray-400:#9ca3af;--color-gray-500:#d1d5db;--color-gray-600:#e5e7eb;--color-gray-700:#f3f4f6;--color-gray-800:#f9fafb;--color-gray-900:#ffffff;--bg-primary:#111827;--bg-secondary:#1f2937;--text-primary:#ffffff;--text-secondary:#d1d5db;--border-color:#374151;--shadow-sm:0 1px 2px rgba(0,0,0,0.3);--shadow-md:0 4px 6px rgba(0,0,0,0.3);--shadow-lg:0 10px 15px rgba(0,0,0,0.4);--shadow-xl:0 20px 25px rgba(0,0,0,0.5)}*{margin:0;padding:0;box-sizing:border-box}body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-size:var(--font-size-base);color:var(--text-primary);background:var(--bg-primary);transition:background-color var(--transition-base),color var(--transition-base)}#root{width:100%;min-height:100vh}.icon{display:inline-block;width:1em;height:1em;vertical-align:middle}button,a,.card,.section{transition:all var(--transition-base)}button:focus-visible,a:focus-visible,input:focus-visible{outline:3px solid var(--color-primary);outline-offset:2px}button:not(:disabled):hover{transform:translateY(-1px);box-shadow:var(--shadow-lg)}button:not(:disabled):active{transform:translateY(0)}@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}@keyframes slideIn{from{opacity:0;transform:translateX(-20px)}to{opacity:1;transform:translateX(0)}}@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}@keyframes shimmer{0%{background-position:-1000px 0}100%{background-position:1000px 0}}.fade-in{animation:fadeIn var(--transition-base)}.slide-in{animation:slideIn var(--transition-base)}.pulse{animation:pulse 2s cubic-bezier(0.4,0,0.6,1) infinite}.spin{animation:spin 1s linear infinite}.skeleton{background:linear-gradient( 90deg,var(--color-gray-200) 0%,var(--color-gray-100) 50%,var(--color-gray-200) 100% );background-size:1000px 100%;animation:shimmer 2s infinite;border-radius:var(--radius-md)}@media (max-width:768px){:root{--font-size-3xl:24px;--spacing-xl:24px;--spacing-2xl:32px}body{font-size:var(--font-size-sm)}}@media print{body{background:white !important}button,.no-print{display:none !important}.card,.section{box-shadow:none !important;border:1px solid var(--color-gray-300) !important;page-break-inside:avoid}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}::-webkit-scrollbar{width:10px;height:10px}::-webkit-scrollbar-track{background:var(--color-gray-100)}::-webkit-scrollbar-thumb{background:var(--color-gray-400);border-radius:var(--radius-full)}::-webkit-scrollbar-thumb:hover{background:var(--color-gray-500)}.text-center{text-align:center}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.visually-hidden{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}</style></head><body><div id="root"></div><!-- Court Procedure Checker Module --><script type="module"> import { MagistratesCourtChecker } from './src/analyzers/CourtProcedureChecker.js'; import { ExportManager } from './src/utils/exportManager.js'; window.MagistratesCourtChecker = MagistratesCourtChecker; window.ExportManager = ExportManager; </script><script type="text/babel"> const { useState, useRef } = React; const Icon = ({ name, className = "", ...props }) => { const icons = { Upload: "‚¨ÜÔ∏è", FileText: "üìÑ", AlertCircle: "‚ö†Ô∏è", CheckCircle: "‚úÖ", Loader: "‚åõ", Download: "‚¨áÔ∏è", Eye: "üëÅÔ∏è", ChevronDown: "‚ñº", ChevronRight: "‚ñ∂", Search: "üîç", Filter: "üîΩ", Settings: "‚öôÔ∏è", Moon: "üåô", Sun: "‚òÄÔ∏è", BarChart: "üìä", Compare: "‚öñÔ∏è", Help: "‚ùì", Print: "üñ®Ô∏è", X: "‚úñÔ∏è", Menu: "‚ò∞" }; return <span className={`icon ${className}`} {...props}>{icons[name] || "‚Ä¢"}</span>; }; const HelpTooltip = ({ content, children }) => { const [showTooltip, setShowTooltip] = React.useState(false); return ( <span style={{ position: 'relative', display: 'inline-block', cursor: 'help' }} onMouseEnter={() => setShowTooltip(true)} onMouseLeave={() => setShowTooltip(false)}> {children} {showTooltip && ( <div style={{ position: 'absolute', bottom: '100%', left: '50%', transform: 'translateX(-50%)', marginBottom: '8px', padding: '12px 16px', backgroundColor: 'var(--color-gray-900)', color: 'white', borderRadius: '8px', fontSize: '13px', lineHeight: '1.5', whiteSpace: 'normal', width: '280px', boxShadow: '0 4px 12px rgba(0,0,0,0.3)', zIndex: 'var(--z-tooltip)', pointerEvents: 'none' }}> {content} <div style={{ position: 'absolute', top: '100%', left: '50%', transform: 'translateX(-50%)', width: 0, height: 0, borderLeft: '6px solid transparent', borderRight: '6px solid transparent', borderTop: '6px solid var(--color-gray-900)' }} /></div> )} </span> ); }; const AnalysisMemory = { storage: null, dbPromise: null, DB_VERSION: 2, DB_NAME: 'ForensicAnalysisDB', MAX_RETRIES: 3, RETRY_DELAY: 1000, isInitialized: false, async retryOperation(operation, retries = this.MAX_RETRIES) { for (let i = 0; i <retries; i++) { try { return await operation(); } catch (error) { if (i === retries - 1) throw error; const delay = this.RETRY_DELAY * Math.pow(2, i); console.warn(`Operation failed, retrying in ${delay}ms... (${i + 1}/${retries})`, error); await new Promise(resolve => setTimeout(resolve, delay)); } } }, async validateDatabaseHealth() { try { const db = await this.getDB(); if (!db) throw new Error('Database connection is null'); const requiredStores = ['analyses', 'defect_patterns', 'statutory_references']; for (const storeName of requiredStores) { if (!db.objectStoreNames.contains(storeName)) { throw new Error(`Required object store '${storeName}' is missing`); } } return true; } catch (error) { console.error('Database health check failed:', error); return false; } }, init() { if (this.dbPromise) return this.dbPromise; this.dbPromise = new Promise((resolve, reject) => { if (!window.indexedDB) { const error = new Error('IndexedDB is not supported in this browser'); console.error(error); reject(error); return; } const request = window.indexedDB.open(this.DB_NAME, this.DB_VERSION); let upgradeFailed = false; request.onupgradeneeded = (e) => { try { const db = e.target.result; const oldVersion = e.oldVersion; const transaction = e.target.transaction; if (!db.objectStoreNames.contains('analyses')) { const analysesStore = db.createObjectStore('analyses', { keyPath: 'id', autoIncrement: true }); analysesStore.createIndex('timestamp', 'timestamp', { unique: false }); analysesStore.createIndex('fileAName', 'fileAName', { unique: false }); analysesStore.createIndex('fileBName', 'fileBName', { unique: false }); } if (!db.objectStoreNames.contains('defect_patterns')) { const patternsStore = db.createObjectStore('defect_patterns', { keyPath: 'pattern_id', autoIncrement: true }); patternsStore.createIndex('defect_type', 'defect_type', { unique: false }); patternsStore.createIndex('occurrence_count', 'occurrence_count', { unique: false }); patternsStore.createIndex('last_seen', 'last_seen', { unique: false }); } if (!db.objectStoreNames.contains('statutory_references')) { const statutesStore = db.createObjectStore('statutory_references', { keyPath: 'reference' }); statutesStore.createIndex('times_encountered', 'times_encountered', { unique: false }); statutesStore.createIndex('compliance_rate', 'compliance_rate', { unique: false }); } if (oldVersion <2 && db.objectStoreNames.contains('patterns')) { db.deleteObjectStore('patterns'); } transaction.onabort = () => { upgradeFailed = true; console.error('Database upgrade transaction was aborted'); }; } catch (error) { upgradeFailed = true; console.error('Error during database upgrade:', error); } }; request.onsuccess = (e) => { if (upgradeFailed) { const error = new Error('Database upgrade failed'); console.error(error); reject(error); return; } this.storage = e.target.result; this.isInitialized = true; this.storage.onversionchange = () => { this.storage.close(); this.storage = null; this.dbPromise = null; this.isInitialized = false; }; this.storage.onerror = (event) => { console.error('Database error:', event.target.error); }; resolve(this.storage); }; request.onerror = (e) => { const error = e.target.error; console.error('Failed to open IndexedDB:', error); let errorMessage = 'Database initialization failed'; if (error.name === 'QuotaExceededError') { errorMessage = 'Storage quota exceeded. Please free up space.'; } else if (error.name === 'VersionError') { errorMessage = 'Database version conflict. Please refresh the page.'; } reject(new Error(errorMessage)); }; request.onblocked = () => { }; }); return this.dbPromise; }, async getDB() { if (!this.storage || !this.isInitialized) { await this.init(); } if (this.storage && this.storage.objectStoreNames.length === 0) { this.storage = null; this.dbPromise = null; this.isInitialized = false; await this.init(); } return this.storage; }, validateAnalysisData(results, files, fileContents) { const errors = []; if (!results || typeof results !== 'object') { errors.push('Analysis results are invalid or missing'); } if (!files || (!files.fileA && !files.fileB)) { errors.push('File information is missing'); } if (files.fileA && files.fileA.name && files.fileA.name.length> 255) { errors.push('File A name exceeds maximum length'); } if (files.fileB && files.fileB.name && files.fileB.name.length> 255) { errors.push('File B name exceeds maximum length'); } const MAX_CONTENT_SIZE = 10 * 1024 * 1024; if (fileContents?.fileA && fileContents.fileA.length> MAX_CONTENT_SIZE) { errors.push('File A content exceeds maximum size (10MB)'); } if (fileContents?.fileB && fileContents.fileB.length> MAX_CONTENT_SIZE) { errors.push('File B content exceeds maximum size (10MB)'); } if (errors.length> 0) { throw new Error(`Validation failed: ${errors.join(', ')}`); } return true; }, sanitizeContent(content) { if (typeof content !== 'string') return ''; return content .replace(/<script[^>]*>.*?<\/script>/gi, '') .replace(/<iframe[^>]*>.*?<\/iframe>/gi, '') .replace(/javascript:/gi, '') .replace(/on\w+\s*=/gi, '') .substring(0, 10 * 1024 * 1024); // Hard limit at 10MB }, async saveAnalysis(results, files, fileContents) { return this.retryOperation(async () => { try { this.validateAnalysisData(results, files, fileContents); const db = await this.getDB(); const defects = this.extractDefects(results); const severity = this.calculateSeveritySummary(defects); const statutes = this.extractStatutoryReferences(results); const sanitizedFileA = this.sanitizeContent(fileContents?.fileA || ''); const sanitizedFileB = this.sanitizeContent(fileContents?.fileB || ''); const analysis = { timestamp: new Date().toISOString(), fileAName: (files.fileA?.name || 'Unknown').substring(0, 255), fileBName: (files.fileB?.name || 'Unknown').substring(0, 255), fileAContent: sanitizedFileA, fileBContent: sanitizedFileB, findings: results, defects: defects, severity_summary: severity, statutory_references: statutes, crossReferences: this.buildCrossReferences(results), version: this.DB_VERSION, savedAt: Date.now() }; const tx = db.transaction('analyses', 'readwrite'); let analysisId = null; await new Promise((resolve, reject) => { tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); tx.onabort = () => reject(new Error('Transaction aborted')); const request = tx.objectStore('analyses').add(analysis); request.onsuccess = () => { analysisId = request.result; }; request.onerror = () => reject(request.error); }); try { await this.updateDefectPatterns(defects); } catch (error) { } try { await this.updateStatutoryReferences(statutes, defects); } catch (error) { } return analysisId; } catch (error) { console.error('Failed to save analysis:', error); if (error.name === 'QuotaExceededError') { throw new Error('Storage quota exceeded. Please delete old analyses or free up space.'); } else if (error.name === 'ConstraintError') { throw new Error('Data constraint violation. Analysis may already exist.'); } else if (error.message.includes('Validation failed')) { throw error; // Re-throw validation errors as-is } else { throw new Error(`Failed to save analysis: ${error.message}`); } } }); }, extractDefects(results) { const defects = []; try { if (!results || typeof results !== 'object') { return defects; } ['fileA', 'fileB'].forEach(fileKey => { try { if (results.phaseA && Array.isArray(results.phaseA[fileKey])) { results.phaseA[fileKey].forEach((preset, presetIndex) => { try { if (!preset || !preset.findings) { return; } const potentialIssues = preset.findings.potentialIssues; if (!potentialIssues) return; const issues = potentialIssues.issues || potentialIssues; if (Array.isArray(issues)) { issues.forEach((issue, issueIndex) => { try { const issueObj = typeof issue === 'string' ? { description: issue } : issue; if (!issueObj || typeof issueObj !== 'object') { return; } defects.push({ phase: 'A', preset: preset.preset || 'Unknown Preset', severity: (issueObj.severity || 'MEDIUM').toUpperCase(), type: issueObj.type || 'General Issue', description: this.sanitizeContent(issueObj.description || String(issue)).substring(0, 1000), file: fileKey, timestamp: new Date().toISOString() }); } catch (error) { console.error(`Error processing Phase A issue:`, error); } }); } } catch (error) { console.error(`Error processing Phase A preset:`, error); } }); } } catch (error) { console.error(`Error processing Phase A ${fileKey}:`, error); } }); if (results.phaseB && Array.isArray(results.phaseB.discrepancies)) { results.phaseB.discrepancies.forEach((disc, index) => { try { const discObj = typeof disc === 'string' ? { description: disc } : disc; if (!discObj || typeof discObj !== 'object') { return; } defects.push({ phase: 'B', type: 'discrepancy', severity: (discObj.severity || 'HIGH').toUpperCase(), description: this.sanitizeContent(discObj.description || String(disc)).substring(0, 1000), timestamp: new Date().toISOString() }); } catch (error) { console.error(`Error processing Phase B discrepancy:`, error); } }); } if (results.phaseB && Array.isArray(results.phaseB.omissions)) { results.phaseB.omissions.forEach((om, index) => { try { if (!om || typeof om !== 'object') { return; } defects.push({ phase: 'B', type: 'omission', severity: 'MEDIUM', element: om.element || 'Unknown Element', status: om.status || 'missing', description: `Missing: ${om.element || 'Unknown Element'}`, timestamp: new Date().toISOString() }); } catch (error) { console.error(`Error processing Phase B omission:`, error); } }); } if (results.phaseC && Array.isArray(results.phaseC.defects)) { results.phaseC.defects.forEach((defect, index) => { try { const defectObj = typeof defect === 'string' ? { description: defect } : defect; if (!defectObj || typeof defectObj !== 'object') { return; } defects.push({ phase: 'C', type: defectObj.type || 'interpretation', severity: (defectObj.severity || 'MEDIUM').toUpperCase(), description: this.sanitizeContent(defectObj.description || String(defect)).substring(0, 1000), timestamp: new Date().toISOString() }); } catch (error) { console.error(`Error processing Phase C defect:`, error); } }); } } catch (error) { console.error('Critical error in extractDefects:', error); } return defects; }, calculateSeveritySummary(defects) { const summary = { HIGH: 0, MEDIUM: 0, LOW: 0, CRITICAL: 0 }; defects.forEach(defect => { const severity = (defect.severity || 'MEDIUM').toUpperCase(); if (summary.hasOwnProperty(severity)) { summary[severity]++; } else { summary[severity] = 1; } }); return summary; }, extractStatutoryReferences(results) { const statutes = new Set(); ['fileA', 'fileB'].forEach(fileKey => { if (results.phaseA?.[fileKey]?.[0]?.findings?.legalReferences) { results.phaseA[fileKey][0].findings.legalReferences.forEach(ref => { if (ref.text) statutes.add(ref.text); }); } }); return Array.from(statutes); }, buildCrossReferences(results) { const refs = { statutory: [], procedural: [], temporal: [], evidential: [] }; ['fileA', 'fileB'].forEach(fileKey => { if (results.phaseA?.[fileKey]?.[0]?.findings?.legalReferences) { results.phaseA[fileKey][0].findings.legalReferences.forEach(ref => { refs.statutory.push({ text: ref.text, type: ref.type, source: fileKey, relatedDefects: this.findRelatedDefects(ref.text, results) }); }); } }); return refs; }, findRelatedDefects(reference, results) { const related = []; const refLower = reference.toLowerCase(); ['fileA', 'fileB'].forEach(fileKey => { if (results.phaseA?.[fileKey]) { results.phaseA[fileKey].forEach(preset => { const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues; if (Array.isArray(issues)) { issues.forEach(issue => { const desc = issue.description || issue; if (typeof desc === 'string' && desc.toLowerCase().includes(refLower)) { related.push({ preset: preset.preset, type: issue.type, severity: issue.severity }); } }); } }); } }); return related; }, async updateDefectPatterns(defects) { try { const db = await this.getDB(); const tx = db.transaction('defect_patterns', 'readwrite'); const store = tx.objectStore('defect_patterns'); for (const defect of defects) { const defectKey = `${defect.type}_${defect.severity}`; const allPatterns = await new Promise((resolve, reject) => { const request = store.getAll(); request.onsuccess = () => resolve(request.result); request.onerror = () => reject(request.error); }); const existingPattern = allPatterns.find(p => p.defect_type === defect.type && p.description.includes(defect.description.substring(0, 50)) ); if (existingPattern) { existingPattern.occurrence_count++; existingPattern.last_seen = new Date().toISOString(); existingPattern.associated_statutes = Array.from(new Set([ ...(existingPattern.associated_statutes || []), ...(defect.statutes || []) ])); if (existingPattern.occurrence_count>= 3 && !existingPattern.recommendation) { existingPattern.recommendation = this.generateRecommendation(existingPattern); } await new Promise((resolve, reject) => { const request = store.put(existingPattern); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); } else { const newPattern = { defect_type: defect.type, description: defect.description, first_seen: new Date().toISOString(), last_seen: new Date().toISOString(), occurrence_count: 1, associated_statutes: defect.statutes || [], recommendation: null }; await new Promise((resolve, reject) => { const request = store.add(newPattern); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); } } } catch (error) { console.error('Failed to update defect patterns:', error); } }, generateRecommendation(pattern) { const recommendations = { 'Missing s.55D directions': 'Systematic issue with preliminary test procedure documentation. Create checklist requiring explicit documentation of: oral directions given, written directions provided, subject\'s response to directions.', 'Missing s.49(1) reason to believe': 'Document officer\'s subjective belief formation at time of demand. Include specific observations that led to reasonable belief.', 'discrepancy': 'Cross-reference detected inconsistency. Verify timeline and ensure all document versions align.', 'omission': 'Critical element missing from documentation. Implement mandatory field checklist for all required elements.', 'admissibility': 'Evidence admissibility concerns detected. Review procedural compliance and statutory requirements.', 'procedural': 'Procedural defect identified. Ensure strict adherence to statutory procedure timeline and requirements.' }; for (const [key, recommendation] of Object.entries(recommendations)) { if (pattern.description.toLowerCase().includes(key.toLowerCase())) { return `${recommendation} (Occurred ${pattern.occurrence_count} times)`; } } return `This issue has occurred ${pattern.occurrence_count} times. Review procedural compliance and create systematic documentation checklist.`; }, async updateStatutoryReferences(statutes, defects) { try { const db = await this.getDB(); const tx = db.transaction('statutory_references', 'readwrite'); const store = tx.objectStore('statutory_references'); for (const statute of statutes) { const existing = await new Promise((resolve, reject) => { const request = store.get(statute); request.onsuccess = () => resolve(request.result); request.onerror = () => reject(request.error); }); const relatedDefects = defects.filter(d => d.description.toLowerCase().includes(statute.toLowerCase()) ).map(d => d.type); if (existing) { existing.times_encountered++; existing.associated_defects = Array.from(new Set([ ...(existing.associated_defects || []), ...relatedDefects ])); const totalDefects = relatedDefects.length; existing.compliance_rate = Math.max(0, 100 - (totalDefects * 10)); await new Promise((resolve, reject) => { const request = store.put(existing); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); } else { const newRef = { reference: statute, statute_name: this.parseStatuteName(statute), times_encountered: 1, associated_defects: relatedDefects, compliance_rate: relatedDefects.length> 0 ? 90 : 100 }; await new Promise((resolve, reject) => { const request = store.add(newRef); request.onsuccess = () => resolve(); request.onerror = () => reject(request.error); }); } } } catch (error) { console.error('Failed to update statutory references:', error); } }, parseStatuteName(reference) { const statuteMap = { 'RSA': 'Road Safety Act 1986', 'Crimes Act': 'Crimes Act 1958', 'Evidence Act': 'Evidence Act 2008', 'Magistrates': 'Magistrates\' Court Act' }; for (const [key, name] of Object.entries(statuteMap)) { if (reference.includes(key)) return name; } return reference; }, async getAllAnalyses(options = {}) { return this.retryOperation(async () => { try { const db = await this.getDB(); const tx = db.transaction('analyses', 'readonly'); const store = tx.objectStore('analyses'); const { limit = 1000, offset = 0, sortOrder = 'desc' } = options; return new Promise((resolve, reject) => { const analyses = []; const index = store.index('timestamp'); const direction = sortOrder === 'desc' ? 'prev' : 'next'; const request = index.openCursor(null, direction); let count = 0; let skipped = 0; request.onsuccess = (event) => { const cursor = event.target.result; if (cursor) { if (skipped <offset) { skipped++; cursor.continue(); } else if (count <limit) { analyses.push(cursor.value); count++; cursor.continue(); } else { resolve(analyses); } } else { resolve(analyses); } }; request.onerror = () => { console.error('Error reading analyses:', request.error); reject(request.error); }; tx.onerror = () => { console.error('Transaction error:', tx.error); reject(tx.error); }; }); } catch (error) { console.error('Failed to retrieve analyses:', error); return []; } }); }, async getAllDefectPatterns() { return this.retryOperation(async () => { try { const db = await this.getDB(); const tx = db.transaction('defect_patterns', 'readonly'); const store = tx.objectStore('defect_patterns'); return new Promise((resolve, reject) => { const request = store.getAll(); request.onsuccess = () => { const patterns = request.result || []; resolve(patterns); }; request.onerror = () => { console.error('Error reading defect patterns:', request.error); reject(request.error); }; tx.onerror = () => { console.error('Transaction error:', tx.error); reject(tx.error); }; }); } catch (error) { console.error('Failed to retrieve defect patterns:', error); return []; } }); }, async getAllStatutoryReferences() { return this.retryOperation(async () => { try { const db = await this.getDB(); const tx = db.transaction('statutory_references', 'readonly'); const store = tx.objectStore('statutory_references'); return new Promise((resolve, reject) => { const request = store.getAll(); request.onsuccess = () => { const references = request.result || []; resolve(references); }; request.onerror = () => { console.error('Error reading statutory references:', request.error); reject(request.error); }; tx.onerror = () => { console.error('Transaction error:', tx.error); reject(tx.error); }; }); } catch (error) { console.error('Failed to retrieve statutory references:', error); return []; } }); }, async deleteOldAnalyses(daysToKeep = 90) { return this.retryOperation(async () => { try { const db = await this.getDB(); const cutoffDate = new Date(); cutoffDate.setDate(cutoffDate.getDate() - daysToKeep); const cutoffISO = cutoffDate.toISOString(); const tx = db.transaction('analyses', 'readwrite'); const store = tx.objectStore('analyses'); const index = store.index('timestamp'); let deletedCount = 0; return new Promise((resolve, reject) => { const range = IDBKeyRange.upperBound(cutoffISO); const request = index.openCursor(range); request.onsuccess = (event) => { const cursor = event.target.result; if (cursor) { cursor.delete(); deletedCount++; cursor.continue(); } else { resolve(deletedCount); } }; request.onerror = () => reject(request.error); tx.onerror = () => reject(tx.error); }); } catch (error) { console.error('Failed to delete old analyses:', error); throw error; } }); }, async getDatabaseStats() { try { const [analyses, patterns, references] = await Promise.all([ this.getAllAnalyses({ limit: 10000 }), this.getAllDefectPatterns(), this.getAllStatutoryReferences() ]); const totalDefects = analyses.reduce((sum, a) => sum + (a.defects?.length || 0), 0); const avgDefectsPerAnalysis = analyses.length> 0 ? (totalDefects / analyses.length).toFixed(2) : 0; return { totalAnalyses: analyses.length, totalDefectPatterns: patterns.length, totalStatutoryReferences: references.length, totalDefects: totalDefects, averageDefectsPerAnalysis: avgDefectsPerAnalysis, oldestAnalysis: analyses.length> 0 ? analyses[analyses.length - 1]?.timestamp : null, newestAnalysis: analyses.length> 0 ? analyses[0]?.timestamp : null }; } catch (error) { console.error('Failed to get database stats:', error); return null; } }, async getIntelligenceForAnalysis(currentDefects) { try { const allPatterns = await this.getAllDefectPatterns(); const intelligence = []; for (const defect of currentDefects) { const matchingPattern = allPatterns.find(p => p.defect_type === defect.type && p.description.includes(defect.description.substring(0, 50)) ); if (matchingPattern) { intelligence.push({ defect: defect, isRecurring: matchingPattern.occurrence_count>= 3, previousOccurrences: matchingPattern.occurrence_count, firstSeen: matchingPattern.first_seen, lastSeen: matchingPattern.last_seen, recommendation: matchingPattern.recommendation, isNovel: false }); } else { intelligence.push({ defect: defect, isRecurring: false, previousOccurrences: 0, isNovel: true, recommendation: '‚ö†Ô∏è NEW ISSUE: This type of defect has not been encountered before.' }); } } return intelligence; } catch (error) { console.error('Failed to generate intelligence:', error); return []; } }, async generateLearningInsights() { try { const analyses = await this.getAllAnalyses(); const patterns = await this.getAllDefectPatterns(); const statutes = await this.getAllStatutoryReferences(); if (analyses.length === 0) { return { totalAnalyses: 0, totalDefects: 0, mostCommonIssue: null, recurringPatterns: [], statuteCompliance: [], temporalTrends: null, recommendations: [] }; } const totalDefects = analyses.reduce((sum, a) => sum + (a.defects?.length || 0), 0); const mostCommon = patterns.sort((a, b) => b.occurrence_count - a.occurrence_count)[0]; const recurring = patterns.filter(p => p.occurrence_count>= 3); const temporal = this.calculateTemporalTrends(analyses); const recommendations = this.generateProcessRecommendations(patterns, statutes); return { totalAnalyses: analyses.length, totalDefects: totalDefects, mostCommonIssue: mostCommon ? { type: mostCommon.defect_type, count: mostCommon.occurrence_count, percentage: ((mostCommon.occurrence_count / totalDefects) * 100).toFixed(1) } : null, recurringPatterns: recurring, statuteCompliance: statutes.sort((a, b) => a.compliance_rate - b.compliance_rate).slice(0, 5), temporalTrends: temporal, recommendations: recommendations, newIssuesThisAnalysis: 0 // This will be set by the analyzer }; } catch (error) { console.error('Failed to generate learning insights:', error); return null; } }, calculateTemporalTrends(analyses) { if (analyses.length <2) return null; const sorted = analyses.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); const midpoint = Math.floor(sorted.length / 2); const older = sorted.slice(0, midpoint); const recent = sorted.slice(midpoint); const olderDefectCount = older.reduce((sum, a) => sum + (a.defects?.length || 0), 0); const recentDefectCount = recent.reduce((sum, a) => sum + (a.defects?.length || 0), 0); const olderAvg = older.length> 0 ? olderDefectCount / older.length : 0; const recentAvg = recent.length> 0 ? recentDefectCount / recent.length : 0; const trend = recentAvg <olderAvg ? 'improving' : recentAvg> olderAvg ? 'worsening' : 'stable'; const changePercent = olderAvg> 0 ? (((recentAvg - olderAvg) / olderAvg) * 100).toFixed(1) : 0; return { trend: trend, changePercent: Math.abs(changePercent), direction: recentAvg <olderAvg ? 'decrease' : 'increase', olderAverage: olderAvg.toFixed(1), recentAverage: recentAvg.toFixed(1) }; }, generateProcessRecommendations(patterns, statutes) { const recommendations = []; patterns.filter(p => p.occurrence_count>= 3).forEach(pattern => { if (pattern.recommendation) { recommendations.push({ type: 'recurring_defect', priority: pattern.occurrence_count>= 5 ? 'HIGH' : 'MEDIUM', issue: pattern.defect_type, occurrences: pattern.occurrence_count, recommendation: pattern.recommendation }); } }); statutes.filter(s => s.compliance_rate <70).forEach(statute => { recommendations.push({ type: 'statute_compliance', priority: 'HIGH', statute: statute.reference, complianceRate: statute.compliance_rate, recommendation: `${statute.reference} has low compliance (${statute.compliance_rate}%). Review procedural requirements and create targeted training.` }); }); return recommendations; } }; const DefectTimeline = ({ analyses }) => { const [selectedDefect, setSelectedDefect] = useState(null); const [filters, setFilters] = useState({ dateRange: 'all', // all, last7, last30, last90 defectType: 'all', severity: 'all', statute: 'all' }); const [expandedAnalysis, setExpandedAnalysis] = useState(null); const filterOptions = React.useMemo(() => { if (!analyses || analyses.length === 0) return { types: [], severities: [], statutes: [] }; const types = new Set(); const severities = new Set(); const statutes = new Set(); analyses.forEach(analysis => { if (analysis.defects) { analysis.defects.forEach(defect => { types.add(defect.type); severities.add(defect.severity); }); } if (analysis.statutory_references) { analysis.statutory_references.forEach(ref => statutes.add(ref)); } }); return { types: Array.from(types), severities: Array.from(severities), statutes: Array.from(statutes) }; }, [analyses]); const filteredAnalyses = React.useMemo(() => { if (!analyses || analyses.length === 0) return []; let filtered = [...analyses]; if (filters.dateRange !== 'all') { const now = new Date(); const daysMap = { last7: 7, last30: 30, last90: 90 }; const days = daysMap[filters.dateRange]; const cutoff = new Date(now - days * 24 * 60 * 60 * 1000); filtered = filtered.filter(a => new Date(a.timestamp)>= cutoff); } if (filters.defectType !== 'all') { filtered = filtered.filter(a => a.defects?.some(d => d.type === filters.defectType) ); } if (filters.severity !== 'all') { filtered = filtered.filter(a => a.defects?.some(d => d.severity === filters.severity) ); } if (filters.statute !== 'all') { filtered = filtered.filter(a => a.statutory_references?.includes(filters.statute) ); } return filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); }, [analyses, filters]); if (!analyses || analyses.length === 0) { return ( <div style={{ padding: '20px', backgroundColor: '#f9fafb', textAlign: 'center' }}><p style={{ color: '#6b7280' }}>No historical analysis data available yet. Complete analyses will appear here over time.</p></div> ); } const getSeverityColor = (severity) => { const colors = { 'CRITICAL': '#dc2626', 'HIGH': '#f59e0b', 'MEDIUM': '#3b82f6', 'LOW': '#10b981' }; return colors[severity?.toUpperCase()] || '#6b7280'; }; return ( <div style={{ padding: '20px', backgroundColor: '#f9fafb' }}><h3 style={{ marginBottom: '16px' }}>üìä Chronological Analysis Timeline</h3> {/* Filters */} <div style={{ marginBottom: '20px', padding: '16px', backgroundColor: 'white', borderRadius: '8px', boxShadow: '0 1px 3px rgba(0,0,0,0.1)' }}><h4 style={{ marginBottom: '12px', fontSize: '14px' }}>Filter Results</h4><div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '12px' }}> {/* Date Range */} <div><label style={{ display: 'block', fontSize: '12px', marginBottom: '4px', color: '#6b7280' }}> Date Range </label><select value={filters.dateRange} onChange={(e) => setFilters({...filters, dateRange: e.target.value})} style={{ width: '100%', padding: '6px 8px', borderRadius: '4px', border: '1px solid #d1d5db', fontSize: '13px' }}><option value="all">All Time</option><option value="last7">Last 7 Days</option><option value="last30">Last 30 Days</option><option value="last90">Last 90 Days</option></select></div> {/* Defect Type */} <div><label style={{ display: 'block', fontSize: '12px', marginBottom: '4px', color: '#6b7280' }}> Defect Type </label><select value={filters.defectType} onChange={(e) => setFilters({...filters, defectType: e.target.value})} style={{ width: '100%', padding: '6px 8px', borderRadius: '4px', border: '1px solid #d1d5db', fontSize: '13px' }}><option value="all">All Types</option> {filterOptions.types.map(type => ( <option key={type} value={type}>{type}</option> ))} </select></div> {/* Severity */} <div><label style={{ display: 'block', fontSize: '12px', marginBottom: '4px', color: '#6b7280' }}> Severity Level </label><select value={filters.severity} onChange={(e) => setFilters({...filters, severity: e.target.value})} style={{ width: '100%', padding: '6px 8px', borderRadius: '4px', border: '1px solid #d1d5db', fontSize: '13px' }}><option value="all">All Severities</option> {filterOptions.severities.map(sev => ( <option key={sev} value={sev}>{sev}</option> ))} </select></div> {/* Statute */} <div><label style={{ display: 'block', fontSize: '12px', marginBottom: '4px', color: '#6b7280' }}> Statute Referenced </label><select value={filters.statute} onChange={(e) => setFilters({...filters, statute: e.target.value})} style={{ width: '100%', padding: '6px 8px', borderRadius: '4px', border: '1px solid #d1d5db', fontSize: '13px' }}><option value="all">All Statutes</option> {filterOptions.statutes.map(stat => ( <option key={stat} value={stat}>{stat}</option> ))} </select></div></div><div style={{ marginTop: '12px', fontSize: '12px', color: '#6b7280' }}> Showing {filteredAnalyses.length} of {analyses.length} analyses </div></div> {/* Timeline Items */} <div style={{ position: 'relative' }}> {/* Timeline line */} <div style={{ position: 'absolute', left: '20px', top: '0', bottom: '0', width: '2px', backgroundColor: '#d1d5db' }} /> {filteredAnalyses.map((analysis, idx) => { const isExpanded = expandedAnalysis === analysis.id; const defectCount = analysis.defects?.length || 0; const severitySummary = analysis.severity_summary || {}; return ( <div key={analysis.id || idx} style={{ position: 'relative', marginLeft: '40px', marginBottom: '20px', padding: '16px', backgroundColor: 'white', borderRadius: '8px', boxShadow: '0 1px 3px rgba(0,0,0,0.1)', cursor: 'pointer', transition: 'all 0.2s' }} onClick={() => setExpandedAnalysis(isExpanded ? null : analysis.id)} onMouseEnter={(e) => e.currentTarget.style.boxShadow = '0 4px 6px rgba(0,0,0,0.15)'} onMouseLeave={(e) => e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)'}> {/* Timeline dot */} <div style={{ position: 'absolute', left: '-31px', top: '20px', width: '12px', height: '12px', borderRadius: '50%', backgroundColor: defectCount> 5 ? '#dc2626' : defectCount> 2 ? '#f59e0b' : '#10b981', border: '2px solid white', boxShadow: '0 0 0 2px #d1d5db' }} /> {/* Analysis Header */} <div style={{ marginBottom: '12px' }}><div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}><div><div style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}> {new Date(analysis.timestamp).toLocaleString()} </div><div style={{ fontWeight: '600', fontSize: '14px' }}> Analysis #{analysis.id} </div></div><div style={{ textAlign: 'right' }}><div style={{ fontSize: '24px', fontWeight: 'bold', color: defectCount> 5 ? '#dc2626' : '#6b7280' }}> {defectCount} </div><div style={{ fontSize: '11px', color: '#6b7280' }}>defects</div></div></div><div style={{ fontSize: '13px', color: '#4b5563', marginTop: '8px' }}><div>üìÑ {analysis.fileAName}</div><div>üìÑ {analysis.fileBName}</div></div></div> {/* Severity Summary */} <div style={{ display: 'flex', gap: '8px', marginTop: '8px' }}> {Object.entries(severitySummary).map(([severity, count]) => ( count> 0 && ( <span key={severity} style={{ padding: '2px 8px', borderRadius: '12px', fontSize: '11px', backgroundColor: getSeverityColor(severity) + '20', color: getSeverityColor(severity), fontWeight: '600' }}> {severity}: {count} </span> ) ))} </div> {/* Expanded Details */} {isExpanded && ( <div style={{ marginTop: '16px', paddingTop: '16px', borderTop: '1px solid #e5e7eb' }}><h5 style={{ marginBottom: '8px', fontSize: '13px', fontWeight: '600' }}>Defects Found:</h5> {analysis.defects?.map((defect, didx) => ( <div key={didx} style={{ padding: '8px', marginBottom: '6px', backgroundColor: '#f9fafb', borderRadius: '4px', borderLeft: `3px solid ${getSeverityColor(defect.severity)}`, fontSize: '12px' }}><div style={{ fontWeight: '600', color: getSeverityColor(defect.severity) }}> {defect.severity} - {defect.type} </div><div style={{ color: '#4b5563', marginTop: '4px' }}> {defect.description} </div></div> ))} {analysis.statutory_references && analysis.statutory_references.length> 0 && ( <div style={{ marginTop: '12px' }}><h5 style={{ marginBottom: '6px', fontSize: '13px', fontWeight: '600' }}>Statutes Referenced:</h5><div style={{ fontSize: '12px', color: '#6b7280' }}> {analysis.statutory_references.join(', ')} </div></div> )} </div> )} <div style={{ fontSize: '11px', color: '#9ca3af', marginTop: '8px', textAlign: 'right' }}> Click to {isExpanded ? 'collapse' : 'expand'} details </div></div> ); })} </div> {filteredAnalyses.length === 0 && ( <div style={{ textAlign: 'center', padding: '40px', color: '#6b7280' }}> No analyses match the selected filters. </div> )} </div> ); }; const LearningInsightsPanel = ({ insights, currentDefects }) => { if (!insights) { return ( <div style={{ padding: '20px', backgroundColor: '#f9fafb', borderRadius: '8px', textAlign: 'center', color: '#6b7280' }}><p>Loading intelligence summary...</p></div> ); } if (insights.totalAnalyses === 0) { return ( <div style={{ padding: '20px', backgroundColor: '#e0f2fe', borderRadius: '8px', border: '1px solid #0284c7' }}><h3 style={{ marginBottom: '12px', color: '#0284c7' }}>üìä System Intelligence Summary</h3><p style={{ color: '#0c4a6e' }}> No historical data yet. This system will learn from each analysis and provide intelligent insights over time. </p></div> ); } const { temporalTrends } = insights; const trendIcon = temporalTrends?.trend === 'improving' ? 'üìà‚úÖ' : temporalTrends?.trend === 'worsening' ? 'üìâ‚ö†Ô∏è' : '‚û°Ô∏è'; const trendColor = temporalTrends?.trend === 'improving' ? '#10b981' : temporalTrends?.trend === 'worsening' ? '#dc2626' : '#6b7280'; return ( <div style={{ padding: '24px', backgroundColor: 'white', borderRadius: '12px', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', marginBottom: '24px' }}><h3 style={{ marginBottom: '20px', fontSize: '20px', fontWeight: '700', color: '#1f2937', borderBottom: '2px solid #e5e7eb', paddingBottom: '12px' }}> üìä System Intelligence Summary </h3> {/* Summary Stats */} <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))', gap: '16px', marginBottom: '24px' }}><div style={{ padding: '16px', backgroundColor: '#eff6ff', borderRadius: '8px', borderLeft: '4px solid #3b82f6' }}><div style={{ fontSize: '28px', fontWeight: 'bold', color: '#1e40af' }}> {insights.totalAnalyses} </div><div style={{ fontSize: '12px', color: '#1e40af', marginTop: '4px' }}> Total Analyses </div></div><div style={{ padding: '16px', backgroundColor: '#fef3c7', borderRadius: '8px', borderLeft: '4px solid #f59e0b' }}><div style={{ fontSize: '28px', fontWeight: 'bold', color: '#92400e' }}> {insights.totalDefects} </div><div style={{ fontSize: '12px', color: '#92400e', marginTop: '4px' }}> Total Defects Found </div></div> {currentDefects && ( <div style={{ padding: '16px', backgroundColor: '#f0fdf4', borderRadius: '8px', borderLeft: '4px solid #10b981' }}><div style={{ fontSize: '28px', fontWeight: 'bold', color: '#065f46' }}> {currentDefects.filter(d => d.isNovel).length} </div><div style={{ fontSize: '12px', color: '#065f46', marginTop: '4px' }}> New Issues This Analysis </div></div> )} {temporalTrends && ( <div style={{ padding: '16px', backgroundColor: temporalTrends.trend === 'improving' ? '#f0fdf4' : temporalTrends.trend === 'worsening' ? '#fee2e2' : '#f9fafb', borderRadius: '8px', borderLeft: `4px solid ${trendColor}` }}><div style={{ fontSize: '22px', fontWeight: 'bold', color: trendColor }}> {trendIcon} {temporalTrends.changePercent}% </div><div style={{ fontSize: '12px', color: trendColor, marginTop: '4px' }}> {temporalTrends.trend.charAt(0).toUpperCase() + temporalTrends.trend.slice(1)} Trend </div></div> )} </div> {/* Most Common Issue */} {insights.mostCommonIssue && ( <div style={{ padding: '16px', backgroundColor: '#fef2f2', borderRadius: '8px', marginBottom: '20px', border: '1px solid #fecaca' }}><h4 style={{ fontSize: '14px', fontWeight: '600', color: '#991b1b', marginBottom: '8px' }}> ‚ö†Ô∏è Most Common Issue </h4><div style={{ fontSize: '13px', color: '#7f1d1d' }}><strong>{insights.mostCommonIssue.type}</strong><div style={{ marginTop: '4px' }}> Occurred {insights.mostCommonIssue.count} times ({insights.mostCommonIssue.percentage}% of all defects) </div></div></div> )} {/* Recurring Patterns */} {insights.recurringPatterns && insights.recurringPatterns.length> 0 && ( <div style={{ marginBottom: '20px' }}><h4 style={{ fontSize: '15px', fontWeight: '600', color: '#1f2937', marginBottom: '12px' }}> üîÑ Recurring Patterns (3+ occurrences) </h4> {insights.recurringPatterns.slice(0, 3).map((pattern, idx) => ( <div key={idx} style={{ padding: '12px', backgroundColor: '#fff7ed', borderRadius: '6px', marginBottom: '10px', borderLeft: '3px solid #f59e0b' }}><div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}><div style={{ flex: 1 }}><div style={{ fontSize: '13px', fontWeight: '600', color: '#92400e' }}> {pattern.defect_type} </div><div style={{ fontSize: '12px', color: '#78350f', marginTop: '4px' }}> {pattern.description.substring(0, 100)}{pattern.description.length> 100 ? '...' : ''} </div> {pattern.recommendation && ( <div style={{ marginTop: '8px', padding: '8px', backgroundColor: '#fffbeb', borderRadius: '4px', fontSize: '12px', color: '#78350f' }}><strong>üí° Recommendation:</strong> {pattern.recommendation} </div> )} </div><div style={{ marginLeft: '12px', padding: '4px 12px', backgroundColor: '#f59e0b', color: 'white', borderRadius: '12px', fontSize: '12px', fontWeight: '600', whiteSpace: 'nowrap' }}> {pattern.occurrence_count}x </div></div></div> ))} </div> )} {/* Statute Compliance */} {insights.statuteCompliance && insights.statuteCompliance.length> 0 && ( <div style={{ marginBottom: '20px' }}><h4 style={{ fontSize: '15px', fontWeight: '600', color: '#1f2937', marginBottom: '12px' }}> ‚öñÔ∏è Statute Compliance Rates (Lowest First) </h4> {insights.statuteCompliance.map((statute, idx) => ( <div key={idx} style={{ padding: '10px', backgroundColor: statute.compliance_rate <70 ? '#fef2f2' : '#f0fdf4', borderRadius: '6px', marginBottom: '8px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', border: statute.compliance_rate <70 ? '1px solid #fecaca' : '1px solid #bbf7d0' }}><div><div style={{ fontSize: '13px', fontWeight: '600', color: statute.compliance_rate <70 ? '#991b1b' : '#065f46' }}> {statute.reference} </div><div style={{ fontSize: '11px', color: '#6b7280', marginTop: '2px' }}> {statute.statute_name} </div></div><div style={{ padding: '4px 12px', backgroundColor: statute.compliance_rate <70 ? '#dc2626' : statute.compliance_rate <85 ? '#f59e0b' : '#10b981', color: 'white', borderRadius: '12px', fontSize: '12px', fontWeight: '600' }}> {statute.compliance_rate}% </div></div> ))} </div> )} {/* Process Improvement Recommendations */} {insights.recommendations && insights.recommendations.length> 0 && ( <div style={{ padding: '16px', backgroundColor: '#e0f2fe', borderRadius: '8px', border: '1px solid #0284c7' }}><h4 style={{ fontSize: '15px', fontWeight: '600', color: '#075985', marginBottom: '12px' }}> üí° Recommended Process Improvements </h4> {insights.recommendations.map((rec, idx) => ( <div key={idx} style={{ padding: '10px', backgroundColor: 'white', borderRadius: '6px', marginBottom: '8px', borderLeft: `3px solid ${rec.priority === 'HIGH' ? '#dc2626' : '#f59e0b'}` }}><div style={{ display: 'flex', alignItems: 'start', gap: '8px' }}><span style={{ padding: '2px 6px', backgroundColor: rec.priority === 'HIGH' ? '#dc2626' : '#f59e0b', color: 'white', borderRadius: '4px', fontSize: '10px', fontWeight: '600', marginTop: '2px' }}> {rec.priority} </span><div style={{ flex: 1 }}><div style={{ fontSize: '12px', fontWeight: '600', color: '#1f2937', marginBottom: '4px' }}> {rec.issue || rec.statute} {rec.occurrences && ` (${rec.occurrences}x)`} {rec.complianceRate && ` - ${rec.complianceRate}% compliance`} </div><div style={{ fontSize: '12px', color: '#4b5563' }}> {rec.recommendation} </div></div></div></div> ))} </div> )} {/* Temporal Trends Detail */} {temporalTrends && ( <div style={{ marginTop: '20px', padding: '12px', backgroundColor: '#f9fafb', borderRadius: '6px', fontSize: '12px', color: '#4b5563' }}><strong>üìà Trend Analysis:</strong> {' '} {temporalTrends.trend === 'improving' && ( `Compliance improvement detected. Recent analyses average ${temporalTrends.recentAverage} defects vs ${temporalTrends.olderAverage} previously (${temporalTrends.changePercent}% improvement). Continue current documentation practices.` )} {temporalTrends.trend === 'worsening' && ( `Compliance decline detected. Recent analyses average ${temporalTrends.recentAverage} defects vs ${temporalTrends.olderAverage} previously (${temporalTrends.changePercent}% increase). Review recent procedural changes.` )} {temporalTrends.trend === 'stable' && ( `Compliance rates remain stable. Recent and historical defect rates are consistent.` )} </div> )} </div> ); }; const CrossAnalysisIntelligence = ({ intelligence }) => { if (!intelligence || intelligence.length === 0) { return null; } const recurringIssues = intelligence.filter(i => i.isRecurring); const novelIssues = intelligence.filter(i => i.isNovel); return ( <div style={{ padding: '20px', backgroundColor: '#f9fafb', borderRadius: '8px', marginBottom: '20px' }}><h3 style={{ marginBottom: '16px', fontSize: '18px', fontWeight: '600' }}> üîç Cross-Analysis Intelligence </h3> {novelIssues.length> 0 && ( <div style={{ marginBottom: '16px' }}><h4 style={{ fontSize: '14px', fontWeight: '600', color: '#0284c7', marginBottom: '8px' }}> ‚ö†Ô∏è NEW: {novelIssues.length} Novel Issue{novelIssues.length> 1 ? 's' : ''} Detected </h4> {novelIssues.map((item, idx) => ( <div key={idx} style={{ padding: '12px', backgroundColor: '#e0f2fe', borderRadius: '6px', marginBottom: '8px', border: '1px solid #0284c7' }}><div style={{ fontSize: '13px', fontWeight: '600', color: '#075985' }}> {item.defect.type} - {item.defect.severity} </div><div style={{ fontSize: '12px', color: '#0c4a6e', marginTop: '4px' }}> {item.defect.description} </div><div style={{ fontSize: '12px', color: '#0369a1', marginTop: '6px', fontStyle: 'italic' }}> üí° {item.recommendation} </div></div> ))} </div> )} {recurringIssues.length> 0 && ( <div><h4 style={{ fontSize: '14px', fontWeight: '600', color: '#dc2626', marginBottom: '8px' }}> üîÑ RECURRING: {recurringIssues.length} Previously Seen Issue{recurringIssues.length> 1 ? 's' : ''} </h4> {recurringIssues.map((item, idx) => ( <div key={idx} style={{ padding: '12px', backgroundColor: '#fef2f2', borderRadius: '6px', marginBottom: '8px', border: '1px solid #fecaca' }}><div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}><div style={{ flex: 1 }}><div style={{ fontSize: '13px', fontWeight: '600', color: '#991b1b' }}> {item.defect.type} - {item.defect.severity} </div><div style={{ fontSize: '12px', color: '#7f1d1d', marginTop: '4px' }}> {item.defect.description} </div><div style={{ fontSize: '11px', color: '#991b1b', marginTop: '6px' }}> üìä Previously occurred <strong>{item.previousOccurrences}</strong> time{item.previousOccurrences> 1 ? 's' : ''} <br /> First seen: {new Date(item.firstSeen).toLocaleDateString()} <br /> Last seen: {new Date(item.lastSeen).toLocaleDateString()} </div> {item.recommendation && ( <div style={{ marginTop: '8px', padding: '8px', backgroundColor: '#fff7ed', borderRadius: '4px', fontSize: '12px', color: '#92400e', border: '1px solid #fed7aa' }}><strong>üí° Systematic Recommendation:</strong> {item.recommendation} </div> )} </div><span style={{ padding: '4px 10px', backgroundColor: '#dc2626', color: 'white', borderRadius: '12px', fontSize: '12px', fontWeight: '600', whiteSpace: 'nowrap', marginLeft: '12px' }}> {item.previousOccurrences}x </span></div></div> ))} </div> )} </div> ); }; const PatternDetector = { async analyze(currentAnalysis, historicalAnalyses) { const patterns = { recurring: [], emerging: [], resolved: [] }; const defectCounts = {}; historicalAnalyses.forEach(analysis => { if (analysis.defects) { analysis.defects.forEach(defect => { const key = `${defect.type}|${defect.description}`; defectCounts[key] = (defectCounts[key] || 0) + 1; }); } }); Object.entries(defectCounts).forEach(([key, count]) => { if (count>= 3) { const [type, description] = key.split('|'); patterns.recurring.push({ type, description, frequency: count, firstSeen: this.findFirstOccurrence(type, description, historicalAnalyses), lastSeen: this.findLastOccurrence(type, description, historicalAnalyses), recommendation: this.generateRecommendation(type, description, count) }); } }); return patterns; }, findFirstOccurrence(type, description, analyses) { for (let analysis of analyses) { if (analysis.defects) { const found = analysis.defects.find(d => d.type === type && d.description === description); if (found) return analysis.timestamp; } } return null; }, findLastOccurrence(type, description, analyses) { for (let i = analyses.length - 1; i>= 0; i--) { if (analyses[i].defects) { const found = analyses[i].defects.find(d => d.type === type && d.description === description); if (found) return analyses[i].timestamp; } } return null; }, generateRecommendation(type, description, frequency) { const recommendations = { 'Missing Statutory Reference': `After ${frequency} occurrences, consider creating a checklist template that includes all required statutory references for this document type.`, 'Mixed Mandatory/Discretionary Language': `This language ambiguity has appeared ${frequency} times. Recommend standardizing document language to use either "must/shall" OR "may" consistently, with clear section separation.`, 'Insufficient Detail': `Documents consistently lack detail. Create minimum content guidelines specifying required sections and minimum line/word counts.`, 'Acknowledged Defect': `Errors acknowledged ${frequency} times suggests a review process gap. Implement mandatory peer review before document finalization.`, 'Missing Primary Legislation': `After ${frequency} occurrences, consider creating a checklist template that includes all required statutory references for this document type.`, 'Insufficient Substantive Content': `Documents consistently lack detail. Create minimum content guidelines specifying required sections and minimum line/word counts.` }; return recommendations[type] || `Recurring issue (${frequency}x). Systematic review and process improvement recommended.`; } }; const getColorForSeverity = (severity) => { const colors = { 'critical': '#fecaca', 'high': '#fed7aa', 'medium': '#fef3c7', 'low': '#dbeafe' }; return colors[severity] || '#f3f4f6'; }; const findDefectsForReference = (reference, analysis) => { const related = []; const refLower = reference.toLowerCase(); ['fileA', 'fileB'].forEach(fileKey => { if (analysis.phaseA && analysis.phaseA[fileKey]) { analysis.phaseA[fileKey].forEach(preset => { const potentialIssues = preset.findings.potentialIssues; const issues = potentialIssues.issues || potentialIssues; if (Array.isArray(issues)) { issues.forEach(issue => { if (issue.description && issue.description.toLowerCase().includes(refLower)) { related.push({ type: issue.type, severity: issue.severity, description: issue.description }); } }); } }); } }); return related; }; const buildMatrix = (analysis) => { const matrix = []; const refs = []; if (analysis.phaseA) { ['fileA', 'fileB'].forEach(fileKey => { if (analysis.phaseA[fileKey] && analysis.phaseA[fileKey][0] && analysis.phaseA[fileKey][0].findings && analysis.phaseA[fileKey][0].findings.legalReferences) { refs.push(...analysis.phaseA[fileKey][0].findings.legalReferences); } }); } const uniqueRefs = []; const seen = new Set(); refs.forEach(ref => { const key = `${ref.type}:${ref.text}`.toLowerCase(); if (!seen.has(key)) { seen.add(key); uniqueRefs.push(ref); } }); uniqueRefs.forEach(ref => { const relatedDefects = findDefectsForReference(ref.text, analysis); const highSeverity = relatedDefects.filter(d => d.severity === 'high' || d.severity === 'critical' ); const compliant = highSeverity.length === 0; matrix.push({ statute: ref.text, section: ref.type, defects: relatedDefects.slice(0, 5), // Limit to 5 for display compliant: compliant, action: determineAction(relatedDefects, compliant) }); }); return matrix; }; const determineAction = (defects, compliant) => { if (compliant) return 'No action required - monitoring'; const highSeverity = defects.filter(d => d.severity === 'high' || d.severity === 'critical' ); if (highSeverity.length> 0) { return '‚ö†Ô∏è URGENT: Review and address high-severity issues immediately'; } return 'üìã Review medium/low issues and plan remediation'; }; const detectPatterns = (historicalAnalyses) => { if (!historicalAnalyses || historicalAnalyses.length === 0) return []; const patternCounts = {}; historicalAnalyses.forEach(analysis => { if (analysis.defects) { analysis.defects.forEach(defect => { const key = `${defect.type}|${defect.severity}`; if (!patternCounts[key]) { patternCounts[key] = { type: defect.type, severity: defect.severity, count: 0, descriptions: [] }; } patternCounts[key].count++; if (patternCounts[key].descriptions.length <3) { patternCounts[key].descriptions.push(defect.description); } }); } }); return Object.values(patternCounts).filter(p => p.count>= 2); }; const CrossReferenceMatrix = ({ analysis }) => { const matrix = React.useMemo(() => buildMatrix(analysis), [analysis]); if (!matrix || matrix.length === 0) { return ( <div style={{ padding: '20px', backgroundColor: '#f9fafb', textAlign: 'center' }}><p style={{ color: '#6b7280' }}>No statutory references found to create cross-reference matrix.</p></div> ); } return ( <div style={{ padding: '20px' }}><h3>üîó Cross-Reference Matrix</h3><p style={{ fontSize: '14px', color: '#6b7280', marginBottom: '16px' }}> Relationships between statutory references and identified defects </p><table style={{ width: '100%', borderCollapse: 'collapse', backgroundColor: 'white', boxShadow: '0 1px 3px rgba(0,0,0,0.12)', borderRadius: '8px', overflow: 'hidden' }}><thead><tr style={{ backgroundColor: '#f3f4f6' }}><th style={{ padding: '12px', textAlign: 'left', borderBottom: '2px solid #e5e7eb', fontWeight: '600', fontSize: '14px' }}>Statutory Reference</th><th style={{ padding: '12px', textAlign: 'left', borderBottom: '2px solid #e5e7eb', fontWeight: '600', fontSize: '14px' }}>Related Defects</th><th style={{ padding: '12px', textAlign: 'left', borderBottom: '2px solid #e5e7eb', fontWeight: '600', fontSize: '14px' }}>Compliance Status</th><th style={{ padding: '12px', textAlign: 'left', borderBottom: '2px solid #e5e7eb', fontWeight: '600', fontSize: '14px' }}>Action Required</th></tr></thead><tbody> {matrix.map((row, idx) => ( <tr key={idx} style={{ borderBottom: '1px solid #e5e7eb' }}><td style={{ padding: '12px', verticalAlign: 'top' }}><strong style={{ fontSize: '14px' }}>{row.statute}</strong><br /><span style={{ fontSize: '12px', color: '#666' }}> {row.section} </span></td><td style={{ padding: '12px', verticalAlign: 'top' }}> {row.defects.length> 0 ? ( row.defects.map((d, i) => ( <div key={i} style={{ padding: '4px 8px', marginBottom: '4px', backgroundColor: getColorForSeverity(d.severity), borderRadius: '4px', fontSize: '12px', border: '1px solid #e5e7eb' }}><strong>[{d.severity.toUpperCase()}]</strong> {d.type} </div> )) ) : ( <span style={{ fontSize: '12px', color: '#6b7280' }}>No related defects</span> )} </td><td style={{ padding: '12px', verticalAlign: 'top' }}><span style={{ padding: '4px 12px', borderRadius: '12px', fontSize: '12px', fontWeight: '600', backgroundColor: row.compliant ? '#d1fae5' : '#fee2e2', color: row.compliant ? '#065f46' : '#991b1b' }}> {row.compliant ? '‚úÖ Compliant' : '‚ö†Ô∏è Non-Compliant'} </span></td><td style={{ padding: '12px', fontSize: '13px', verticalAlign: 'top' }}> {row.action} </td></tr> ))} </tbody></table></div> ); }; const ContextualIntelligence = { async enhanceFindings(currentAnalysis, historicalAnalyses) { return { ...currentAnalysis, contextualInsights: { severity: this.compareSeverity(currentAnalysis, historicalAnalyses), trend: this.analyzeTrend(currentAnalysis, historicalAnalyses), recommendations: this.generateSmartRecommendations(currentAnalysis, historicalAnalyses), novelIssues: this.identifyNovelIssues(currentAnalysis, historicalAnalyses) } }; }, countSeverity(analysis, severity) { let count = 0; if (analysis.findings && analysis.findings.phaseA) { ['fileA', 'fileB'].forEach(fileKey => { if (analysis.findings.phaseA[fileKey]) { analysis.findings.phaseA[fileKey].forEach(preset => { const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues; if (Array.isArray(issues)) { count += issues.filter(i => i.severity === severity).length; } }); } }); } else if (analysis.defects) { count = analysis.defects.filter(d => d.severity === severity).length; } return count; }, compareSeverity(current, historical) { if (!historical || historical.length === 0) { return { status: 'baseline', message: 'This is your first analysis - establishing baseline metrics' }; } const currentHigh = this.countSeverity({ findings: current }, 'high'); const currentCritical = this.countSeverity({ findings: current }, 'critical'); const currentTotal = currentHigh + currentCritical; const avgHigh = historical.reduce((sum, a) => sum + this.countSeverity(a, 'high'), 0) / historical.length; const avgCritical = historical.reduce((sum, a) => sum + this.countSeverity(a, 'critical'), 0) / historical.length; const avgTotal = avgHigh + avgCritical; if (avgTotal === 0) { return { status: 'baseline', message: 'Insufficient historical data for comparison' }; } if (currentTotal> avgTotal * 1.5) { return { status: 'worse', message: `‚ö†Ô∏è Current analysis shows ${Math.round((currentTotal / avgTotal - 1) * 100)}% more high-severity issues than historical average`, data: { current: currentTotal, average: avgTotal.toFixed(1) } }; } else if (currentTotal <avgTotal * 0.5 && avgTotal> 0) { return { status: 'better', message: `‚úÖ Significant improvement: ${Math.round((1 - currentTotal / avgTotal) * 100)}% fewer high-severity issues`, data: { current: currentTotal, average: avgTotal.toFixed(1) } }; } return { status: 'stable', message: 'Issue severity within normal range', data: { current: currentTotal, average: avgTotal.toFixed(1) } }; }, analyzeTrend(current, historical) { if (!historical || historical.length <2) { return { direction: 'insufficient_data', message: 'Need at least 2 historical analyses to detect trends' }; } const recent = historical.slice(-5); const counts = recent.map(a => this.countSeverity(a, 'high') + this.countSeverity(a, 'critical')); const trend = counts[counts.length - 1] - counts[0]; if (trend> 2) { return { direction: 'worsening', message: 'üìà Issues increasing over recent analyses - systematic review recommended', data: { change: trend, samples: counts.length } }; } else if (trend <-2) { return { direction: 'improving', message: 'üìâ Issues decreasing - current processes appear effective', data: { change: trend, samples: counts.length } }; } return { direction: 'stable', message: 'No significant trend detected', data: { change: trend, samples: counts.length } }; }, generateSmartRecommendations(current, historical) { const recommendations = []; const currentIssues = []; if (current.phaseA) { ['fileA', 'fileB'].forEach(fileKey => { if (current.phaseA[fileKey]) { current.phaseA[fileKey].forEach(preset => { const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues; if (Array.isArray(issues)) { currentIssues.push(...issues); } }); } }); } const highSeverity = currentIssues.filter(i => i.severity === 'high' || i.severity === 'critical'); if (highSeverity.length> 3) { recommendations.push({ priority: 'high', category: 'Quality Control', recommendation: 'Multiple high-severity issues detected. Consider implementing a document review checklist before submission.', impact: 'Reduce critical defects by 40-60%' }); } const missingRefs = currentIssues.filter(i => i.type && (i.type.includes('Missing') || i.type.includes('Statute')) ); if (missingRefs.length> 0) { recommendations.push({ priority: 'medium', category: 'Statutory Compliance', recommendation: 'Create a statutory reference template for this document type to ensure all required references are included.', impact: 'Improve compliance by 30-50%' }); } const proceduralIssues = currentIssues.filter(i => i.type && (i.type.includes('Procedural') || i.type.includes('Fairness')) ); if (proceduralIssues.length> 0) { recommendations.push({ priority: 'high', category: 'Procedural Compliance', recommendation: 'Review procedural requirements and implement mandatory peer review for procedural fairness.', impact: 'Reduce jurisdictional errors' }); } if (recommendations.length === 0) { recommendations.push({ priority: 'low', category: 'Monitoring', recommendation: 'Continue current document preparation processes - quality metrics are within acceptable range.', impact: 'Maintain current standards' }); } return recommendations; }, identifyNovelIssues(current, historical) { if (!historical || historical.length === 0) { return []; } const historicalTypes = new Set(); historical.forEach(analysis => { if (analysis.defects) { analysis.defects.forEach(defect => { historicalTypes.add(defect.type); }); } }); const novelIssues = []; if (current.phaseA) { ['fileA', 'fileB'].forEach(fileKey => { if (current.phaseA[fileKey]) { current.phaseA[fileKey].forEach(preset => { const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues; if (Array.isArray(issues)) { issues.forEach(issue => { if (!historicalTypes.has(issue.type)) { novelIssues.push({ type: issue.type, severity: issue.severity, description: issue.description, preset: preset.preset }); } }); } }); } }); } return novelIssues; } }; const ExportUtils = { exportAsJSON(analysisResults, filename = 'forensic-analysis.json') { const exportData = { metadata: { exportDate: new Date().toISOString(), applicationVersion: '2.0.0', analysisType: 'Victorian Legal Document Analysis' }, analysis: analysisResults, defects: this.extractAllDefects(analysisResults), summary: this.generateSummary(analysisResults) }; const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' }); saveAs(blob, filename); }, async exportAsPDF(analysisResults, filename = 'forensic-analysis-report.pdf') { const { jsPDF } = window.jspdf; const doc = new jsPDF(); let yPos = 20; const pageWidth = doc.internal.pageSize.getWidth(); const margin = 20; doc.setFontSize(24); doc.setFont(undefined, 'bold'); doc.text('Forensic Legal Analysis Report', pageWidth / 2, yPos, { align: 'center' }); yPos += 15; doc.setFontSize(12); doc.setFont(undefined, 'normal'); doc.text(`Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, pageWidth / 2, yPos, { align: 'center' }); yPos += 20; doc.setFontSize(16); doc.setFont(undefined, 'bold'); doc.text('Executive Summary', margin, yPos); yPos += 10; const summary = this.generateSummary(analysisResults); doc.setFontSize(10); doc.setFont(undefined, 'normal'); doc.text(`Total Defects Found: ${summary.totalDefects}`, margin, yPos); yPos += 6; doc.text(`Critical Issues: ${summary.criticalCount}`, margin, yPos); yPos += 6; doc.text(`High Priority Issues: ${summary.highCount}`, margin, yPos); yPos += 6; doc.text(`Medium Priority Issues: ${summary.mediumCount}`, margin, yPos); yPos += 6; doc.text(`Low Priority Issues: ${summary.lowCount}`, margin, yPos); yPos += 15; if (yPos> 250) { doc.addPage(); yPos = 20; } doc.setFontSize(14); doc.setFont(undefined, 'bold'); doc.text('Defect Summary', margin, yPos); yPos += 10; const defects = this.extractAllDefects(analysisResults); const tableData = defects.map(d => [ d.preset || d.phase, d.type || 'General', d.severity || 'N/A', (d.description || '').substring(0, 60) + '...' ]); doc.autoTable({ startY: yPos, head: [['Preset/Phase', 'Type', 'Severity', 'Description']], body: tableData, styles: { fontSize: 8 }, headStyles: { fillColor: [37, 99, 235] }, margin: { left: margin, right: margin } }); yPos = doc.lastAutoTable.finalY + 15; if (yPos> 250) { doc.addPage(); yPos = 20; } doc.setFontSize(14); doc.setFont(undefined, 'bold'); doc.text('Statutory Compliance Matrix', margin, yPos); yPos += 10; const statutoryRefs = this.extractStatutoryReferences(analysisResults); if (statutoryRefs.length> 0) { const statutoryData = statutoryRefs.slice(0, 20).map(ref => [ ref.text, ref.type, ref.compliance || 'Under Review' ]); doc.autoTable({ startY: yPos, head: [['Statutory Reference', 'Type', 'Compliance Status']], body: statutoryData, styles: { fontSize: 8 }, headStyles: { fillColor: [37, 99, 235] }, margin: { left: margin, right: margin } }); yPos = doc.lastAutoTable.finalY + 15; } if (yPos> 250) { doc.addPage(); yPos = 20; } doc.setFontSize(14); doc.setFont(undefined, 'bold'); doc.text('Recommendations', margin, yPos); yPos += 10; doc.setFontSize(10); doc.setFont(undefined, 'normal'); const recommendations = this.generateRecommendations(summary); recommendations.forEach((rec, index) => { if (yPos> 270) { doc.addPage(); yPos = 20; } doc.text(`${index + 1}. ${rec}`, margin, yPos, { maxWidth: pageWidth - 2 * margin }); yPos += 8; }); doc.save(filename); }, async exportAsWord(analysisResults, filename = 'forensic-analysis.docx') { const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, Table, TableRow, TableCell, WidthType } = docx; const summary = this.generateSummary(analysisResults); const defects = this.extractAllDefects(analysisResults); const doc = new Document({ sections: [{ properties: {}, children: [ new Paragraph({ text: 'Forensic Legal Analysis Report', heading: HeadingLevel.TITLE, alignment: AlignmentType.CENTER, }), new Paragraph({ text: `Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`, alignment: AlignmentType.CENTER, }), new Paragraph({ text: '' }), new Paragraph({ text: 'Executive Summary', heading: HeadingLevel.HEADING_1, }), new Paragraph({ children: [ new TextRun({ text: 'Total Defects Found: ', bold: true }), new TextRun({ text: summary.totalDefects.toString() }), ], }), new Paragraph({ children: [ new TextRun({ text: 'Critical Issues: ', bold: true }), new TextRun({ text: summary.criticalCount.toString() }), ], }), new Paragraph({ children: [ new TextRun({ text: 'High Priority Issues: ', bold: true }), new TextRun({ text: summary.highCount.toString() }), ], }), new Paragraph({ children: [ new TextRun({ text: 'Medium Priority Issues: ', bold: true }), new TextRun({ text: summary.mediumCount.toString() }), ], }), new Paragraph({ children: [ new TextRun({ text: 'Low Priority Issues: ', bold: true }), new TextRun({ text: summary.lowCount.toString() }), ], }), new Paragraph({ text: '' }), new Paragraph({ text: 'Key Defects Identified', heading: HeadingLevel.HEADING_1, }), ...defects.slice(0, 50).map(defect => new Paragraph({ children: [ new TextRun({ text: `[${defect.severity || 'N/A'}] `, bold: true }), new TextRun({ text: `${defect.preset || defect.phase}: ` }), new TextRun({ text: defect.description || defect.type || 'No description' }), ], bullet: { level: 0 }, }) ), new Paragraph({ text: '' }), new Paragraph({ text: 'Recommendations', heading: HeadingLevel.HEADING_1, }), ...this.generateRecommendations(summary).map(rec => new Paragraph({ text: rec, bullet: { level: 0 }, }) ), ], }], }); const blob = await Packer.toBlob(doc); saveAs(blob, filename); }, exportAsCSV(analysisResults, filename = 'defects-only.csv') { const defects = this.extractAllDefects(analysisResults); let csv = 'Date,Defect Type,Severity,Statute,Description,Recommendation\n'; defects.forEach(defect => { const row = [ new Date().toLocaleDateString(), (defect.type || 'General').replace(/,/g, ';'), defect.severity || 'N/A', (defect.statute || 'N/A').replace(/,/g, ';'), (defect.description || '').replace(/,/g, ';').substring(0, 200), (defect.recommendation || 'Review required').replace(/,/g, ';') ]; csv += row.map(field => `"${field}"`).join(',') + '\n'; }); const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' }); saveAs(blob, filename); }, extractAllDefects(results) { const defects = []; if (results.phaseA) { ['fileA', 'fileB'].forEach(fileKey => { if (results.phaseA[fileKey]) { results.phaseA[fileKey].forEach(preset => { const issues = preset.findings?.potentialIssues?.issues || preset.findings?.potentialIssues || []; if (Array.isArray(issues)) { issues.forEach(issue => { defects.push({ phase: 'A', preset: preset.preset, severity: issue.severity, type: issue.type, description: issue.description, file: fileKey, statute: issue.statute || 'N/A', recommendation: issue.recommendation }); }); } }); } }); } if (results.phaseB) { if (results.phaseB.discrepancies) { results.phaseB.discrepancies.forEach(disc => { defects.push({ phase: 'B', type: 'discrepancy', severity: disc.severity, description: disc.description, statute: 'Cross-document analysis' }); }); } if (results.phaseB.omissions) { results.phaseB.omissions.forEach(om => { defects.push({ phase: 'B', type: 'omission', severity: 'Medium', element: om.element, description: `${om.element} - ${om.status}`, statute: 'Document completeness' }); }); } } if (results.phaseC && results.phaseC.defects) { results.phaseC.defects.forEach(defect => { defects.push({ phase: 'C', ...defect }); }); } if (results.phaseD && results.phaseD.defects) { results.phaseD.defects.forEach(defect => { defects.push({ phase: 'D', ...defect }); }); } return defects; }, generateSummary(results) { const defects = this.extractAllDefects(results); return { totalDefects: defects.length, criticalCount: defects.filter(d => d.severity === 'Critical').length, highCount: defects.filter(d => d.severity === 'High').length, mediumCount: defects.filter(d => d.severity === 'Medium').length, lowCount: defects.filter(d => d.severity === 'Low').length, byPhase: { A: defects.filter(d => d.phase === 'A').length, B: defects.filter(d => d.phase === 'B').length, C: defects.filter(d => d.phase === 'C').length, D: defects.filter(d => d.phase === 'D').length } }; }, extractStatutoryReferences(results) { const refs = []; if (results.phaseA) { ['fileA', 'fileB'].forEach(fileKey => { if (results.phaseA[fileKey] && results.phaseA[fileKey][0]?.findings?.legalReferences) { results.phaseA[fileKey][0].findings.legalReferences.forEach(ref => { refs.push({ text: ref.text, type: ref.type, source: fileKey }); }); } }); } return refs; }, generateRecommendations(summary) { const recs = []; if (summary.criticalCount> 0) { recs.push(`URGENT: ${summary.criticalCount} critical issues require immediate attention. These may render proceedings invalid.`); } if (summary.highCount> 0) { recs.push(`HIGH PRIORITY: ${summary.highCount} high-priority issues should be addressed before court proceedings.`); } if (summary.mediumCount> 0) { recs.push(`Review ${summary.mediumCount} medium-priority issues for compliance improvements.`); } if (summary.byPhase.B> 0) { recs.push('Cross-document discrepancies detected. Ensure all documents are properly synchronized and consistent.'); } if (summary.byPhase.C> 0) { recs.push('Victorian statutory compliance issues identified. Consult with legal counsel on legislative requirements.'); } if (summary.byPhase.D> 0) { recs.push('Criminal procedure defects found. Review Magistrates\' Court procedures and rectify before hearing.'); } if (summary.totalDefects === 0) { recs.push('No significant defects found. Documents appear to meet Victorian legal standards.'); } return recs; } }; const ForensicLegalAnalyzer = () => { const [files, setFiles] = useState({ fileA: null, fileB: null }); const [fileContents, setFileContents] = useState({ fileA: '', fileB: '' }); const [analysisState, setAnalysisState] = useState('idle'); const [currentPhase, setCurrentPhase] = useState(''); const [analysisResults, setAnalysisResults] = useState(null); const [expandedSections, setExpandedSections] = useState({}); const [historicalAnalyses, setHistoricalAnalyses] = useState([]); const [detectedPatterns, setDetectedPatterns] = useState(null); const [contextualInsights, setContextualInsights] = useState(null); const [uploadProgress, setUploadProgress] = useState({ fileA: 0, fileB: 0 }); const [isUploading, setIsUploading] = useState({ fileA: false, fileB: false }); const [analysisProgress, setAnalysisProgress] = useState(0); const [currentPreset, setCurrentPreset] = useState(''); const [defectCounter, setDefectCounter] = useState(0); const [darkMode, setDarkMode] = useState(false); const [viewMode, setViewMode] = useState('analysis'); // 'analysis', 'dashboard', 'comparison' const [searchTerm, setSearchTerm] = useState(''); const [filterSeverity, setFilterSeverity] = useState('all'); // 'all', 'high', 'medium+', 'by-statute' const [printMode, setPrintMode] = useState(false); const [comparisonAnalyses, setComparisonAnalyses] = useState([null, null]); const [showSettings, setShowSettings] = useState(false); const [settings, setSettings] = useState({ severityThresholds: { critical: 90, high: 70, medium: 40 }, priorityStatutes: ['Crimes Act', 'Evidence Act', 'Criminal Procedure Act'], exportFormat: 'pdf', autoSaveFrequency: 5, dataRetentionDays: 90 }); const fileInputA = useRef(null); const fileInputB = useRef(null); React.useEffect(() => { document.documentElement.setAttribute('data-theme', darkMode ? 'dark' : 'light'); }, [darkMode]); React.useEffect(() => { AnalysisMemory.init().then(() => { return AnalysisMemory.getAllAnalyses(); }).then(analyses => { setHistoricalAnalyses(analyses || []); }).catch(err => { console.error('Failed to initialize storage:', err); }); }, []); const interpretivePresets = [ { name: 'Statutory Procedural Analysis', description: 'Examines compliance with statutory requirements, procedural mandates, and legislative frameworks', focus: ['compliance', 'procedure', 'statutory_requirements', 'jurisdictional_prerequisites'] }, { name: 'Contextual Analysis', description: 'Evaluates meaning within broader legislative, factual, and temporal context', focus: ['surrounding_circumstances', 'legislative_scheme', 'temporal_context', 'factual_matrix'] }, { name: 'Jurisprudential Analysis', description: 'Applies established legal principles, precedents, and interpretative doctrines', focus: ['precedent', 'common_law_principles', 'interpretative_doctrines', 'judicial_reasoning'] }, { name: 'Objective Textual Analysis', description: 'Focuses on plain meaning, literal interpretation, and grammatical construction', focus: ['plain_meaning', 'grammatical_analysis', 'ordinary_meaning', 'textual_structure'] }, { name: 'Subjective Intent Analysis', description: 'Considers apparent intentions, representations, and assertions within documents', focus: ['stated_intentions', 'apparent_purposes', 'declarations', 'subjective_assertions'] }, { name: 'Purposive Analysis', description: 'Examines legislative purpose, policy objectives, and intended outcomes', focus: ['legislative_purpose', 'policy_objectives', 'mischief_rule', 'intended_effect'] }, { name: 'Comparative Cross-Reference Analysis', description: 'Identifies inconsistencies, contradictions, and discrepancies between documents', focus: ['consistency', 'contradictions', 'omissions', 'discrepancies'] }, { name: 'Evidentiary Standards Analysis', description: 'Evaluates evidentiary sufficiency, admissibility, and probative value', focus: ['admissibility', 'relevance', 'probative_value', 'evidentiary_weight'] } ]; const classifyDocumentType = (filename, content) => { const types = { 'Statutory Legislation': /\bact\s+\d{4}\b|primary legislation|statute/i, 'Delegated Legislation': /\bregulation|rules|order|instrument\b/i, 'Victoria Police Manual': /\bvictoria police|vpm|police manual|operational procedure/i, 'Disclosure Document': /\bdisclosure|discovery|prosecution brief/i, 'Evidence Exhibit': /\bexhibit|evidentiary material|physical evidence/i, 'Statement': /\bstatement of|witness statement|affidavit|statutory declaration/i, 'Court Order': /\border of the court|court order|judicial order/i, 'Evidentiary Certificate': /\bevidentiary certificate|certificate of|s\.\s*\d+\s+certificate/i, 'Summons': /\bsummons|witness summons|subpoena/i, 'Charge Sheet': /\bcharge sheet|charges|indictment|complaint/i, 'Submission': /\bsubmission|written submission|legal submission/i, 'Deposition': /\bdeposition|committal|preliminary hearing/i, 'Case Law': /\b[A-Z][a-z]+\s+v\s+[A-Z][a-z]+|\[\d{4}\]|CLR|VR|VSC/, 'Legal Narrative': /\bnarrativ|chronolog|fact pattern|sequence of events/i, 'Court Documentation': /\bfiling|pleading|court document|notice of/i }; for (const [type, pattern] of Object.entries(types)) { if (pattern.test(content) || pattern.test(filename)) { return type; } } return 'General Legal Document'; }; const identifyVictorianFramework = (content, documentType) => { const framework = { primaryLegislation: [], subordinateInstrumentation: [], jurisdiction: 'Victoria, Australia', governingCourts: [], relevantPoliceProcedures: [], applicableEvidentRules: [] }; const vicActPatterns = [ /Criminal\s+Procedure\s+Act\s+2009/gi, /Evidence\s+Act\s+2008/gi, /Crimes\s+Act\s+1958/gi, /Charter\s+of\s+Human\s+Rights\s+and\s+Responsibilities\s+Act\s+2006/gi, /Victoria\s+Police\s+Act\s+2013/gi, /Sentencing\s+Act\s+1991/gi, /Children,\s+Youth\s+and\s+Families\s+Act\s+2005/gi, /Supreme\s+Court\s+Act\s+1986/gi, /Magistrates[\'']?\s+Court\s+Act\s+1989/gi, /County\s+Court\s+Act\s+1958/gi, /Bail\s+Act\s+1977/gi, /Confiscation\s+Act\s+1997/gi ]; vicActPatterns.forEach(pattern => { const matches = content.match(pattern); if (matches) { framework.primaryLegislation.push(...new Set(matches)); } }); const vicRegPatterns = [ /Criminal\s+Procedure\s+Regulations/gi, /Evidence\s+\(Miscellaneous\s+Provisions\s*\)\s+Regulations/gi, /Victoria\s+Police\s+Regulations/gi, /Supreme\s+Court\s+\(General\s+Civil\s+Procedure\s*\)\s+Rules/gi, /Magistrates[\'']?\s+Court\s+General\s+Civil\s+Procedure\s+Rules/gi ]; vicRegPatterns.forEach(pattern => { const matches = content.match(pattern); if (matches) { framework.subordinateInstrumentation.push(...new Set(matches)); } }); const courtPatterns = [ /Supreme\s+Court\s+of\s+Victoria/gi, /County\s+Court\s+of\s+Victoria/gi, /Magistrates[\'']?\s+Court\s+of\s+Victoria/gi, /Children[\'']?s\s+Court\s+of\s+Victoria/gi, /Coroners\s+Court\s+of\s+Victoria/gi ]; courtPatterns.forEach(pattern => { const matches = content.match(pattern); if (matches) { framework.governingCourts.push(...new Set(matches)); } }); if (documentType === 'Victoria Police Manual' || content.match(/victoria\s+police/i)) { const vpmPatterns = [ /VPM\s+[A-Z0-9-]+/g, /Operational\s+Procedure\s+\d+/gi, /Victoria\s+Police\s+Manual\s+Section\s+\d+/gi ]; vpmPatterns.forEach(pattern => { const matches = content.match(pattern); if (matches) { framework.relevantPoliceProcedures.push(...new Set(matches)); } }); } const evidenceRules = [ /s\.\s*\d+\s+Evidence\s+Act/gi, /section\s+\d+\s+of\s+the\s+Evidence\s+Act/gi, /Division\s+\d+\s+of\s+Part\s+\d+\s+of\s+the\s+Evidence\s+Act/gi ]; evidenceRules.forEach(pattern => { const matches = content.match(pattern); if (matches) { framework.applicableEvidentRules.push(...new Set(matches)); } }); return framework; }; const extractTextWithOCR = async (file, fileKey, onProgress) => { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = async (e) => { try { const { data: { text } } = await Tesseract.recognize( e.target.result, 'eng', { logger: (m) => { if (m.status === 'recognizing text') { const progress = Math.round(m.progress * 100); if (onProgress) { onProgress(progress); } } } } ); resolve(text); } catch (error) { console.error('OCR extraction failed:', error); reject(error); } }; reader.onerror = () => reject(new Error('Failed to read file')); reader.readAsDataURL(file); }); }; const extractTextFromPDF = async (file, fileKey, onProgress) => { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = async (e) => { try { const typedArray = new Uint8Array(e.target.result); const loadingTask = pdfjsLib.getDocument(typedArray); const pdf = await loadingTask.promise; const numPages = pdf.numPages; let fullText = ''; for (let pageNum = 1; pageNum <= numPages; pageNum++) { const page = await pdf.getPage(pageNum); const textContent = await page.getTextContent(); const pageText = textContent.items.map(item => item.str).join(' '); fullText += pageText + '\n\n'; const progress = Math.round((pageNum / numPages) * 100); if (onProgress) { onProgress(progress); } console.log(`Processed page ${pageNum}/${numPages} (${progress}%)`); } resolve(fullText); } catch (error) { console.error('PDF extraction failed:', error); reject(error); } }; reader.onerror = () => reject(new Error('Failed to read PDF file')); reader.readAsArrayBuffer(file); }); }; const FILE_VALIDATION = { MAX_SIZE: 50 * 1024 * 1024, // 50MB ALLOWED_TYPES: [ 'application/pdf', 'text/plain', 'image/png', 'image/jpeg', 'image/jpg', 'image/gif', 'image/bmp', 'image/tiff' ], ALLOWED_EXTENSIONS: ['.pdf', '.txt', '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.tif'] }; const validateFile = (file) => { const errors = []; if (!file) { errors.push('No file selected'); return { valid: false, errors }; } if (file.size> FILE_VALIDATION.MAX_SIZE) { errors.push(`File size exceeds maximum allowed size (50MB). File size: ${(file.size / 1024 / 1024).toFixed(2)}MB`); } if (file.size === 0) { errors.push('File is empty'); } const fileName = file.name.toLowerCase(); const fileExtension = fileName.substring(fileName.lastIndexOf('.')); const fileType = file.type.toLowerCase(); const hasValidType = FILE_VALIDATION.ALLOWED_TYPES.includes(fileType); const hasValidExtension = FILE_VALIDATION.ALLOWED_EXTENSIONS.some(ext => fileName.endsWith(ext)); if (!hasValidType && !hasValidExtension) { errors.push(`Unsupported file type. Allowed types: PDF, Text files, Images (PNG, JPG, GIF, BMP, TIFF)`); } if (fileName.includes('..') || fileName.includes('/') || fileName.includes('\\')) { errors.push('Invalid filename'); } return { valid: errors.length === 0, errors: errors }; }; const handleFileUpload = async (file, fileKey) => { if (!file) { console.error('No file provided to handleFileUpload'); return; } const validation = validateFile(file); if (!validation.valid) { alert(`File validation failed:\n\n${validation.errors.join('\n')}`); console.error('File validation errors:', validation.errors); return; } setIsUploading(prev => ({ ...prev, [fileKey]: true })); setUploadProgress(prev => ({ ...prev, [fileKey]: 0 })); try { let content = ''; const fileType = file.type; const fileName = file.name.toLowerCase(); console.log(`File size: ${(file.size / 1024 / 1024).toFixed(2)}MB`); if (fileType === 'application/pdf' || fileName.endsWith('.pdf')) { setUploadProgress(prev => ({ ...prev, [fileKey]: 5 })); content = await extractTextFromPDF(file, fileKey, (progress) => { const mappedProgress = 5 + Math.round(progress * 0.65); setUploadProgress(prev => ({ ...prev, [fileKey]: mappedProgress })); }); } else if (fileType.startsWith('image/') || fileName.endsWith('.png') || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.gif') || fileName.endsWith('.bmp') || fileName.endsWith('.tiff')) { setUploadProgress(prev => ({ ...prev, [fileKey]: 5 })); content = await extractTextWithOCR(file, fileKey, (progress) => { const mappedProgress = 5 + Math.round(progress * 0.65); setUploadProgress(prev => ({ ...prev, [fileKey]: mappedProgress })); }); } else { content = await new Promise((resolve, reject) => { const reader = new FileReader(); reader.onprogress = (e) => { if (e.lengthComputable) { const progress = 5 + Math.round((e.loaded / e.total) * 65); setUploadProgress(prev => ({ ...prev, [fileKey]: progress })); } }; reader.onload = (e) => resolve(e.target.result); reader.onerror = () => reject(new Error('Failed to read text file')); reader.readAsText(file); }); } if (!content || content.trim().length === 0) { throw new Error('No text could be extracted from the file. The file may be empty or the format is not supported.'); } setUploadProgress(prev => ({ ...prev, [fileKey]: 75 })); const documentType = classifyDocumentType(file.name, content); const framework = identifyVictorianFramework(content, documentType); setUploadProgress(prev => ({ ...prev, [fileKey]: 90 })); const enhancedFile = { ...file, documentType: documentType, framework: framework, uploadTimestamp: new Date().toISOString(), extractionMethod: fileType === 'application/pdf' ? 'PDF Extraction' : fileType.startsWith('image/') ? 'OCR (Tesseract)' : 'Plain Text' }; setFiles(prev => ({ ...prev, [fileKey]: enhancedFile })); setFileContents(prev => ({ ...prev, [fileKey]: content })); setUploadProgress(prev => ({ ...prev, [fileKey]: 100 })); if (typeof ForensicAnalyzerConfig !== 'undefined' && ForensicAnalyzerConfig.utils.runAutomatedAnalysis) { console.log(`\n${'='.repeat(80)}`); console.log(`AUTOMATED COMPLIANCE ANALYSIS - ${fileKey.toUpperCase()}`); console.log('='.repeat(80)); const automatedResults = ForensicAnalyzerConfig.utils.runAutomatedAnalysis(content, file.name); enhancedFile.automatedAnalysis = automatedResults; setFiles(prev => ({ ...prev, [fileKey]: enhancedFile })); console.log('‚îÄ'.repeat(80)); if (automatedResults.reasonableBeliefTest) { } if (automatedResults.overallCompliance.recommendations.length> 0) { automatedResults.overallCompliance.recommendations.forEach((rec, idx) => { console.log(`${idx + 1}. [${rec.priority.toUpperCase()}] ${rec.recommendation}`); }); } console.log('='.repeat(80) + '\n'); } setTimeout(() => { setIsUploading(prev => ({ ...prev, [fileKey]: false })); }, 300); } catch (error) { console.error(`Error processing file ${file.name}:`, error); alert(`Failed to process file: ${error.message}\n\nSupported formats:\n- PDF documents (.pdf)\n- Images (.png, .jpg, .jpeg, .gif, .bmp, .tiff) - OCR will be performed\n- Text files (.txt, .doc, .docx)`); setIsUploading(prev => ({ ...prev, [fileKey]: false })); setUploadProgress(prev => ({ ...prev, [fileKey]: 0 })); } }; const handleUrlUpload = async (url, fileKey) => { try { const response = await fetch(url); const content = await response.text(); setFiles(prev => ({ ...prev, [fileKey]: { name: url.split('/').pop(), type: 'url' } })); setFileContents(prev => ({ ...prev, [fileKey]: content })); } catch (error) { alert('Failed to fetch document from URL. Please ensure the URL is accessible and points to a text document.'); } }; const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); }; const handleDrop = (e, fileKey) => { e.preventDefault(); e.stopPropagation(); const file = e.dataTransfer.files[0]; if (file) handleFileUpload(file, fileKey); }; const simulateAnalysis = async () => { setAnalysisState('analyzing'); setAnalysisResults(null); setAnalysisProgress(0); setCurrentPhase('Phase A: Multi-Preset Forensic Examination'); setAnalysisProgress(10); await new Promise(resolve => setTimeout(resolve, 2000)); const phaseAResults = { fileA: interpretivePresets.map(preset => ({ preset: preset.name, findings: generateFindings(fileContents.fileA, preset) })), fileB: interpretivePresets.map(preset => ({ preset: preset.name, findings: generateFindings(fileContents.fileB, preset) })) }; setAnalysisProgress(40); setCurrentPhase('Phase B: Victorian Criminal Compliance & Statutory Cross-Reference Analysis'); await new Promise(resolve => setTimeout(resolve, 2000)); const phaseBResults = performCrossReference(phaseAResults); setAnalysisProgress(65); setCurrentPhase('Phase C: Statutory Interpretation & Legislative Purpose Analysis'); await new Promise(resolve => setTimeout(resolve, 2000)); const phaseCResults = performStatutoryInterpretation(phaseAResults, phaseBResults); setAnalysisProgress(70); setCurrentPhase('Phase D: Victorian Magistrates\' Court Criminal Procedure Analysis'); await new Promise(resolve => setTimeout(resolve, 2000)); const phaseDResults = await performMagistratesCourtAnalysis(phaseAResults, phaseBResults, phaseCResults); setAnalysisProgress(80); const finalResults = { phaseA: phaseAResults, phaseB: phaseBResults, phaseC: phaseCResults, phaseD: phaseDResults, summary: generateExecutiveSummary(phaseAResults, phaseBResults, phaseCResults, phaseDResults) }; setAnalysisResults(finalResults); setAnalysisProgress(90); const analysisId = await AnalysisMemory.saveAnalysis(finalResults, files, fileContents); const updatedAnalyses = await AnalysisMemory.getAllAnalyses(); setHistoricalAnalyses(updatedAnalyses || []); setAnalysisProgress(92); const learningInsights = await AnalysisMemory.generateLearningInsights(); setAnalysisProgress(94); const currentDefects = AnalysisMemory.extractDefects(finalResults); const crossIntelligence = await AnalysisMemory.getIntelligenceForAnalysis(currentDefects); setContextualInsights({ learningInsights: learningInsights, crossIntelligence: crossIntelligence }); setAnalysisProgress(96); if (updatedAnalyses && updatedAnalyses.length> 0) { const patterns = await PatternDetector.analyze(finalResults, updatedAnalyses); setDetectedPatterns(patterns); } const totalDefects = ExportUtils.extractAllDefects(finalResults).length; setDefectCounter(totalDefects); setAnalysisProgress(100); setAnalysisState('complete'); setCurrentPhase('Analysis Complete - Intelligence Insights Ready'); }; const performLinguisticInspection = (content, documentType, framework) => { const lines = content.split('\n'); const linguisticReport = { totalWords: 0, totalLines: lines.length, lineByLineAnalysis: [], wordAccuracyIssues: [], grammaticalDefects: [], legalTerminologyIssues: [], victorianComplianceDefects: [] }; lines.forEach((line, lineIndex) => { const lineNumber = lineIndex + 1; const words = line.trim().split(/\s+/).filter(w => w.length> 0); linguisticReport.totalWords += words.length; const lineAnalysis = { lineNumber: lineNumber, content: line, wordCount: words.length, issues: [], wordByWordInspection: [] }; words.forEach((word, wordIndex) => { const wordPosition = wordIndex + 1; const cleanWord = word.replace(/[^\w\s'-]/g, '').toLowerCase(); const wordInspection = { position: wordPosition, word: word, issues: [] }; const victorianTermIssues = checkVictorianLegalTerminology(word, cleanWord, documentType); if (victorianTermIssues.length> 0) { wordInspection.issues.push(...victorianTermIssues); linguisticReport.legalTerminologyIssues.push({ line: lineNumber, word: word, position: wordPosition, issues: victorianTermIssues }); } const spellingIssues = checkLegalSpelling(word, cleanWord); if (spellingIssues) { wordInspection.issues.push(spellingIssues); linguisticReport.wordAccuracyIssues.push({ line: lineNumber, word: word, position: wordPosition, issue: spellingIssues }); } if (wordInspection.issues.length> 0) { lineAnalysis.wordByWordInspection.push(wordInspection); } }); const lineIssues = performLineInspection(line, lineNumber, documentType, framework); lineAnalysis.issues.push(...lineIssues); if (lineIssues.length> 0) { linguisticReport.grammaticalDefects.push(...lineIssues.map(issue => ({ line: lineNumber, content: line, issue: issue }))); } linguisticReport.lineByLineAnalysis.push(lineAnalysis); }); return linguisticReport; }; const checkVictorianLegalTerminology = (originalWord, cleanWord, documentType) => { const issues = []; // Victorian-specific terminology that must be accurate const victorianTerms = { 'informant': { correct: 'informant', common_errors: ['informent', 'informent'], context: 'Victorian police terminology' }, 'indictable': { correct: 'indictable', common_errors: ['indicatable', 'indictible'], context: 'Victorian criminal law' }, 'committals': { correct: 'committals', common_errors: ['commitals', 'commital'], context: 'Victorian court procedure' }, 'magistrate': { correct: 'magistrate', common_errors: ['magistrait', 'magistrat'], context: 'Victorian judicial officer' }, 'summons': { correct: 'summons', common_errors: ['summon', 'summonses'], context: 'Victorian court process' }, 'pursuant': { correct: 'pursuant', common_errors: ['persuan', 'persuant'], context: 'Legal terminology' }, 'defence': { correct: 'defence', american: 'defense', context: 'Australian spelling (not defense)' }, 'practitioner': { correct: 'practitioner', common_errors: ['practisioner', 'practioner'], context: 'Legal practitioner' }, 'recognised': { correct: 'recognised', american: 'recognized', context: 'Australian spelling (not recognized)' }, 'summarised': { correct: 'summarised', american: 'summarized', context: 'Australian spelling (not summarized)' } }; for (const [term, info] of Object.entries(victorianTerms)) { if (info.common_errors && info.common_errors.includes(cleanWord)) { issues.push({ type: 'Victorian Legal Terminology Error', severity: 'high', description: `"${originalWord}" should be "${info.correct}" in ${info.context}`, correct: info.correct, context: info.context }); } if (info.american && cleanWord === info.american) { issues.push({ type: 'Australian Spelling Required', severity: 'medium', description: `"${originalWord}" uses American spelling. Victorian documents require "${info.correct}"`, correct: info.correct, context: info.context }); } } return issues; }; const checkLegalSpelling = (word, cleanWord) => { const commonLegalMisspellings = { 'achive': 'achieve', 'admissable': 'admissible', 'alledge': 'allege', 'arguement': 'argument', 'benificial': 'beneficial', 'calender': 'calendar', 'comitted': 'committed', 'complience': 'compliance', 'defendent': 'defendant', 'discreation': 'discretion', 'existance': 'existence', 'fourty': 'forty', 'gaurd': 'guard', 'guidence': 'guidance', 'independant': 'independent', 'judgement': 'judgment', // Note: In Australian legal context, both are acceptable 'liason': 'liaison', 'maintainance': 'maintenance', 'occassion': 'occasion', 'occurance': 'occurrence', 'persue': 'pursue', 'preceed': 'precede', 'priviledge': 'privilege', 'proceedure': 'procedure', 'recieve': 'receive', 'seperate': 'separate', 'statutory': 'statuary' // Common typo }; if (commonLegalMisspellings[cleanWord]) { return { type: 'Spelling Error', severity: 'medium', description: `"${word}" appears to be misspelled. Correct spelling: "${commonLegalMisspellings[cleanWord]}"`, suggestion: commonLegalMisspellings[cleanWord] }; } return null; }; const performLineInspection = (line, lineNumber, documentType, framework) => { const issues = []; if (/section\s+\d+\s*$/i.test(line) && !line.includes('Act')) { issues.push({ type: 'Incomplete Statutory Reference', severity: 'high', description: 'Section reference without specifying the Act', defect: 'Section reference incomplete - must specify governing Act' }); } if (/,\s+and\s+,/.test(line)) { issues.push({ type: 'Grammatical Error', severity: 'low', description: 'Incorrect comma placement with conjunction', defect: 'Oxford comma usage inconsistent or incorrect' }); } if (documentType === 'Victoria Police Manual' && /was\s+\w+ed\b|were\s+\w+ed\b/i.test(line)) { issues.push({ type: 'Passive Voice in Procedural Document', severity: 'low', description: 'Victoria Police procedures should use active voice', defect: 'Consider rephrasing in active voice for clarity' }); } if (/as soon as possible|ASAP|promptly|immediately/i.test(line)) { issues.push({ type: 'Vague Temporal Reference', severity: 'medium', description: 'Imprecise time requirement - Victorian statutory compliance requires specific timeframes', defect: 'Replace with specific timeframe (e.g., "within 7 days", "within 24 hours")' }); } if (documentType === 'Statement' && lineNumber === 1) { if (!/statement\s+of/i.test(line)) { issues.push({ type: 'Missing Statement Header', severity: 'high', description: 'Statement documents should begin with "Statement of [name]"', defect: 'Required header missing - Victoria Police disclosure requirements' }); } } const incorrectCourtRefs = [ { pattern: /Magistrates Court(?!\s+of\s+Victoria)/gi, correct: 'Magistrates\' Court of Victoria' }, { pattern: /Supreme Court(?!\s+of\s+Victoria)/gi, correct: 'Supreme Court of Victoria' }, { pattern: /County Court(?!\s+of\s+Victoria)/gi, correct: 'County Court of Victoria' } ]; incorrectCourtRefs.forEach(ref => { if (ref.pattern.test(line)) { issues.push({ type: 'Incomplete Court Reference', severity: 'high', description: `Court reference should be "${ref.correct}" in Victorian documents`, defect: 'Full court name required for Victorian jurisdiction' }); } }); return issues; }; const generateFindings = (content, preset) => { const words = content.split(/\s+/).filter(w => w.length> 0); const lines = content.split('\n').filter(l => l.trim().length> 0); const legalReferences = extractLegalReferences(content); const linguisticInspection = performLinguisticInspection(content, 'General Legal Document', {}); return { wordCount: words.length, lineCount: lines.length, linguisticInspection: linguisticInspection, keyTermsIdentified: extractKeyTerms(content, preset), proceduralElements: identifyProceduralElements(content, preset), legalReferences: legalReferences, potentialIssues: identifyPotentialIssues(content, preset, legalReferences), contextualMarkers: extractContextualMarkers(content, preset) }; }; const extractKeyTerms = (content, preset) => { const legalTerms = ['section', 'act', 'regulation', 'pursuant', 'provision', 'subsection', 'statute', 'legislative', 'compliance', 'requirement', 'jurisdiction', 'evidence', 'exhibit', 'disclosure', 'preliminary', 'test', 'analysis', 'procedure', 'statutory', 'mandatory', 'discretionary', 'power']; const found = []; legalTerms.forEach(term => { const regex = new RegExp(`\\b${term}\\b`, 'gi'); const matches = content.match(regex); if (matches) { found.push({ term: term, occurrences: matches.length, contexts: extractContexts(content, term, 50) }); } }); return found.slice(0, 10); }; const extractContexts = (content, term, contextLength) => { const regex = new RegExp(`.{0,${contextLength}}\\b${term}\\b.{0,${contextLength}}`, 'gi'); const matches = content.match(regex); return matches ? matches.slice(0, 3) : []; }; const identifyProceduralElements = (content, preset) => { const proceduralIndicators = [ { pattern: /section\s+\d+[A-Z]?/gi, type: 'Statutory Reference' }, { pattern: /\b(must|shall|may|ought)\b/gi, type: 'Mandatory/Discretionary Language' }, { pattern: /\b(pursuant to|in accordance with|under)\b/gi, type: 'Procedural Compliance Indicator' }, { pattern: /\b(evidence|exhibit|disclosure|statement)\b/gi, type: 'Evidentiary Element' }, { pattern: /\b(date|time|within|before|after)\b/gi, type: 'Temporal Element' } ]; return proceduralIndicators.map(indicator => ({ type: indicator.type, matches: (content.match(indicator.pattern) || []).length, examples: extractContexts(content, indicator.pattern.source.replace(/\\b|\(|\)|gi/g, ''), 40).slice(0, 2) })).filter(item => item.matches> 0); }; const extractLegalReferences = (content) => { const references = []; const sectionMatches = content.match(/section\s+\d+[A-Z]?(?:\(\d+\))?(?:\([a-z]\))?/gi); if (sectionMatches) { references.push(...sectionMatches.map(m => ({ type: 'Section Reference', text: m }))); } const actMatches = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Act\s+\d{4}/g); if (actMatches) { references.push(...actMatches.map(m => ({ type: 'Act Citation', text: m }))); } return references.slice(0, 15); }; const identifyPotentialIssues = (content, preset, legalReferences = []) => { const issues = []; const primaryActs = legalReferences.filter(r => r.type === 'Act Citation'); const sectionRefs = legalReferences.filter(r => r.type === 'Section Reference'); // Category 1: CRITICAL STATUTORY DEFECTS (High Severity) const errorPatterns = /\b(error|incorrect|mistake|erroneously|wrongly|inadvertent|oversight)\b/gi; const errorMatches = content.match(errorPatterns); if (errorMatches && errorMatches.length> 0) { issues.push({ severity: 'critical', type: 'Acknowledged Defect', category: 'Statutory Compliance', description: `Document contains ${errorMatches.length} reference(s) to errors or incorrect information`, evidence: errorMatches.slice(0, 3).join(', '), statutoryImpact: 'May invalidate reliance on document under s15AA Acts Interpretation Act', weight: 10 }); } const jurisdictionPatterns = /\b(jurisdiction|ultra vires|beyond power|lack.*authority|void|invalid)\b/gi; const jurisdictionMatches = content.match(jurisdictionPatterns); if (jurisdictionMatches && jurisdictionMatches.length> 2) { issues.push({ severity: 'critical', type: 'Jurisdictional Defect', category: 'Statutory Compliance', description: 'Document raises potential jurisdictional or validity concerns', evidence: jurisdictionMatches.slice(0, 3).join(', '), statutoryImpact: 'Jurisdictional defects may render decision void ab initio', weight: 10 }); } const fairnessPatterns = /\b(natural justice|procedural fairness|bias|denied.*opportunity|no.*hearing|unfair)\b/gi; const fairnessMatches = content.match(fairnessPatterns); if (fairnessMatches && fairnessMatches.length> 0) { issues.push({ severity: 'high', type: 'Procedural Fairness Issue', category: 'Statutory Compliance', description: 'Document indicates potential breach of procedural fairness', evidence: fairnessMatches.slice(0, 3).join(', '), statutoryImpact: 'Breach of natural justice may constitute jurisdictional error', weight: 9 }); } if (primaryActs.length === 0) { issues.push({ severity: 'high', type: 'Missing Primary Legislation', category: 'Statutory Framework', description: 'No primary Act citations identified - cannot determine governing legislative framework', statutoryImpact: 'Unable to assess compliance with enabling legislation', weight: 8 }); } if (sectionRefs.length === 0 && content.length> 500) { issues.push({ severity: 'medium', type: 'Missing Specific Statutory Provisions', category: 'Statutory Framework', description: 'No specific section references identified despite substantive content', statutoryImpact: 'Lack of specificity may indicate insufficient statutory basis', weight: 6 }); } const inconsistentCitations = checkCitationConsistency(content); if (inconsistentCitations.length> 0) { issues.push({ severity: 'medium', type: 'Inconsistent Citation Format', category: 'Statutory Framework', description: 'Mixed or inconsistent citation formats detected', evidence: inconsistentCitations.join('; '), weight: 5 }); } const subordinateInstruments = identifySubordinateInstruments(content); if (subordinateInstruments.regulations.length> 0 && primaryActs.length === 0) { issues.push({ severity: 'medium', type: 'Orphaned Subordinate Instrument', category: 'Legislative Hierarchy', description: `${subordinateInstruments.regulations.length} subordinate instrument(s) cited without parent Act`, evidence: subordinateInstruments.regulations.slice(0, 3).join(', '), statutoryImpact: 'Subordinate instruments must be read subject to enabling Act', weight: 7 }); } const conflictPatterns = /\b(contrary to|inconsistent with|conflict|override|supersede)\b/gi; const conflictMatches = content.match(conflictPatterns); if (conflictMatches && subordinateInstruments.regulations.length> 0) { issues.push({ severity: 'high', type: 'Potential Instrument Conflict', category: 'Legislative Hierarchy', description: 'Potential conflict between subordinate and primary legislation', evidence: conflictMatches.slice(0, 2).join(', '), statutoryImpact: 'Subordinate instruments cannot override primary legislation', weight: 8 }); } const mustShallCount = (content.match(/\b(must|shall|required)\b/gi) || []).length; const mayCount = (content.match(/\b(may|discretion|permitted)\b/gi) || []).length; const couldCount = (content.match(/\b(could|might|possibly)\b/gi) || []).length; if (mustShallCount> 0 && mayCount> 0) { const ratio = mayCount / mustShallCount; const severity = ratio> 0.5 ? 'medium' : 'low'; issues.push({ severity: severity, type: 'Mixed Mandatory/Discretionary Language', category: 'Interpretive Clarity', description: `Document contains both mandatory (${mustShallCount}) and discretionary (${mayCount}) obligations`, statutoryImpact: 'Mandatory obligations interpreted according to "must" vs "may" distinction', weight: ratio> 0.5 ? 5 : 3 }); } if (couldCount> mustShallCount && mustShallCount> 0) { issues.push({ severity: 'medium', type: 'Vague Language in Statutory Context', category: 'Interpretive Clarity', description: `Predominance of uncertain language (${couldCount} instances) over mandatory obligations`, weight: 4 }); } const lines = content.split('\n').filter(l => l.trim().length> 0); const words = content.split(/\s+/).length; if (lines.length <5 && words <100) { issues.push({ severity: 'medium', type: 'Insufficient Substantive Content', category: 'Procedural Sufficiency', description: `Document appears to lack substantive detail (${lines.length} lines, ${words} words)`, statutoryImpact: 'Inadequate reasoning may constitute failure to discharge statutory duty', weight: 6 }); } const temporalMarkers = content.match(/\b(\d{1,2}\/\d{1,2}\/\d{2,4}|\d{4}-\d{2}-\d{2}|date|time|deadline|by|before|after|within \d+)\b/gi); if (!temporalMarkers && content.length> 500) { issues.push({ severity: 'low', type: 'Missing Temporal References', category: 'Procedural Sufficiency', description: 'No specific dates or timeframes identified in substantive document', weight: 3 }); } const evidenceMarkers = content.match(/\b(evidence|exhibit|annexure|attachment|schedule|appendix)\b/gi); if (evidenceMarkers && evidenceMarkers.length> 3) { const evidenceVerification = content.match(/\b(refer|attached|enclosed|provided)\b/gi); if (!evidenceVerification || evidenceVerification.length <evidenceMarkers.length) { issues.push({ severity: 'medium', type: 'Potential Missing Evidence', category: 'Procedural Sufficiency', description: `${evidenceMarkers.length} evidence references but insufficient verification of attachment`, weight: 5 }); } } const generalTerms = content.match(/\b(general|overall|broadly|in general|generally)\b/gi); const specificTerms = content.match(/\b(specific|specifically|particular|precisely|expressly)\b/gi); if (generalTerms && specificTerms && generalTerms.length> specificTerms.length * 2) { issues.push({ severity: 'low', type: 'Predominance of General over Specific', category: 'Interpretive Principles', description: 'Document relies heavily on general rather than specific provisions', statutoryImpact: 'Principle: Specific provisions prevail over general (generalia specialibus non derogant)', weight: 4 }); } const inclusionTerms = content.match(/\b(includes?|including|such as|means)\b/gi); const exclusionTerms = content.match(/\b(excludes?|excluding|except|other than|but not)\b/gi); if (inclusionTerms && !exclusionTerms && inclusionTerms.length> 3) { issues.push({ severity: 'low', type: 'Express Inclusions without Exclusions', category: 'Interpretive Principles', description: 'Multiple express inclusions may imply exclusion of unstated items', statutoryImpact: 'Principle: Express mention excludes unstated items (expressio unius)', weight: 3 }); } const totalWeight = issues.reduce((sum, issue) => sum + (issue.weight || 0), 0); issues.sort((a, b) => (b.weight || 0) - (a.weight || 0)); issues.forEach((issue, index) => { issue.id = `ISSUE-${index + 1}`; issue.governingFramework = primaryActs.length> 0 ? primaryActs[0].text : 'Unspecified'; }); return { issues: issues, summary: { totalIssues: issues.length, critical: issues.filter(i => i.severity === 'critical').length, high: issues.filter(i => i.severity === 'high').length, medium: issues.filter(i => i.severity === 'medium').length, low: issues.filter(i => i.severity === 'low').length, overallRiskScore: totalWeight, riskLevel: totalWeight> 40 ? 'CRITICAL' : totalWeight> 25 ? 'HIGH' : totalWeight> 15 ? 'MEDIUM' : 'LOW' } }; }; const checkCitationConsistency = (content) => { const inconsistencies = []; const sectionStyle1 = content.match(/section \d+/gi); const sectionStyle2 = content.match(/s\.\d+/gi); const sectionStyle3 = content.match(/sec\. \d+/gi); const styles = [sectionStyle1, sectionStyle2, sectionStyle3].filter(s => s && s.length> 0); if (styles.length> 1) { inconsistencies.push('Mixed section reference formats (e.g., "section 5", "s.5", "sec. 5")'); } const subsectionParen = content.match(/\(\d+\)/g); const subsectionBracket = content.match(/\[\d+\]/g); if (subsectionParen && subsectionBracket) { inconsistencies.push('Mixed subsection formats (parentheses vs brackets)'); } return inconsistencies; }; const identifySubordinateInstruments = (content) => { const regulations = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Regulations?\s+\d{4}/g) || []; const rules = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Rules\s+\d{4}/g) || []; const orders = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Orders?\s+\d{4}/g) || []; const instruments = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Instrument\s+\d{4}/g) || []; return { regulations: [...new Set(regulations)], rules: [...new Set(rules)], orders: [...new Set(orders)], instruments: [...new Set(instruments)], total: regulations.length + rules.length + orders.length + instruments.length }; }; const extractContextualMarkers = (content, preset) => { return { temporalMarkers: (content.match(/\b(before|after|within|during|on|at)\s+[a-zA-Z0-9\s,]+/gi) || []).slice(0, 5), conditionalMarkers: (content.match(/\b(if|unless|provided that|subject to)\b[^.]+/gi) || []).slice(0, 5), authorityMarkers: (content.match(/\b(officer|court|tribunal|authority|minister)\b[^.]+/gi) || []).slice(0, 5) }; }; const checkVictorianStatutoryCompliance = (content, documentType, legalReferences) => { const complianceIssues = []; if (documentType === 'Disclosure Document' || documentType === 'Statement') { if (!/informant[\'']?s?\s+statement/i.test(content)) { complianceIssues.push({ severity: 'critical', statute: 'Criminal Procedure Act 2009', section: 'Part 3.3 - s.186 Disclosure Requirements', defect: 'Missing informant\'s statement in disclosure', compliance: 'non-compliant', remediation: 'Include informant\'s statement as required by CPA 2009 s.186(1)(a)' }); } const witnessStatementMatch = content.match(/witness\s+statement/gi); if (!witnessStatementMatch || witnessStatementMatch.length === 0) { complianceIssues.push({ severity: 'high', statute: 'Criminal Procedure Act 2009', section: 'Part 3.3 - s.186 Witness Statements', defect: 'No witness statements identified', compliance: 'unclear', remediation: 'Verify all witness statements are disclosed per s.186(1)(b)' }); } if (!/prior\s+(conviction|record|history)|criminal\s+(history|record)/i.test(content)) { complianceIssues.push({ severity: 'medium', statute: 'Criminal Procedure Act 2009', section: 'Part 3.3 - s.186 Prior Convictions', defect: 'No reference to prior convictions or criminal history', compliance: 'unclear', remediation: 'Disclose any prior convictions relevant to the case (s.186(1)(c))' }); } if (!/evidence\s+(list|schedule|inventory)|exhibit\s+(list|schedule|inventory)|physical\s+evidence/i.test(content)) { complianceIssues.push({ severity: 'high', statute: 'Criminal Procedure Act 2009', section: 'Part 3.3 - s.186 Physical Evidence', defect: 'No physical evidence list or exhibit schedule identified', compliance: 'non-compliant', remediation: 'Provide list of all physical evidence per s.186(1)(d)' }); } const hasSignature = /signed|signature/i.test(content); const hasDate = /dated|date\s*:/i.test(content); if (!hasSignature) { complianceIssues.push({ severity: 'critical', statute: 'Criminal Procedure Act 2009', section: 'Part 3.3 - Statement Formalities', defect: 'No indication that statements are signed', compliance: 'non-compliant', remediation: 'All statements must be signed by declarant' }); } if (!hasDate) { complianceIssues.push({ severity: 'high', statute: 'Criminal Procedure Act 2009', section: 'Part 3.3 - Statement Formalities', defect: 'No indication that statements are dated', compliance: 'non-compliant', remediation: 'All statements must be dated to establish timeline' }); } if (!/within\s+\d+\s+(days?|weeks?|months?)|disclosure\s+deadline/i.test(content)) { complianceIssues.push({ severity: 'high', statute: 'Criminal Procedure Act 2009', section: 's.186 - Disclosure Timing', defect: 'No specific disclosure timeframe identified', compliance: 'potentially non-compliant', remediation: 'Ensure disclosure meets s.186 mandatory timeframes' }); } const exhibitReferences = content.match(/exhibit\s+[A-Z0-9]+/gi); if (exhibitReferences && exhibitReferences.length> 0) { const properIdentification = /exhibit\s+[A-Z0-9]+:\s*[\w\s]+/i.test(content); if (!properIdentification) { complianceIssues.push({ severity: 'medium', statute: 'Criminal Procedure Act 2009', section: 'Part 3.3 - Exhibit Identification', defect: 'Exhibits referenced but may lack proper descriptions', compliance: 'unclear', remediation: 'Each exhibit must have unique identifier and description' }); } } } const isPreliminaryTest = /preliminary\s+(test|breath|drug)|roadside\s+test|screening\s+test/i.test(content); if (isPreliminaryTest) { const hasReasonToBelieve = /reason\s+to\s+(believe|suspect)|reasonable\s+(belief|suspicion)|believed|suspected/i.test(content); if (!hasReasonToBelieve) { complianceIssues.push({ severity: 'critical', statute: 'Road Safety Act 1986', section: 's.49(1) - Reason to Believe', defect: 'No evidence that officer had "reason to believe" as required by s.49(1)', compliance: 'non-compliant', remediation: 'Document must show officer\'s subjective belief that driver had consumed alcohol/drugs' }); } const hasDirections = /in\s+accordance\s+with\s+directions?|directions?\s+(given|provided|issued)|followed\s+directions?/i.test(content); if (!hasDirections) { complianceIssues.push({ severity: 'critical', statute: 'Road Safety Act 1986', section: 's.55D(1) - Accordance with Directions', defect: 'No evidence test was conducted "in accordance with directions"', compliance: 'non-compliant', remediation: 'Must specify that test was conducted in accordance with s.55D(1) directions' }); } const hasOralDirections = /oral\s+directions?|verbal\s+(?:directions?|instructions?)|spoken\s+to|told\s+to|instructed\s+(?:to|that)/i.test(content); const hasLiteracyRef = /literate|able\s+to\s+read|read\s+and\s+understand/i.test(content); if (!hasOralDirections && !hasLiteracyRef) { complianceIssues.push({ severity: 'high', statute: 'Road Safety Act 1986', section: 's.55D(2) - Oral Directions', defect: 'No indication that oral directions were given if person literate', compliance: 'unclear', remediation: 'If person literate, oral directions must be given per s.55D(2)' }); } const properPerformanceIndicators = [ /device\s+approval|approved\s+device|approved\s+(?:by|under)/i, /calibrat(?:ed|ion)|maintain(?:ed|ance)|servic(?:ed|ing)/i, /proper\s+(?:working\s+)?(?:order|condition|performance)/i, /tested\s+and\s+(?:certified|approved)/i ]; const hasProperPerformance = properPerformanceIndicators.some(pattern => pattern.test(content)); if (!hasProperPerformance) { complianceIssues.push({ severity: 'critical', statute: 'Road Safety Act 1986', section: 's.55E - Proper Performance', defect: 'No indicators of device "proper performance" as required by s.55E', compliance: 'non-compliant', remediation: 'Must document: device approval number, calibration/maintenance records' }); } const hasApprovalNumber = /approval\s+(?:number|no\.?|#)\s*:?\s*[\w\d\-]+|device\s+(?:number|no\.?|#)\s*:?\s*[\w\d\-]+/i.test(content); if (!hasApprovalNumber) { complianceIssues.push({ severity: 'high', statute: 'Road Safety Act 1986', section: 's.55E - Device Approval', defect: 'No device approval number specified', compliance: 'non-compliant', remediation: 'Must specify approved device number per s.55E proper performance requirements' }); } const hasMaintenanceRecords = /calibrat(?:ed|ion)\s+(?:on|date|record)|maintenance\s+(?:log|record)|service\s+(?:date|record)/i.test(content); if (!hasMaintenanceRecords) { complianceIssues.push({ severity: 'high', statute: 'Road Safety Act 1986', section: 's.55E - Device Maintenance', defect: 'No calibration or maintenance records referenced', compliance: 'unclear', remediation: 'Document calibration/maintenance to establish proper performance' }); } const hasEvidentinaryTest = /evidentiary\s+test|evidential\s+(?:test|breath)/i.test(content); if (hasEvidentinaryTest) { const hasCompliance = /complied\s+with|in\s+accordance\s+with|pursuant\s+to.*s(?:ection)?\s*55\(1\)/i.test(content); if (!hasCompliance) { complianceIssues.push({ severity: 'high', statute: 'Road Safety Act 1986', section: 's.55(1) - Evidentiary Test', defect: 'Evidentiary test mentioned but compliance not documented', compliance: 'unclear', remediation: 'Document compliance with s.55(1) evidentiary test requirements' }); } } const hasTestTime = /time\s+of\s+test|test\s+conducted\s+at|tested\s+at/i.test(content); const hasDrivingTime = /time\s+of\s+(?:driving|incident|offence)|drove\s+at|driving\s+at/i.test(content); if (hasTestTime && !hasDrivingTime) { complianceIssues.push({ severity: 'medium', statute: 'Road Safety Act 1986', section: 'Temporal Requirements', defect: 'Test time documented but time of driving unclear', compliance: 'unclear', remediation: 'Establish temporal link between driving and test administration' }); } } const hearsayIndicators = /(?:he|she|they)\s+(?:said|told|stated)|told\s+(?:me|us|the\s+officer)|stated\s+that|informed\s+(?:me|us)|reported\s+that/i; const hasHearsay = hearsayIndicators.test(content); if (hasHearsay) { complianceIssues.push({ severity: 'high', statute: 'Evidence Act 2008 (Vic)', section: 's.59 - Hearsay Rule', defect: 'Potential hearsay evidence identified', compliance: 'unclear', remediation: 'Verify hearsay is admissible under exception (s.60-69) or consider s.59 exclusion' }); const hearsayExceptions = /s(?:ection)?\s*(?:60|61|62|63|64|65|66|67|68|69)|exception\s+to\s+hearsay|business\s+records|contemporaneous\s+statement/i; if (!hearsayExceptions.test(content)) { complianceIssues.push({ severity: 'critical', statute: 'Evidence Act 2008 (Vic)', section: 's.60-69 - Hearsay Exceptions', defect: 'Hearsay evidence present but no exception claimed', compliance: 'non-compliant', remediation: 'Identify applicable hearsay exception under s.60-69 or exclude evidence' }); } const businessRecords = /business\s+records?|s(?:ection)?\s*69|records?\s+(?:kept|made)\s+in\s+(?:the\s+)?course\s+of.*business/i; if (businessRecords.test(content)) { const hasFoundation = /person\s+with\s+knowledge|made\s+(?:by|at)|kept\s+in\s+(?:the\s+)?ordinary\s+course/i.test(content); if (!hasFoundation) { complianceIssues.push({ severity: 'high', statute: 'Evidence Act 2008 (Vic)', section: 's.69 - Business Records', defect: 'Business records exception invoked but foundation not established', compliance: 'unclear', remediation: 'Establish s.69 requirements: record made by competent person, in ordinary course' }); } } } const highlyPrejudicial = /prior\s+(?:conviction|offence)|bad\s+character|previous\s+(?:criminal|bad)\s+(?:conduct|behaviour)|prejudicial/i; if (highlyPrejudicial.test(content)) { complianceIssues.push({ severity: 'medium', statute: 'Evidence Act 2008 (Vic)', section: 's.137 - Probative vs Prejudicial', defect: 'Potentially prejudicial evidence - probative value may be outweighed', compliance: 'consider-exclusion', remediation: 'Court discretion under s.137: exclude if probative value <unfair prejudice' }); } const improperlyObtained = /obtained\s+(?:illegally|unlawfully|improperly)|breach\s+of|violated|without\s+(?:warrant|authority|consent)|unlawful\s+(?:search|seizure)/i; if (improperlyObtained.test(content)) { complianceIssues.push({ severity: 'critical', statute: 'Evidence Act 2008 (Vic)', section: 's.138 - Improperly Obtained Evidence', defect: 'Evidence may have been improperly or illegally obtained', compliance: 'non-compliant', remediation: 'Court must consider s.138 discretionary exclusion for improperly obtained evidence' }); } if (documentType === 'Victoria Police Manual' || /victoria\s+police/i.test(content)) { if (!/Victoria\s+Police\s+Act\s+2013/i.test(content)) { complianceIssues.push({ severity: 'medium', statute: 'Victoria Police Act 2013', section: 'General Compliance', defect: 'Police procedures should reference Victoria Police Act 2013', compliance: 'potentially non-compliant', remediation: 'Add reference to Victoria Police Act 2013' }); } } const humanRightsIndicators = /rights?|fairness|natural justice|discrimination|equality/i; if (humanRightsIndicators.test(content)) { if (!/Charter\s+of\s+Human\s+Rights/i.test(content)) { complianceIssues.push({ severity: 'medium', statute: 'Charter of Human Rights and Responsibilities Act 2006', section: 'Human rights considerations', defect: 'Document discusses rights but does not reference Charter', compliance: 'consider-charter', remediation: 'Consider whether Charter of Human Rights and Responsibilities Act 2006 is engaged' }); } } if (documentType === 'Court Order' || documentType === 'Court Documentation') { const hasCourtRef = /Supreme\s+Court|County\s+Court|Magistrates/i.test(content); const hasFullCourtName = /Supreme\s+Court\s+of\s+Victoria|County\s+Court\s+of\s+Victoria|Magistrates[\'']?\s+Court\s+of\s+Victoria/i.test(content); if (hasCourtRef && !hasFullCourtName) { complianceIssues.push({ severity: 'high', statute: 'Court rules and procedures', section: 'Court identification', defect: 'Court references must use full official name including "of Victoria"', compliance: 'non-compliant', remediation: 'Use full court names: "Supreme Court of Victoria", "County Court of Victoria", "Magistrates\' Court of Victoria"' }); } } return complianceIssues; }; const evaluateCrossFileNarrativeTimeline = (contentA, contentB, fileAMetadata, fileBMetadata) => { const narrativeAnalysis = { timelineDiscrepancies: [], narrativeInconsistencies: [], eventSequenceMismatch: [], factualContradictions: [], sequentialMapping: [] }; const datesA = extractDatesAndTimeline(contentA); const datesB = extractDatesAndTimeline(contentB); const eventsA = extractNarrativeEvents(contentA); const eventsB = extractNarrativeEvents(contentB); datesA.forEach(dateA => { const matchingDatesB = datesB.filter(dateB => dateB.normalizedDate === dateA.normalizedDate ); if (matchingDatesB.length> 0) { matchingDatesB.forEach(dateB => { if (dateA.context !== dateB.context) { narrativeAnalysis.timelineDiscrepancies.push({ date: dateA.normalizedDate, fileA: { line: dateA.line, context: dateA.context }, fileB: { line: dateB.line, context: dateB.context }, severity: 'high', defect: 'Same date referenced with different contexts', mapping: `File A Line ${dateA.line} vs File B Line ${dateB.line}` }); } }); } }); const commonTerms = findCommonNarrativeTerms(eventsA, eventsB); commonTerms.forEach(term => { const orderA = eventsA.findIndex(e => e.text.toLowerCase().includes(term.toLowerCase())); const orderB = eventsB.findIndex(e => e.text.toLowerCase().includes(term.toLowerCase())); if (orderA !== -1 && orderB !== -1) { const contextA = eventsA[orderA]; const contextB = eventsB[orderB]; if (contextA.surrounding !== contextB.surrounding) { narrativeAnalysis.eventSequenceMismatch.push({ term: term, fileA: { line: contextA.line, sequence: orderA, context: contextA.text }, fileB: { line: contextB.line, sequence: orderB, context: contextB.text }, severity: 'medium', defect: 'Same event referenced but surrounding narrative differs', mapping: `File A Line ${contextA.line} (Event #${orderA + 1}) vs File B Line ${contextB.line} (Event #${orderB + 1})` }); } } }); const contradictions = findFactualContradictions(contentA, contentB); narrativeAnalysis.factualContradictions = contradictions; narrativeAnalysis.sequentialMapping = buildSequentialMapping( datesA, datesB, eventsA, eventsB, contentA, contentB ); return narrativeAnalysis; }; const extractDatesAndTimeline = (content) => { const dates = []; const lines = content.split('\n'); const datePatterns = [ /\b(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\b/g, // DD/MM/YYYY or DD-MM-YYYY /\b(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})\b/g, // YYYY/MM/DD /\b(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\b/gi, /\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{1,2}),?\s+(\d{4})\b/gi ]; lines.forEach((line, index) => { datePatterns.forEach(pattern => { const matches = [...line.matchAll(pattern)]; matches.forEach(match => { dates.push({ line: index + 1, original: match[0], normalizedDate: match[0], // Simplified - would normally parse to standard format context: line.trim() }); }); }); const temporalMarkers = [ /\bbefore\s+[^.]+/gi, /\bafter\s+[^.]+/gi, /\bwithin\s+\d+\s+(days?|weeks?|months?|years?)/gi, /\bon\s+or\s+about\s+[^.]+/gi ]; temporalMarkers.forEach(pattern => { const matches = [...line.matchAll(pattern)]; matches.forEach(match => { dates.push({ line: index + 1, original: match[0], normalizedDate: 'temporal-marker', context: line.trim() }); }); }); }); return dates; }; const extractNarrativeEvents = (content) => { const events = []; const lines = content.split('\n'); const eventIndicators = [ /\b(occurred|happened|took place|transpired|witnessed|observed|attended|conducted|performed|executed)\b/gi, /\b(seized|arrested|detained|charged|interviewed|questioned)\b/gi, /\b(stated|declared|asserted|claimed|testified|deposed)\b/gi, /\b(found|discovered|located|identified|recovered)\b/gi ]; lines.forEach((line, index) => { eventIndicators.forEach(pattern => { if (pattern.test(line)) { const surrounding = lines.slice(Math.max(0, index - 1), Math.min(lines.length, index + 2)).join(' '); events.push({ line: index + 1, text: line.trim(), surrounding: surrounding.trim() }); } }); }); return events; }; const findCommonNarrativeTerms = (eventsA, eventsB) => { const termsA = new Set( eventsA.flatMap(e => e.text.toLowerCase().match(/\b\w{4,}\b/g) || []) ); const termsB = new Set( eventsB.flatMap(e => e.text.toLowerCase().match(/\b\w{4,}\b/g) || []) ); return [...termsA].filter(term => termsB.has(term) && !['this', 'that', 'with', 'from', 'have', 'been', 'were', 'said'].includes(term)); }; const findFactualContradictions = (contentA, contentB) => { const contradictions = []; const contradictionPatterns = [ { pattern: /\b(yes|no|true|false|did|did not|was|was not)\b/gi, type: 'affirmation/negation' }, { pattern: /\b\d+\s+(person|people|officer|individual|item|exhibit)/gi, type: 'quantity' }, { pattern: /\b(present|absent|available|unavailable)\b/gi, type: 'presence' } ]; contradictionPatterns.forEach(({ pattern, type }) => { const matchesA = contentA.match(pattern) || []; const matchesB = contentB.match(pattern) || []; if (matchesA.length> 0 && matchesB.length> 0) { const uniqueA = new Set(matchesA.map(m => m.toLowerCase())); const uniqueB = new Set(matchesB.map(m => m.toLowerCase())); uniqueA.forEach(a => { if (a.includes('not') && uniqueB.has(a.replace(/not\s+/, ''))) { contradictions.push({ type: type, fileA: a, fileB: a.replace(/not\s+/, ''), severity: 'high', defect: 'Direct contradiction between documents' }); } }); } }); return contradictions; }; const buildSequentialMapping = (datesA, datesB, eventsA, eventsB, contentA, contentB) => { const mapping = []; datesA.forEach((dateA, indexA) => { mapping.push({ sequenceNumber: mapping.length + 1, type: 'temporal', source: 'File A', line: dateA.line, element: dateA.original, context: dateA.context, crossReference: datesB.find(db => db.normalizedDate === dateA.normalizedDate) || null }); }); datesB.forEach((dateB, indexB) => { if (!mapping.find(m => m.source === 'File B' && m.line === dateB.line)) { mapping.push({ sequenceNumber: mapping.length + 1, type: 'temporal', source: 'File B', line: dateB.line, element: dateB.original, context: dateB.context, crossReference: datesA.find(da => da.normalizedDate === dateB.normalizedDate) || null }); } }); eventsA.forEach(eventA => { mapping.push({ sequenceNumber: mapping.length + 1, type: 'narrative-event', source: 'File A', line: eventA.line, element: eventA.text, context: eventA.surrounding, crossReference: null }); }); eventsB.forEach(eventB => { mapping.push({ sequenceNumber: mapping.length + 1, type: 'narrative-event', source: 'File B', line: eventB.line, element: eventB.text, context: eventB.surrounding, crossReference: null }); }); return mapping.sort((a, b) => a.sequenceNumber - b.sequenceNumber); }; const generateOmissionsReport = (contentA, contentB, phaseAResults) => { const report = { statutoryReferences: { inANotInB: [], inBNotInA: [] }, proceduralElements: { inANotInB: [], inBNotInA: [] }, factsAndAssertions: { inANotInB: [], inBNotInA: [] }, criticalOmissions: { victorianCriminalRequirements: [] } }; const refsA = new Set(phaseAResults.fileA[0].findings.legalReferences.map(r => r.text)); const refsB = new Set(phaseAResults.fileB[0].findings.legalReferences.map(r => r.text)); refsA.forEach(ref => { if (!refsB.has(ref)) { report.statutoryReferences.inANotInB.push({ element: ref, category: 'Statutory Reference', severity: 'high', impact: 'Legal authority present in Doc A but not referenced in Doc B' }); } }); refsB.forEach(ref => { if (!refsA.has(ref)) { report.statutoryReferences.inBNotInA.push({ element: ref, category: 'Statutory Reference', severity: 'high', impact: 'Legal authority present in Doc B but not referenced in Doc A' }); } }); const proceduralA = phaseAResults.fileA[0].findings.proceduralElements || []; const proceduralB = phaseAResults.fileB[0].findings.proceduralElements || []; const procTypesA = new Set(proceduralA.map(p => p.type)); const procTypesB = new Set(proceduralB.map(p => p.type)); procTypesA.forEach(type => { if (!procTypesB.has(type)) { const examples = proceduralA.find(p => p.type === type)?.examples || []; report.proceduralElements.inANotInB.push({ element: type, category: 'Procedural Element', severity: 'medium', examples: examples.slice(0, 2), impact: 'Procedural step described in Doc A but omitted from Doc B' }); } }); procTypesB.forEach(type => { if (!procTypesA.has(type)) { const examples = proceduralB.find(p => p.type === type)?.examples || []; report.proceduralElements.inBNotInA.push({ element: type, category: 'Procedural Element', severity: 'medium', examples: examples.slice(0, 2), impact: 'Procedural step described in Doc B but omitted from Doc A' }); } }); // Critical Victorian Criminal Matter Omissions const hasDirectionsA = /in\s+accordance\s+with\s+directions?/i.test(contentA); const hasDirectionsB = /in\s+accordance\s+with\s+directions?/i.test(contentB); if (hasDirectionsA && !hasDirectionsB) { report.criticalOmissions.victorianCriminalRequirements.push({ element: '"In accordance with directions" language', statute: 'Road Safety Act 1986 s.55D(1)', severity: 'critical', inDocument: 'Doc A', omittedFrom: 'Doc B', impact: 'Critical RSA 1986 s.55D(1) compliance requirement missing from Doc B' }); } if (hasDirectionsB && !hasDirectionsA) { report.criticalOmissions.victorianCriminalRequirements.push({ element: '"In accordance with directions" language', statute: 'Road Safety Act 1986 s.55D(1)', severity: 'critical', inDocument: 'Doc B', omittedFrom: 'Doc A', impact: 'Critical RSA 1986 s.55D(1) compliance requirement missing from Doc A' }); } const hasReasonToBelieveA = /reason\s+to\s+(believe|suspect)|reasonable\s+(belief|suspicion)/i.test(contentA); const hasReasonToBelieveB = /reason\s+to\s+(believe|suspect)|reasonable\s+(belief|suspicion)/i.test(contentB); if (hasReasonToBelieveA && !hasReasonToBelieveB) { report.criticalOmissions.victorianCriminalRequirements.push({ element: 'Officer\'s "reason to believe" formation', statute: 'Road Safety Act 1986 s.49(1)', severity: 'critical', inDocument: 'Doc A', omittedFrom: 'Doc B', impact: 'Critical s.49(1) requirement - officer\'s subjective belief not documented in Doc B' }); } if (hasReasonToBelieveB && !hasReasonToBelieveA) { report.criticalOmissions.victorianCriminalRequirements.push({ element: 'Officer\'s "reason to believe" formation', statute: 'Road Safety Act 1986 s.49(1)', severity: 'critical', inDocument: 'Doc B', omittedFrom: 'Doc A', impact: 'Critical s.49(1) requirement - officer\'s subjective belief not documented in Doc A' }); } const hasApprovalA = /approval\s+(?:number|no\.?|#)|device\s+(?:number|no\.?|#)/i.test(contentA); const hasApprovalB = /approval\s+(?:number|no\.?|#)|device\s+(?:number|no\.?|#)/i.test(contentB); if (hasApprovalA && !hasApprovalB) { report.criticalOmissions.victorianCriminalRequirements.push({ element: 'Device approval number', statute: 'Road Safety Act 1986 s.55E', severity: 'high', inDocument: 'Doc A', omittedFrom: 'Doc B', impact: 'Device approval number (s.55E proper performance) missing from Doc B' }); } const hasCalibrationA = /calibrat(?:ed|ion)|maintenance|service/i.test(contentA); const hasCalibrationB = /calibrat(?:ed|ion)|maintenance|service/i.test(contentB); if (hasCalibrationA && !hasCalibrationB) { report.criticalOmissions.victorianCriminalRequirements.push({ element: 'Calibration/maintenance records', statute: 'Road Safety Act 1986 s.55E', severity: 'high', inDocument: 'Doc A', omittedFrom: 'Doc B', impact: 'Proper performance indicators (s.55E) - calibration/maintenance omitted from Doc B' }); } const hasTestTimeA = /time\s+of\s+test|test\s+(?:conducted|administered)\s+at/i.test(contentA); const hasTestTimeB = /time\s+of\s+test|test\s+(?:conducted|administered)\s+at/i.test(contentB); const hasDrivingTimeA = /time\s+of\s+(?:driving|incident|offence)/i.test(contentA); const hasDrivingTimeB = /time\s+of\s+(?:driving|incident|offence)/i.test(contentB); if (hasTestTimeA && !hasTestTimeB) { report.criticalOmissions.victorianCriminalRequirements.push({ element: 'Time of test administration', statute: 'Road Safety Act 1986 - Temporal Requirements', severity: 'medium', inDocument: 'Doc A', omittedFrom: 'Doc B', impact: 'Test timing documented in Doc A but omitted from Doc B' }); } if (hasDrivingTimeA && !hasDrivingTimeB) { report.criticalOmissions.victorianCriminalRequirements.push({ element: 'Time of driving/incident', statute: 'Road Safety Act 1986 - Temporal Requirements', severity: 'high', inDocument: 'Doc A', omittedFrom: 'Doc B', impact: 'Critical temporal element - driving time in Doc A but omitted from Doc B' }); } const hasHearsayExceptionA = /s(?:ection)?\s*(?:60|61|62|63|64|65|66|67|68|69)|exception\s+to\s+hearsay/i.test(contentA); const hasHearsayExceptionB = /s(?:ection)?\s*(?:60|61|62|63|64|65|66|67|68|69)|exception\s+to\s+hearsay/i.test(contentB); if (hasHearsayExceptionA && !hasHearsayExceptionB) { report.criticalOmissions.victorianCriminalRequirements.push({ element: 'Hearsay exception claim', statute: 'Evidence Act 2008 (Vic) s.60-69', severity: 'high', inDocument: 'Doc A', omittedFrom: 'Doc B', impact: 'Hearsay exception basis in Doc A but not asserted in Doc B' }); } return report; }; const buildComplianceMatrix = (phaseAResults, complianceA, complianceB) => { const matrix = []; const provisionsMap = new Map(); [...complianceA, ...complianceB].forEach(issue => { const key = `${issue.statute}|${issue.section}`; if (!provisionsMap.has(key)) { provisionsMap.set(key, { provision: `${issue.statute} - ${issue.section}`, statute: issue.statute, section: issue.section, docACompliance: null, docBCompliance: null, docAIssues: [], docBIssues: [], discrepancies: [] }); } }); complianceA.forEach(issue => { const key = `${issue.statute}|${issue.section}`; const provision = provisionsMap.get(key); if (provision) { provision.docAIssues.push(issue); if (issue.compliance === 'compliant') { provision.docACompliance = 'compliant'; } else if (issue.compliance === 'non-compliant') { provision.docACompliance = 'non-compliant'; } else { provision.docACompliance = 'unclear'; } } }); complianceB.forEach(issue => { const key = `${issue.statute}|${issue.section}`; const provision = provisionsMap.get(key); if (provision) { provision.docBIssues.push(issue); if (issue.compliance === 'compliant') { provision.docBCompliance = 'compliant'; } else if (issue.compliance === 'non-compliant') { provision.docBCompliance = 'non-compliant'; } else { provision.docBCompliance = 'unclear'; } } }); provisionsMap.forEach((provision, key) => { if (provision.docACompliance === null && provision.docAIssues.length === 0) { provision.docACompliance = 'compliant'; } if (provision.docBCompliance === null && provision.docBIssues.length === 0) { provision.docBCompliance = 'compliant'; } if (provision.docACompliance !== provision.docBCompliance) { provision.discrepancies.push(`Doc A is ${provision.docACompliance || 'unknown'} but Doc B is ${provision.docBCompliance || 'unknown'}`); } const highSeverityA = provision.docAIssues.filter(i => i.severity === 'critical' || i.severity === 'high'); const highSeverityB = provision.docBIssues.filter(i => i.severity === 'critical' || i.severity === 'high'); if (highSeverityA.length> 0 || highSeverityB.length> 0) { provision.actionRequired = 'URGENT: Address critical/high severity issues immediately'; } else if (provision.docAIssues.length> 0 || provision.docBIssues.length> 0) { provision.actionRequired = 'Review and remediate medium/low severity issues'; } else { provision.actionRequired = 'No action required - monitoring'; } matrix.push(provision); }); // Sort by severity (critical issues first) matrix.sort((a, b) => { const aHasCritical = [...a.docAIssues, ...a.docBIssues].some(i => i.severity === 'critical'); const bHasCritical = [...b.docAIssues, ...b.docBIssues].some(i => i.severity === 'critical'); if (aHasCritical && !bHasCritical) return -1; if (!aHasCritical && bHasCritical) return 1; const aHasHigh = [...a.docAIssues, ...a.docBIssues].some(i => i.severity === 'high'); const bHasHigh = [...b.docAIssues, ...b.docBIssues].some(i => i.severity === 'high'); if (aHasHigh && !bHasHigh) return -1; if (!aHasHigh && bHasHigh) return 1; return 0; }); return matrix; }; const performCrossReference = (phaseAResults) => { const discrepancies = []; const consistencies = []; const omissions = []; const refsA = new Set(phaseAResults.fileA[0].findings.legalReferences.map(r => r.text.toLowerCase())); const refsB = new Set(phaseAResults.fileB[0].findings.legalReferences.map(r => r.text.toLowerCase())); refsA.forEach(ref => { if (refsB.has(ref)) { consistencies.push({ type: 'Statutory Reference', element: ref, status: 'Present in both documents' }); } else { omissions.push({ type: 'Statutory Reference', element: ref, status: 'Present only in File A' }); } }); refsB.forEach(ref => { if (!refsA.has(ref)) { omissions.push({ type: 'Statutory Reference', element: ref, status: 'Present only in File B' }); } }); const termsA = phaseAResults.fileA[0].findings.keyTermsIdentified.map(t => t.term); const termsB = phaseAResults.fileB[0].findings.keyTermsIdentified.map(t => t.term); const significantDiscrepancy = Math.abs(termsA.length - termsB.length)> 5; if (significantDiscrepancy) { discrepancies.push({ type: 'Document Comprehensiveness', description: `Significant difference in legal terminology density (File A: ${termsA.length} terms, File B: ${termsB.length} terms)`, severity: 'medium' }); } const complianceA = checkVictorianStatutoryCompliance( fileContents.fileA, files.fileA?.documentType || 'General Legal Document', phaseAResults.fileA[0].findings.legalReferences ); const complianceB = checkVictorianStatutoryCompliance( fileContents.fileB, files.fileB?.documentType || 'General Legal Document', phaseAResults.fileB[0].findings.legalReferences ); const narrativeEvaluation = evaluateCrossFileNarrativeTimeline( fileContents.fileA, fileContents.fileB, files.fileA, files.fileB ); const omissionsReport = generateOmissionsReport( fileContents.fileA, fileContents.fileB, phaseAResults ); const complianceMatrix = buildComplianceMatrix( phaseAResults, complianceA, complianceB ); return { discrepancies, consistencies: consistencies.slice(0, 10), omissions: omissions.slice(0, 10), omissionsReport: omissionsReport, complianceMatrix: complianceMatrix, governingFramework: identifyGoverningFramework(phaseAResults), complianceAssessment: assessCompliance(phaseAResults), victorianCompliance: { fileA: complianceA, fileB: complianceB }, narrativeAndTimeline: narrativeEvaluation }; }; const identifyGoverningFramework = (phaseAResults) => { const frameworks = []; phaseAResults.fileA.forEach(analysis => { analysis.findings.legalReferences.forEach(ref => { if (ref.type === 'Act Citation') { frameworks.push({ statute: ref.text, source: 'File A', applicability: 'Primary governing legislation' }); } }); }); phaseAResults.fileB.forEach(analysis => { analysis.findings.legalReferences.forEach(ref => { if (ref.type === 'Act Citation') { frameworks.push({ statute: ref.text, source: 'File B', applicability: 'Primary governing legislation' }); } }); }); return frameworks; }; const assessCompliance = (phaseAResults) => { const assessment = { fileA: { compliant: 0, nonCompliant: 0, unclear: 0, criticalIssues: 0, highIssues: 0, mediumIssues: 0, lowIssues: 0, totalWeight: 0, riskLevel: 'LOW' }, fileB: { compliant: 0, nonCompliant: 0, unclear: 0, criticalIssues: 0, highIssues: 0, mediumIssues: 0, lowIssues: 0, totalWeight: 0, riskLevel: 'LOW' } }; ['fileA', 'fileB'].forEach(fileKey => { let fileRiskScore = 0; phaseAResults[fileKey].forEach(analysis => { const potentialIssues = analysis.findings.potentialIssues; const issues = potentialIssues.issues || potentialIssues; const summary = potentialIssues.summary; if (summary) { assessment[fileKey].criticalIssues += summary.critical || 0; assessment[fileKey].highIssues += summary.high || 0; assessment[fileKey].mediumIssues += summary.medium || 0; assessment[fileKey].lowIssues += summary.low || 0; fileRiskScore += summary.overallRiskScore || 0; if (summary.critical> 0 || summary.high> 0) { assessment[fileKey].nonCompliant++; } else if (summary.medium> 0) { assessment[fileKey].unclear++; } else { assessment[fileKey].compliant++; } } else { if (issues.length === 0) { assessment[fileKey].compliant++; } else { issues.forEach(issue => { if (issue.severity === 'critical') { assessment[fileKey].criticalIssues++; assessment[fileKey].nonCompliant++; } else if (issue.severity === 'high') { assessment[fileKey].highIssues++; assessment[fileKey].nonCompliant++; } else if (issue.severity === 'medium') { assessment[fileKey].mediumIssues++; assessment[fileKey].unclear++; } else { assessment[fileKey].lowIssues++; assessment[fileKey].unclear++; } }); } } }); assessment[fileKey].totalWeight = fileRiskScore; assessment[fileKey].riskLevel = fileRiskScore> 40 ? 'CRITICAL' : fileRiskScore> 25 ? 'HIGH' : fileRiskScore> 15 ? 'MEDIUM' : 'LOW'; }); return assessment; }; /** * Apply Interpretation Act 1984 (Vic) Section 35(a) - Purposive Construction * Analyzes provisions to determine Parliament's intention and legislative purpose */ const applyPurposiveConstruction = (provision, context) => { const analysis = { provision: provision, parliamentaryIntention: '', mischiefAddressed: '', purposeAdvanced: '', recommendation: '' }; if (provision.includes('s.49') || provision.includes('section 49')) { analysis.parliamentaryIntention = 'Parliament intended to provide lawful authority for preliminary breath testing while protecting individual rights through procedural safeguards'; analysis.mischiefAddressed = 'Addresses the mischief of impaired driving detection while preventing arbitrary testing without reasonable grounds'; analysis.purposeAdvanced = 'Road safety through evidence-based detection of alcohol impairment, balanced against procedural fairness'; analysis.recommendation = 'Interpret requirements strictly - each element must be satisfied to advance the protective purpose'; } else if (provision.includes('s.55') || provision.includes('section 55')) { analysis.parliamentaryIntention = 'Parliament intended to establish evidentiary breath testing regime with strict procedural compliance to ensure accuracy and fairness'; analysis.mischiefAddressed = 'Prevents unreliable breath test evidence while ensuring procedural integrity of testing process'; analysis.purposeAdvanced = 'Reliable evidence of BAC levels through mandated procedures and device standards'; analysis.recommendation = 'Strict compliance with directions and procedures required - deviations undermine legislative purpose'; } else if (provision.includes('RSA') || provision.includes('Road Safety Act')) { analysis.parliamentaryIntention = 'Comprehensive road safety framework balancing enforcement with procedural protections'; analysis.mischiefAddressed = 'Road trauma from impaired driving while maintaining evidentiary standards'; analysis.purposeAdvanced = 'Public safety through evidence-based prosecutions with procedural safeguards'; analysis.recommendation = 'Purposive interpretation requires balancing safety objectives with fairness to accused'; } else { analysis.parliamentaryIntention = 'Determine purpose through text, context, and legislative scheme'; analysis.mischiefAddressed = 'Consider what problem the provision addresses'; analysis.purposeAdvanced = 'Interpretation should advance the identified legislative purpose'; analysis.recommendation = 'Apply purposive construction per Interpretation Act 1984 (Vic) s.35(a)'; } return analysis; }; /** * Apply Interpretation Act 1984 (Vic) Section 36 - Use of Extrinsic Materials * Identifies ambiguous provisions and suggests reference to extrinsic aids */ const identifyExtrinsicMaterialsNeeded = (provision, ambiguity) => { const extrinsicAnalysis = { provision: provision, isAmbiguous: false, ambiguityType: '', suggestedMaterials: [], applicationGuidance: '' }; const ambiguousPhrases = [ { phrase: 'reason to believe', type: 'Subjective vs Objective Standard' }, { phrase: 'as soon as practicable', type: 'Temporal Requirement' }, { phrase: 'in accordance with', type: 'Compliance Standard' }, { phrase: 'satisfied that', type: 'Evidentiary Threshold' }, { phrase: 'directions', type: 'Form and Content of Directions' }, { phrase: 'approved', type: 'Authorization Standard' } ]; for (const item of ambiguousPhrases) { if (provision.toLowerCase().includes(item.phrase) || ambiguity.includes(item.phrase)) { extrinsicAnalysis.isAmbiguous = true; extrinsicAnalysis.ambiguityType = item.type; extrinsicAnalysis.suggestedMaterials = [ `Second Reading Speech for relevant amending Act (if Victorian legislation)`, `Explanatory Memorandum addressing "${item.phrase}" requirement`, `Parliamentary Committee Reports on road safety legislation`, `Prior judicial interpretation of "${item.phrase}" in Victorian courts`, `Regulatory Impact Statements for relevant regulations` ]; extrinsicAnalysis.applicationGuidance = `Per Interpretation Act 1984 (Vic) s.36, extrinsic materials may be considered to: (a) confirm plain meaning; (b) resolve ambiguity; (c) determine Parliament's intention. Materials cannot override clear statutory language but can illuminate meaning of "${item.phrase}".`; break; } } return extrinsicAnalysis; }; /** * Apply Common Law Maxim: Noscitur a sociis (words known by company) * Interprets words in context of surrounding words */ const applyNosciturASociis = (phrase, context) => { const analysis = { phrase: phrase, surroundingContext: '', interpretation: '', application: '' }; if (phrase.includes('reason to believe')) { analysis.surroundingContext = 'Within s.49, "reason to believe" appears alongside requirements for preliminary testing, indications of alcohol consumption, and observation requirements'; analysis.interpretation = 'Must be interpreted in context of other s.49 requirements - objective basis required, not mere suspicion'; analysis.application = 'Officer must articulate specific facts constituting "reason to believe" consistent with other evidentiary requirements in s.49'; } else if (phrase.includes('in accordance with')) { analysis.surroundingContext = 'Appears with "directions", "approved device", and procedural requirements'; analysis.interpretation = 'Strict compliance interpretation - must follow directions precisely as the surrounding procedural language requires exactitude'; analysis.application = 'Deviations from directions may vitiate test validity, as phrase appears in procedural compliance context'; } else if (phrase.includes('directions')) { analysis.surroundingContext = 'Used with "oral or written", "given by", and "approved device"'; analysis.interpretation = 'Directions must be clear, communicated (oral or written), and relate to approved device operation'; analysis.application = 'Vague or uncommunicated instructions cannot constitute "directions" in this statutory context'; } else { analysis.surroundingContext = context || 'Analyze within immediate statutory context'; analysis.interpretation = 'Interpret term by reference to associated words and phrases'; analysis.application = 'Apply noscitur a sociis to derive meaning from statutory company'; } return analysis; }; /** * Apply Common Law Maxim: Expressio unius est exclusio alterius * Express mention of specific things excludes others not mentioned */ const applyExpressioUnius = (listProvision) => { const analysis = { expresslyIncluded: [], impliedlyExcluded: '', legalConsequence: '', example: '' }; if (listProvision.includes('s.49(1)') || listProvision.includes('section 49(1)')) { analysis.expresslyIncluded = [ 's.49(1)(a) - Driving or in charge of motor vehicle', 's.49(1)(b) - Consumed intoxicating liquor', 's.49(1)(c) - Accident involving injury/death', 's.49(1)(d) - Involved in accident', 's.49(1)(e) - Committed traffic offence', 's.49(1)(f) - Driving in manner dangerous', 's.49(1)(g) - Subject to alcohol interlock condition', 's.49(1)(h) - Random breath testing' ]; analysis.impliedlyExcluded = 'Any circumstances NOT listed in s.49(1)(a)-(h) do NOT authorize preliminary breath test'; analysis.legalConsequence = 'If test conducted outside listed circumstances, test is unauthorized and potentially inadmissible'; analysis.example = 'Example: If officer lacks "reason to believe" under (b) and no other subsection applies, test is unauthorized'; } else if (listProvision.includes('approved') || listProvision.includes('prescribed')) { analysis.expresslyIncluded = ['Specifically approved/prescribed items per regulation']; analysis.impliedlyExcluded = 'Non-approved or non-prescribed items/procedures are excluded'; analysis.legalConsequence = 'Use of non-approved device or non-prescribed procedure renders test invalid'; analysis.example = 'Example: Only breath testing devices specifically approved may be used - substitutes excluded'; } else { analysis.expresslyIncluded = ['Items explicitly listed in provision']; analysis.impliedlyExcluded = 'Items not listed are implicitly excluded'; analysis.legalConsequence = 'Express list limits scope of provision'; analysis.example = 'Apply expressio unius to statutory lists'; } return analysis; }; /** * Apply Common Law Maxim: Generalia specialibus non derogant * Specific provisions override general provisions */ const applyGeneraliaSpecialibus = (generalProvision, specificProvision) => { const analysis = { generalProvision: generalProvision, specificProvision: specificProvision, whichPrevails: '', reasoning: '', practicalEffect: '' }; if (specificProvision.includes('s.55D') || specificProvision.includes('s.55E')) { analysis.specificProvision = 'RSA 1986 ss.55D-55E (specific breath test direction requirements)'; analysis.generalProvision = generalProvision || 'General testing provisions under RSA Part 5'; analysis.whichPrevails = 'Specific provisions in ss.55D-55E prevail'; analysis.reasoning = 'Sections 55D-55E contain detailed, specific requirements for breath test directions and procedures. These override general testing provisions.'; analysis.practicalEffect = 'Must comply with specific s.55D requirements (directions, timing) even if general provisions might allow broader discretion'; } else if (specificProvision.includes('s.49')) { analysis.specificProvision = 's.49 RSA (specific preliminary test requirements)'; analysis.generalProvision = generalProvision || 'General police powers'; analysis.whichPrevails = 'Specific s.49 requirements prevail'; analysis.reasoning = 's.49 lists specific circumstances authorizing preliminary tests - these specific requirements override general police discretion'; analysis.practicalEffect = 'Cannot rely on general police powers to conduct test outside s.49(1)(a)-(h) circumstances'; } else { analysis.whichPrevails = 'Specific provision prevails over general'; analysis.reasoning = 'Where specific and general provisions conflict, specific controls per generalia specialibus non derogant'; analysis.practicalEffect = 'Apply specific statutory requirements strictly'; } return analysis; }; /** * Apply Common Law Maxim: Ejusdem generis (of the same kind) * General words following specific words are interpreted consistently */ const applyEjusdemGeneris = (specificList, generalTerm) => { const analysis = { specificItems: specificList, generalTerm: generalTerm, interpretation: '', limitation: '' }; if (generalTerm.includes('other') || generalTerm.includes('similar')) { analysis.interpretation = `General term "${generalTerm}" must be interpreted ejusdem generis - of the same kind as the specific items listed`; analysis.limitation = `"${generalTerm}" is limited to items sharing characteristics of: ${specificList.join(', ')}`; } else { analysis.interpretation = 'Interpret general terms following specific lists as being of the same kind'; analysis.limitation = 'General language constrained by nature of specific examples'; } return analysis; }; /** * COMPREHENSIVE AMBIGUITY RESOLVER * Provides literal, contextual, and purposive interpretations for ambiguous phrases */ const resolveAmbiguity = (ambiguousPhrase, documentContext, statutoryContext) => { const resolution = { ambiguousPhrase: ambiguousPhrase, literalInterpretation: { meaning: '', analysis: '', strengths: '', weaknesses: '' }, contextualInterpretation: { meaning: '', analysis: '', statutoryScheme: '', strengths: '', weaknesses: '' }, purposiveInterpretation: { meaning: '', analysis: '', legislativePurpose: '', mischiefRule: '', strengths: '', weaknesses: '' }, victorianCourtPreference: '', recommendedInterpretation: '', caseLawPrinciples: [] }; if (ambiguousPhrase.toLowerCase().includes('reason to believe')) { resolution.literalInterpretation = { meaning: 'Plain English: A reason (cause, ground) to believe (accept as true)', analysis: 'Ordinary meaning suggests some factual basis for belief, but does not specify objective or subjective standard', strengths: 'Simple, accessible interpretation aligned with common usage', weaknesses: 'Ambiguous whether purely subjective belief sufficient or objective reasonableness required' }; resolution.contextualInterpretation = { meaning: 'Within s.49 statutory context: Objective factual basis for belief that person consumed intoxicating liquor', analysis: 's.49 is a police power provision requiring justification for interference with liberty. Context suggests objective standard.', statutoryScheme: 's.49 part of graduated testing regime (preliminary ‚Üí evidentiary). Each stage requires objective basis. Context demands "reason" be objectively verifiable.', strengths: 'Consistent with other s.49 requirements; protects against arbitrary testing; aligns with rule of law', weaknesses: 'More demanding than plain text might suggest' }; resolution.purposiveInterpretation = { meaning: 'Objectively reasonable grounds based on observable facts to believe alcohol consumed', analysis: 'Legislative purpose balances road safety with individual rights. Requires articulable, objective basis.', legislativePurpose: 'Parliament intended to authorize testing while preventing arbitrary exercises of power. Purpose advanced by objective standard.', mischiefRule: 'Mischief addressed: impaired driving detection. But also addresses mischief of arbitrary state power. Requires objective reasonableness.', strengths: 'Advances legislative purpose of balanced enforcement; consistent with Interpretation Act 1984 (Vic) s.35(a)', weaknesses: 'Imposes requirements not explicit in text' }; resolution.victorianCourtPreference = 'Victorian courts would prefer PURPOSIVE/CONTEXTUAL interpretation requiring objective reasonableness'; resolution.recommendedInterpretation = 'Adopt objective standard: "reason to believe" requires articulable, objectively reasonable grounds based on observable facts. Purely subjective belief insufficient.'; resolution.caseLawPrinciples = [ 'Modern statutory interpretation favors purposive approach (Interpretation Act 1984 (Vic) s.35(a))', 'Police power provisions interpreted with attention to rights protection', 'Ambiguity in penal/quasi-penal statutes resolved in favor of subject', 'Context and purpose trump literalism where ambiguity exists' ]; } else if (ambiguousPhrase.toLowerCase().includes('in accordance with')) { resolution.literalInterpretation = { meaning: 'Plain meaning: In conformity with; following; complying with', analysis: 'Suggests requirement for compliance, but does not specify degree of exactitude required', strengths: 'Clear requirement for some form of compliance', weaknesses: 'Does not specify whether substantial compliance sufficient or strict compliance required' }; resolution.contextualInterpretation = { meaning: 'Within s.55D context: Strict compliance with directions for breath test procedure', analysis: 's.55D creates procedural safeguards for evidentiary testing. Context suggests strict compliance.', statutoryScheme: 'Breath test results are scientific evidence affecting liberty. Statutory scheme requires precision in procedure. "In accordance with" in this context means strict compliance.', strengths: 'Protects evidentiary integrity; ensures procedural fairness; consistent with scientific testing requirements', weaknesses: 'May invalidate tests for minor, non-prejudicial deviations' }; resolution.purposiveInterpretation = { meaning: 'Strict compliance with directions required to ensure test validity and procedural fairness', analysis: 'Purpose of s.55D: ensure reliable, procedurally sound breath testing. Requires strict compliance.', legislativePurpose: 'Parliament intended to ensure breath tests conducted properly with clear procedures. Purpose demands strict interpretation.', mischiefRule: 'Addresses mischief of unreliable or procedurally flawed breath testing. Strict compliance advances this purpose.', strengths: 'Advances legislative purpose; protects accused from procedural irregularities; ensures evidence reliability', weaknesses: 'Strict approach may exclude otherwise reliable evidence' }; resolution.victorianCourtPreference = 'Victorian courts would prefer STRICT COMPLIANCE interpretation given evidentiary and liberty interests'; resolution.recommendedInterpretation = '"In accordance with directions" requires strict compliance. Material deviations from directions vitiate test validity. Minor, non-prejudicial variations may be excused if no unfairness results.'; resolution.caseLawPrinciples = [ 'Evidentiary provisions in criminal/traffic matters require strict construction', 'Procedural safeguards must be observed to protect accused', 'Scientific evidence requires procedural integrity', 'Purposive interpretation favors strict compliance where liberty interests engaged' ]; } else if (ambiguousPhrase.toLowerCase().includes('directions') || ambiguousPhrase.toLowerCase().includes('direction')) { resolution.literalInterpretation = { meaning: 'Plain meaning: Instructions or orders about how to do something', analysis: 'Ordinary meaning suggests communication of instructions, but does not specify form, content, or detail required', strengths: 'Flexible interpretation allowing various forms of instruction', weaknesses: 'Ambiguous as to whether oral suffices, how specific directions must be, whether understanding required' }; resolution.contextualInterpretation = { meaning: 'Within RSA context: Clear, communicated instructions (oral or written) about breath test procedure', analysis: 's.55D(2) explicitly allows "oral or written" directions, indicating communication is essential. Context requires clarity.', statutoryScheme: 'Directions serve to ensure person understands procedure and can comply. Must be sufficiently clear and communicated. Statutory context suggests directions must be comprehensible and actually given.', strengths: 'Ensures procedural fairness; person knows what is required; enables compliance', weaknesses: 'May exclude tests where directions unclear or not proven' }; resolution.purposiveInterpretation = { meaning: 'Clear, communicated instructions enabling subject to understand and comply with breath test procedure', analysis: 'Purpose: ensure person tested understands procedure and can meaningfully comply. Requires actual communication.', legislativePurpose: 'Parliament intended directions to safeguard procedural fairness and enable informed compliance. Purpose requires actual, clear communication.', mischiefRule: 'Addresses mischief of procedurally unfair testing where person does not understand requirements. Demands clear, communicated directions.', strengths: 'Protects procedural rights; ensures fairness; advances purpose of informed compliance', weaknesses: 'May require proof of actual communication and understanding' }; resolution.victorianCourtPreference = 'Victorian courts would require CLEAR, COMMUNICATED directions with proof of actual communication'; resolution.recommendedInterpretation = '"Directions" requires proof that clear instructions were actually communicated (orally or in writing) to the subject. Mere device operation without communicated directions insufficient.'; resolution.caseLawPrinciples = [ 'Procedural requirements in testing regimes must be strictly observed', 'Directions imply communication - unspoken intentions insufficient', 'Purposive interpretation requires directions serve their protective function', 'Ambiguity resolved to protect procedural rights of accused' ]; } else { resolution.literalInterpretation = { meaning: `Plain, ordinary meaning of "${ambiguousPhrase}"`, analysis: 'Interpret words in natural, ordinary sense unless context demands otherwise', strengths: 'Accessible, predictable interpretation', weaknesses: 'May not capture legislative intent or statutory purpose' }; resolution.contextualInterpretation = { meaning: `"${ambiguousPhrase}" interpreted within statutory context and legislative scheme`, analysis: 'Consider surrounding provisions, relationship to other sections, overall statutory purpose', statutoryScheme: 'Examine how phrase fits within broader legislative framework', strengths: 'Harmonizes with legislative scheme; considers broader context', weaknesses: 'May depart from plain meaning' }; resolution.purposiveInterpretation = { meaning: `"${ambiguousPhrase}" interpreted to advance legislative purpose`, analysis: 'Interpretation that promotes purpose of legislation preferred per Interpretation Act 1984 (Vic) s.35(a)', legislativePurpose: 'Determine Parliament\'s intention and mischief addressed', mischiefRule: 'Consider problem provision designed to remedy', strengths: 'Advances legislative purpose; consistent with modern interpretation principles', weaknesses: 'Requires identification of purpose, which may be contested' }; resolution.victorianCourtPreference = 'Victorian courts favor PURPOSIVE interpretation per Interpretation Act 1984 (Vic) s.35(a)'; resolution.recommendedInterpretation = 'Apply modern purposive approach: examine text, context, and legislative purpose. Prefer interpretation advancing statutory purpose.'; resolution.caseLawPrinciples = [ 'Interpretation Act 1984 (Vic) s.35(a) mandates purposive construction', 'Text, context, and purpose analyzed together', 'Extrinsic materials may be consulted per s.36', 'Ambiguity in penal provisions resolved favorably to accused' ]; } return resolution; }; /** * HARMONIZATION ANALYZER * Reconciles conflicts between documents using interpretation principles */ const harmonizeConflicts = (conflicts, phaseAResults, phaseBResults) => { const harmonizations = []; conflicts.forEach(conflict => { const harmonization = { conflict: conflict.description || conflict.element || conflict.type, fileAPosition: '', fileBPosition: '', reconciliationAttempt: '', isReconcilable: false, whichPrevails: '', statutorySupport: '', legalConsequence: '', argumentApproach: '' }; harmonization.fileAPosition = `File A: ${conflict.status?.includes('File A') ? conflict.element : 'Position stated in File A'}`; harmonization.fileBPosition = `File B: ${conflict.status?.includes('File B') ? conflict.element : 'Position stated in File B'}`; if (conflict.type === 'Statutory Reference' || conflict.element?.toLowerCase().includes('s.') || conflict.element?.toLowerCase().includes('section')) { harmonization.reconciliationAttempt = 'Apply harmonious construction principle: attempt to read both documents together to give effect to all provisions. If both documents purport to describe same event, reconcile by examining whether references are complementary or contradictory.'; if (conflict.status?.includes('only in File A')) { harmonization.isReconcilable = false; harmonization.whichPrevails = 'File A contains statutory reference absent from File B'; harmonization.statutorySupport = 'File A has express statutory support; File B lacks this support'; harmonization.legalConsequence = 'File B may be deficient if statutory reference is material to facts. File A position preferred if statutory basis required.'; harmonization.argumentApproach = 'ARGUMENT: File B omits material statutory reference present in File A. Where statutory authority required, File A account prevails. Omission in File B raises question of procedural compliance.'; } else if (conflict.status?.includes('only in File B')) { harmonization.isReconcilable = false; harmonization.whichPrevails = 'File B contains statutory reference absent from File A'; harmonization.statutorySupport = 'File B has express statutory support; File A lacks this support'; harmonization.legalConsequence = 'File A may be deficient if statutory reference is material. File B position preferred if statutory grounding required.'; harmonization.argumentApproach = 'ARGUMENT: File A omits statutory reference present in File B. Question whether File A actions had statutory foundation. File B reference may reveal procedural defect in File A account.'; } else { harmonization.isReconcilable = true; harmonization.whichPrevails = 'Documents can be read harmoniously'; harmonization.statutorySupport = 'Both documents reference relevant statutory provisions'; harmonization.legalConsequence = 'No conflict - documents consistent on statutory framework'; harmonization.argumentApproach = 'Documents align on statutory basis - no interpretative issue'; } } else if (conflict.type === 'Document Comprehensiveness' || conflict.description?.includes('terminology density')) { harmonization.reconciliationAttempt = 'Differences in detail or terminology density do not necessarily create irreconcilable conflict. Apply principle that more detailed account may supplement (not contradict) less detailed account.'; harmonization.isReconcilable = true; harmonization.whichPrevails = 'More comprehensive document provides fuller account'; harmonization.statutorySupport = 'No direct statutory conflict - difference in detail level'; harmonization.legalConsequence = 'More detailed document may reveal omissions in less detailed document. Not necessarily contradictory.'; harmonization.argumentApproach = 'ARGUMENT: Difference in comprehensiveness suggests one document more complete. Question which is contemporaneous and which is reconstruction. More detailed document may be preferred if created closer to events.'; } else { harmonization.reconciliationAttempt = 'Attempt harmonious construction: can documents be read together without contradiction? If irreconcilable, determine which has better statutory foundation and contemporaneous reliability.'; harmonization.isReconcilable = false; harmonization.whichPrevails = 'Depends on statutory support, contemporaneous creation, and procedural context'; harmonization.statutorySupport = 'Analyze which document has express statutory grounding'; harmonization.legalConsequence = 'Irreconcilable conflict raises credibility and reliability issues. May constitute evidence defect.'; harmonization.argumentApproach = 'ARGUMENT: Where documents irreconcilable, prefer document with (1) statutory foundation, (2) contemporaneous creation, (3) procedural safeguards. Conflict itself may be evidence of unreliability.'; } harmonizations.push(harmonization); }); return harmonizations; }; /** * STATUTORY PROVISION INTERPRETATION REPORT GENERATOR * Generates detailed interpretation reports for key provisions */ const generateProvisionReport = (provision, documentText, findings) => { const report = { provision: provision, plainText: '', applicationToFacts: '', requirementsSatisfied: null, deficiencies: [], legalConsequences: [], recommendedArgument: '' }; if (provision.includes('s.49') || provision.includes('section 49') || provision.includes('s 49')) { report.plainText = 'Road Safety Act 1986 (Vic) s.49 - Preliminary Breath Test. Requires: (1) Person driving/in charge of motor vehicle; (2) Officer has reason to believe person consumed intoxicating liquor [s.49(1)(b)] OR other circumstances in s.49(1)(a)-(h); (3) Officer may require preliminary breath test; (4) Person must comply with requirement.'; report.applicationToFacts = `Analyzing documents for s.49 compliance:\n`; const hasReasonToBelieve = documentText.toLowerCase().includes('reason to believe') || documentText.toLowerCase().includes('believed') || documentText.toLowerCase().includes('appeared'); const hasObservations = documentText.toLowerCase().includes('smell') || documentText.toLowerCase().includes('odour') || documentText.toLowerCase().includes('alcohol') || documentText.toLowerCase().includes('intoxicated'); if (hasReasonToBelieve && hasObservations) { report.applicationToFacts += '- Document contains reference to belief/observations regarding alcohol consumption\n'; report.applicationToFacts += '- Observable facts may constitute "reason to believe" under s.49(1)(b)\n'; report.requirementsSatisfied = 'POTENTIALLY - requires verification of objective basis'; } else if (hasReasonToBelieve && !hasObservations) { report.applicationToFacts += '- Document mentions belief but lacks specific observable facts\n'; report.applicationToFacts += '- Insufficient detail to assess whether objective "reason to believe" established\n'; report.requirementsSatisfied = 'UNCLEAR - insufficient factual detail'; report.deficiencies.push('No specific observable facts articulated to establish "reason to believe"'); } else { report.applicationToFacts += '- No express reference to "reason to believe" alcohol consumed\n'; report.applicationToFacts += '- Document does not establish s.49(1)(b) basis for preliminary test\n'; report.requirementsSatisfied = 'NOT SATISFIED - no reason to believe established'; report.deficiencies.push('CRITICAL: No evidence of "reason to believe" person consumed intoxicating liquor per s.49(1)(b)'); } if (report.deficiencies.length> 0) { report.legalConsequences.push('Preliminary breath test may be unauthorized if s.49 requirements not satisfied'); report.legalConsequences.push('Unauthorized preliminary test may affect admissibility of subsequent evidentiary test'); report.legalConsequences.push('Lack of statutory authority for initial stop/test may vitiate entire procedure'); } if (report.requirementsSatisfied === 'NOT SATISFIED') { report.recommendedArgument = 'LITERAL INTERPRETATION ARGUMENT: s.49 expressly requires "reason to believe" person consumed intoxicating liquor. Document lacks any evidence of this prerequisite. Per expressio unius principle, circumstances listed in s.49(1)(a)-(h) are exhaustive - test outside these circumstances is unauthorized. Preliminary test was unlawful, vitiating subsequent evidentiary procedure.'; } else if (report.requirementsSatisfied === 'UNCLEAR') { report.recommendedArgument = 'PURPOSIVE INTERPRETATION ARGUMENT: s.49 "reason to believe" requires objective, articulable basis per Interpretation Act 1984 (Vic) s.35(a). Document fails to articulate specific observable facts. Mere conclusory assertion of belief insufficient. Legislative purpose of protecting against arbitrary testing requires objective basis - not present here.'; } else { report.recommendedArgument = 'VERIFY: While document references observations, confirm they constitute objectively reasonable grounds for belief of alcohol consumption. Apply contextual interpretation of "reason to believe" - requires more than subjective suspicion.'; } } else if (provision.includes('s.55D') || provision.includes('section 55D') || provision.includes('s.55') || provision.includes('s 55')) { report.plainText = 'Road Safety Act 1986 (Vic) s.55D - Breath Test Directions. Requires: (1) Test must be "in accordance with the directions" of person conducting test; (2) Directions may be oral or written; (3) Person must be given opportunity to comply; (4) Procedure must follow approved device requirements.'; report.applicationToFacts = `Analyzing documents for s.55D compliance:\n`; const hasDirections = documentText.toLowerCase().includes('directions') || documentText.toLowerCase().includes('directed') || documentText.toLowerCase().includes('instructed') || documentText.toLowerCase().includes('told'); const hasSpecificDirections = documentText.toLowerCase().includes('blow') || documentText.toLowerCase().includes('breathe') || documentText.toLowerCase().includes('provide'); if (hasDirections && hasSpecificDirections) { report.applicationToFacts += '- Document contains reference to directions/instructions\n'; report.applicationToFacts += '- Some evidence of directions regarding breath sample provision\n'; report.requirementsSatisfied = 'PARTIALLY - requires verification of full compliance'; } else if (hasDirections && !hasSpecificDirections) { report.applicationToFacts += '- Document mentions directions but lacks specific content\n'; report.applicationToFacts += '- Insufficient detail about what directions were actually given\n'; report.requirementsSatisfied = 'UNCLEAR - direction content not established'; report.deficiencies.push('No evidence of specific directions content as required by s.55D'); } else { report.applicationToFacts += '- No reference to directions being given\n'; report.applicationToFacts += '- Document does not establish s.55D directions requirement\n'; report.requirementsSatisfied = 'NOT SATISFIED - no evidence directions given'; report.deficiencies.push('CRITICAL: No evidence that directions were given per s.55D(1) requirement'); } const hasDeviceMention = documentText.toLowerCase().includes('device') || documentText.toLowerCase().includes('machine') || documentText.toLowerCase().includes('approved'); if (!hasDeviceMention) { report.deficiencies.push('No mention of approved device - cannot assess "in accordance with directions" compliance'); } if (report.deficiencies.length> 0) { report.legalConsequences.push('Breath test result potentially inadmissible if not conducted "in accordance with directions"'); report.legalConsequences.push('s.55D is mandatory procedural requirement - non-compliance vitiates test validity'); report.legalConsequences.push('Lack of proof that directions given is evidentiary deficiency'); } if (report.requirementsSatisfied === 'NOT SATISFIED') { report.recommendedArgument = 'LITERAL/STRICT COMPLIANCE ARGUMENT: s.55D(1) expressly requires test be "in accordance with the directions" of person conducting test. Document contains NO evidence that any directions were actually given. Cannot have test "in accordance with" non-existent directions. This is mandatory procedural requirement - strict compliance required. Breath test result inadmissible.'; } else if (report.requirementsSatisfied === 'UNCLEAR') { report.recommendedArgument = 'PURPOSIVE INTERPRETATION ARGUMENT: s.55D serves protective purpose - ensures person understands procedure and can meaningfully comply. Purpose requires proof that clear directions were actually communicated. Document fails to establish what directions were given or that subject understood them. Per Interpretation Act s.35(a), purposive construction requires actual communication - not present here.'; } else { report.recommendedArgument = 'VERIFY STRICT COMPLIANCE: s.55D requires strict compliance with directions. Confirm: (1) directions actually given (oral or written); (2) directions were clear and comprehensible; (3) test conducted exactly in accordance with directions; (4) approved device used. Any material deviation may vitiate test.'; } } else if (provision.toLowerCase().includes('road safety act') || provision.toLowerCase().includes('rsa')) { report.plainText = 'Road Safety Act 1986 (Vic) - Comprehensive traffic and road safety legislation governing driving offences, testing procedures, and evidentiary requirements.'; report.applicationToFacts = 'Road Safety Act provides statutory framework for breath testing regime. Key provisions: Part 5 (drink and drug driving), ss.49-56 (testing procedures), evidentiary provisions.'; report.requirementsSatisfied = 'REQUIRES ANALYSIS - multiple provisions may apply'; report.recommendedArgument = 'Apply purposive construction per Interpretation Act 1984 (Vic) s.35(a). RSA balances road safety objectives with procedural protections for accused. Strict compliance with testing procedures required to advance protective purpose.'; } else { report.plainText = `Statutory provision: ${provision}`; report.applicationToFacts = 'Analyze how provision applies to facts in documents. Determine whether statutory requirements satisfied.'; report.requirementsSatisfied = 'REQUIRES DETAILED ANALYSIS'; report.recommendedArgument = 'Apply modern interpretative approach: examine text (literal meaning), context (statutory scheme), and purpose (legislative intention). Prefer interpretation advancing statutory purpose.'; } return report; }; /** * MAIN STATUTORY INTERPRETATION FUNCTION - PHASE C * Orchestrates all interpretation analyses */ const performStatutoryInterpretation = (phaseAResults, phaseBResults) => { const allStatutoryRefs = []; phaseAResults.fileA.forEach(analysis => { analysis.findings.legalReferences.forEach(ref => { if (ref.type === 'Act Citation' || ref.type === 'Section Reference') { allStatutoryRefs.push({ ref: ref.text, source: 'File A' }); } }); }); phaseAResults.fileB.forEach(analysis => { analysis.findings.legalReferences.forEach(ref => { if (ref.type === 'Act Citation' || ref.type === 'Section Reference') { allStatutoryRefs.push({ ref: ref.text, source: 'File B' }); } }); }); const interpretationActAnalysis = { section35aPurposive: allStatutoryRefs.slice(0, 5).map(item => applyPurposiveConstruction(item.ref, `Found in ${item.source}`) ), section36ExtrinsicMaterials: [] }; const ambiguousPhrases = ['reason to believe', 'in accordance with', 'directions', 'as soon as practicable', 'satisfied that']; ambiguousPhrases.forEach(phrase => { const extrinsicAnalysis = identifyExtrinsicMaterialsNeeded( allStatutoryRefs[0]?.ref || 'Road Safety Act provisions', phrase ); if (extrinsicAnalysis.isAmbiguous) { interpretationActAnalysis.section36ExtrinsicMaterials.push(extrinsicAnalysis); } }); const commonLawMaxims = { nosciturASociis: [ applyNosciturASociis('reason to believe', 's.49 RSA context'), applyNosciturASociis('in accordance with', 's.55D RSA context'), applyNosciturASociis('directions', 's.55D RSA context') ], expressioUnius: [ applyExpressioUnius('s.49(1)(a)-(h) RSA - circumstances authorizing preliminary breath test'), applyExpressioUnius('approved devices and prescribed procedures') ], generaliaSpecialibus: [ applyGeneraliaSpecialibus('General police testing powers', 's.49 RSA specific preliminary test requirements'), applyGeneraliaSpecialibus('General testing provisions', 's.55D-55E RSA specific breath test directions') ], ejusdemGeneris: [ applyEjusdemGeneris(['driving', 'in charge of', 'operating'], 'other similar control of vehicle') ] }; const ambiguityResolutions = [ resolveAmbiguity('reason to believe', fileContents.fileA + fileContents.fileB, 's.49 Road Safety Act'), resolveAmbiguity('in accordance with directions', fileContents.fileA + fileContents.fileB, 's.55D Road Safety Act'), resolveAmbiguity('directions', fileContents.fileA + fileContents.fileB, 's.55D(2) Road Safety Act') ]; const conflicts = [ ...phaseBResults.discrepancies, ...phaseBResults.omissions ]; const harmonizationAnalysis = harmonizeConflicts(conflicts, phaseAResults, phaseBResults); const provisionReports = [ generateProvisionReport('s.49 Road Safety Act 1986 (Vic)', fileContents.fileA, phaseAResults.fileA), generateProvisionReport('s.55D Road Safety Act 1986 (Vic)', fileContents.fileA, phaseAResults.fileA), generateProvisionReport('s.49 Road Safety Act 1986 (Vic)', fileContents.fileB, phaseAResults.fileB), generateProvisionReport('s.55D Road Safety Act 1986 (Vic)', fileContents.fileB, phaseAResults.fileB) ]; return { interpretationAct1984: interpretationActAnalysis, commonLawMaxims: commonLawMaxims, ambiguityResolver: ambiguityResolutions, harmonization: harmonizationAnalysis, provisionReports: provisionReports, literalInterpretation: { approach: 'Textualist/Literal Analysis', findings: 'Plain meaning interpretation applied. See detailed provision reports for literal interpretation of key requirements.' }, contextualInterpretation: { approach: 'Contextual Analysis', findings: 'Provisions interpreted within statutory context. See common law maxims (noscitur a sociis) for contextual analysis.' }, purposiveInterpretation: { approach: 'Interpretation Act 1984 (Vic) s.35(a) - Purposive Construction', findings: 'Legislative purpose analyzed for each provision. See Section 35(a) analysis for detailed purposive interpretation.' }, extrinsicAids: { availableAids: interpretationActAnalysis.section36ExtrinsicMaterials.length> 0 ? interpretationActAnalysis.section36ExtrinsicMaterials[0].suggestedMaterials : ['Second reading speeches', 'Explanatory memoranda', 'Parliamentary debates', 'Prior judicial interpretation'], application: 'Per Interpretation Act 1984 (Vic) s.36, extrinsic materials may be consulted to confirm meaning or resolve ambiguity.' }, interpretativePrinciples: [ { principle: 'Interpretation Act 1984 (Vic) s.35(a)', application: 'Purposive construction - interpretation advancing legislative purpose preferred' }, { principle: 'Interpretation Act 1984 (Vic) s.36', application: 'Extrinsic materials may be used to resolve ambiguity' }, { principle: 'Noscitur a sociis', application: 'Words known by their company - interpret in context' }, { principle: 'Expressio unius est exclusio alterius', application: 'Express mention excludes others' }, { principle: 'Generalia specialibus non derogant', application: 'Specific provisions prevail over general' }, { principle: 'Ejusdem generis', application: 'General words limited by specific examples' } ] }; }; const performMagistratesCourtAnalysis = async (phaseAResults, phaseBResults, phaseCResults) => { const contentA = fileContents.fileA || ''; const contentB = fileContents.fileB || ''; const combinedContent = contentA + '\n' + contentB; let courtCompliance = null; if (window.MagistratesCourtChecker) { try { const checker = new window.MagistratesCourtChecker(); courtCompliance = await checker.analyzeCourtCompliance(combinedContent, { checkDisclosure: true, checkRSA: true }); } catch (error) { console.error('Court Compliance Analysis failed:', error); } } const defectCategories = categorizeDefects(phaseAResults, phaseBResults, contentA, contentB); const procedureCompliance = checkMagistratesCourtProcedure(combinedContent, defectCategories); const rsaCompliance = performRSAChecklist(combinedContent); const disclosureCompliance = checkDisclosureCompliance(combinedContent); const courtSubmissions = generateCourtReadySubmissions(defectCategories, rsaCompliance, disclosureCompliance); const learningInsights = analyzeCasePatterns(defectCategories); return { defectCategories, procedureCompliance, rsaCompliance, disclosureCompliance, courtSubmissions, learningInsights, courtCompliance // Add the new court compliance results }; }; const categorizeDefects = (phaseAResults, phaseBResults, contentA, contentB) => { const categories = { categoryA_Jurisdictional: [], categoryB_Procedural: [], categoryC_Evidentiary: [], categoryD_Factual: [] }; const statutoryAuthMatches = checkPattern(contentA + contentB, /pursuant to|under (section|s\.)\s*\d+|authorized by/gi); if (statutoryAuthMatches.count === 0) { categories.categoryA_Jurisdictional.push({ defectId: 'A1', title: 'Missing Statutory Authority Citation', description: 'No statutory authority cited for actions taken', severity: 'CRITICAL', legalConsequence: 'Court may lack jurisdiction to proceed - decision may be void ab initio', evidence: 'No references to statutory authority found in either document', remedy: 'Prosecution must identify and cite specific statutory provision authorizing action' }); } const indictableIndicators = checkPattern(contentA + contentB, /indictable|higher court|committal|county court/gi); if (indictableIndicators.count> 0) { categories.categoryA_Jurisdictional.push({ defectId: 'A2', title: 'Potential Jurisdictional Limitation', description: 'Document references indictable offenses or higher court matters', severity: 'HIGH', legalConsequence: 'Magistrates\' Court may lack summary jurisdiction', evidence: indictableIndicators.matches.slice(0, 3).join('; '), remedy: 'Verify offense is summary or summarily triable under CPA s.28 or 29' }); } const timeLimitMatches = checkPattern(contentA + contentB, /time.*limit|statute.*limitation|prescribed time|within.*months/gi); if (timeLimitMatches.count> 0) { categories.categoryA_Jurisdictional.push({ defectId: 'A3', title: 'Time Limitation Period Referenced', description: 'Document mentions time limits for prosecution', severity: 'HIGH', legalConsequence: 'Prosecution outside limitation period is void for want of jurisdiction', evidence: timeLimitMatches.matches.slice(0, 3).join('; '), remedy: 'Verify prosecution commenced within limitation period under CPA s.7 or relevant statute' }); } const disclosureDefects = identifyDisclosureDefects(contentA, contentB); categories.categoryB_Procedural.push(...disclosureDefects); const s49Prerequisites = checks49Prerequisites(contentA, contentB); if (s49Prerequisites.defects.length> 0) { categories.categoryB_Procedural.push(...s49Prerequisites.defects); } const s55Compliance = checks55DECompliance(contentA, contentB); if (s55Compliance.defects.length> 0) { categories.categoryB_Procedural.push(...s55Compliance.defects); } const documentValidation = checkDocumentFormalities(contentA, contentB); categories.categoryB_Procedural.push(...documentValidation); const serviceEvidence = checkServiceEvidence(contentA, contentB); if (serviceEvidence.defects.length> 0) { categories.categoryB_Procedural.push(...serviceEvidence.defects); } const hearsayDefects = identifyHearsayDefects(contentA, contentB); categories.categoryC_Evidentiary.push(...hearsayDefects); const opinionDefects = identifyOpinionDefects(contentA, contentB); categories.categoryC_Evidentiary.push(...opinionDefects); const improperEvidence = checkImproperlyObtainedEvidence(contentA, contentB); if (improperEvidence.defects.length> 0) { categories.categoryC_Evidentiary.push(...improperEvidence.defects); } const prejudicialEvidence = checkUnfairlyPrejudicialEvidence(contentA, contentB); categories.categoryC_Evidentiary.push(...prejudicialEvidence); const authenticationDefects = checkAuthentication(contentA, contentB); categories.categoryC_Evidentiary.push(...authenticationDefects); const properPerformanceDefects = checkProperPerformanceEvidence(contentA, contentB); categories.categoryC_Evidentiary.push(...properPerformanceDefects); const timelineDefects = identifyTimelineContradictions(contentA, contentB); categories.categoryD_Factual.push(...timelineDefects); const conflictingStatements = phaseBResults.discrepancies.map(disc => ({ defectId: 'D2', title: 'Conflicting Statement Between Documents', description: disc.description, severity: 'MEDIUM', legalConsequence: 'Inconsistencies may affect witness credibility and weight of evidence', evidence: disc.details, remedy: 'Reconcile conflict through cross-examination or additional evidence' })); categories.categoryD_Factual.push(...conflictingStatements); // D3: Missing critical facts const missingFacts = identifyMissingCriticalFacts(contentA, contentB); categories.categoryD_Factual.push(...missingFacts); return categories; }; const exportReport = async () => { if (!analysisResults) return; const learningInsights = await AnalysisMemory.generateLearningInsights(); const currentDefects = AnalysisMemory.extractDefects(analysisResults); const crossIntelligence = await AnalysisMemory.getIntelligenceForAnalysis(currentDefects); const allPatterns = await AnalysisMemory.getAllDefectPatterns(); const allStatutes = await AnalysisMemory.getAllStatutoryReferences(); const enhancedReport = { metadata: { exportDate: new Date().toISOString(), reportVersion: '2.0-Enhanced', includesLearningData: true }, currentAnalysis: { timestamp: new Date().toISOString(), files: { fileA: files.fileA?.name, fileB: files.fileB?.name }, findings: analysisResults, defectsFound: currentDefects.length, severitySummary: AnalysisMemory.calculateSeveritySummary(currentDefects) }, systemIntelligence: { totalHistoricalAnalyses: learningInsights.totalAnalyses, totalDefectsTracked: learningInsights.totalDefects, mostCommonIssue: learningInsights.mostCommonIssue, complianceTrends: learningInsights.temporalTrends, recommendations: learningInsights.recommendations }, crossAnalysisIntelligence: { novelIssues: crossIntelligence.filter(i => i.isNovel).length, recurringIssues: crossIntelligence.filter(i => i.isRecurring).length, details: crossIntelligence.map(intel => ({ defectType: intel.defect.type, severity: intel.defect.severity, description: intel.defect.description, isNovel: intel.isNovel, isRecurring: intel.isRecurring, previousOccurrences: intel.previousOccurrences || 0, recommendation: intel.recommendation })) }, defectPatterns: { total: allPatterns.length, recurring: allPatterns.filter(p => p.occurrence_count>= 3).length, patterns: allPatterns.map(p => ({ type: p.defect_type, description: p.description, occurrences: p.occurrence_count, firstSeen: p.first_seen, lastSeen: p.last_seen, recommendation: p.recommendation })) }, statutoryCompliance: { total: allStatutes.length, compliance: allStatutes.map(s => ({ reference: s.reference, statute: s.statute_name, timesEncountered: s.times_encountered, complianceRate: s.compliance_rate, associatedDefects: s.associated_defects })) }, exportedBy: 'Forensic Legal Analyzer v2.0 - Enhanced Learning System' }; const blob = new Blob([JSON.stringify(enhancedReport, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `forensic-analysis-enhanced-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url); }; const identifyDisclosureDefects = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; const requiredDisclosure = [ { item: 'informant statement', pattern: /informant.*statement|statement.*informant/gi, section: 's.187(1)(a)' }, { item: 'witness statements', pattern: /witness.*statement|statement.*witness/gi, section: 's.187(1)(b)' }, { item: 'exhibits list', pattern: /exhibit|list.*exhibit/gi, section: 's.187(1)(c)' }, { item: 'prior convictions', pattern: /prior.*conviction|criminal.*history|antecedent/gi, section: 's.187(1)(d)' } ]; requiredDisclosure.forEach(req => { const found = combined.match(req.pattern); if (!found || found.length === 0) { defects.push({ defectId: 'B1', title: `Missing Disclosure: ${req.item}`, description: `No reference to ${req.item} in either document`, severity: 'HIGH', legalConsequence: `Breach of mandatory disclosure requirement - CPA 2009 ${req.section}`, evidence: `No mention of ${req.item} found`, remedy: `Prosecution must provide ${req.item} per CPA Part 3.3 or seek direction from Magistrate` }); } }); return defects; }; const checks49Prerequisites = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; const reasonToBelieve = combined.match(/reason to believe|reasonable.*belief/gi); if (!reasonToBelieve) { defects.push({ defectId: 'B2', title: 'Missing s.49 "Reason to Believe" Basis', description: 'No evidence of required "reason to believe" for preliminary test', severity: 'CRITICAL', legalConsequence: 'Preliminary test unlawful without proper statutory basis - RSA s.49(1)', evidence: 'No statement of belief or grounds for belief found', remedy: 'Officer must articulate specific observations under s.49(1)(a)-(h) forming basis for belief', statutoryReference: 'Road Safety Act 1986 s.49(1): Officer must have reason to believe one of enumerated circumstances exists' }); } const indicators = [ 'smell.*alcohol', 'bloodshot.*eyes', 'slurred.*speech', 'unsteady.*gait', 'affected.*driving', 'accident', 'random.*breath.*test', 'drug.*affected' ]; const foundIndicators = indicators.filter(ind => new RegExp(ind, 'gi').test(combined)); if (foundIndicators.length === 0) { defects.push({ defectId: 'B2a', title: 'Missing Specific s.49(1) Indicators', description: 'No specific factual circumstances identified under s.49(1)(a)-(h)', severity: 'CRITICAL', legalConsequence: 'Insufficient basis for preliminary test - bare assertion insufficient', evidence: 'No enumerated circumstances under s.49(1)(a)-(h) documented', remedy: 'Officer must identify which specific circumstance(s) under s.49(1)(a)-(h) were present', statutoryReference: 'RSA s.49(1)(a)-(h) exhaustively lists circumstances authorizing preliminary test' }); } return { defects }; }; const checks55DECompliance = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; const directionsCompliance = combined.match(/in accordance with|directions.*use|followed.*directions/gi); if (!directionsCompliance) { defects.push({ defectId: 'B3', title: 'Missing s.55D(1) Directions Compliance Evidence', description: 'No evidence test conducted "in accordance with directions"', severity: 'CRITICAL', legalConsequence: 'Test result inadmissible without proof of s.55D(1) compliance', evidence: 'No mention of directions or compliance with directions', remedy: 'Officer must prove specific directions for device use were followed', statutoryReference: 'RSA s.55D(1): test must be conducted "in accordance with the directions for use"' }); } const directionsGiven = combined.match(/oral.*direction|written.*direction|directions.*given|instructed/gi); if (!directionsGiven) { defects.push({ defectId: 'B3a', title: 'Missing s.55D(2) Directions Evidence', description: 'No evidence oral or written directions provided to subject', severity: 'HIGH', legalConsequence: 'Failure to provide directions may vitiate test - s.55D(2) requirement', evidence: 'No mention of giving directions to subject', remedy: 'Officer must prove gave oral directions (if literate) or written (if not literate in English) per s.55D(2)', statutoryReference: 'RSA s.55D(2): Officer must give oral or written directions depending on literacy' }); } const properPerformance = { approved: combined.match(/approved.*device|device.*approved/gi), designed: combined.match(/used as designed|designed.*use/gi), working: combined.match(/working order|properly.*functioning/gi), maintained: combined.match(/properly maintained|maintenance.*record/gi) }; if (!properPerformance.approved) { defects.push({ defectId: 'B3b', title: 'Missing s.55E "Approved Device" Evidence', description: 'No evidence device was approved under RSA', severity: 'HIGH', legalConsequence: 'Cannot rely on s.55E presumption without proof of approved device', evidence: 'No mention of device approval status', remedy: 'Prosecution must prove device approved by Governor in Council under RSA', statutoryReference: 'RSA s.55E: Presumption only applies if device approved for use under Act' }); } if (!properPerformance.working) { defects.push({ defectId: 'B3c', title: 'Missing s.55E "Working Order" Evidence', description: 'No evidence device was in working order', severity: 'HIGH', legalConsequence: 'Cannot rely on s.55E presumption - must prove device working order', evidence: 'No mention of device functionality testing or working order', remedy: 'Officer must provide evidence device was tested and functioning correctly', statutoryReference: 'RSA s.55E: Presumption requires device "is in working order"' }); } if (!properPerformance.maintained) { defects.push({ defectId: 'B3d', title: 'Missing s.55E "Properly Maintained" Evidence', description: 'No evidence device was properly maintained', severity: 'MEDIUM', legalConsequence: 'Weakens s.55E presumption - maintenance evidence typically required', evidence: 'No maintenance records or maintenance verification mentioned', remedy: 'Prosecution should provide maintenance logs or certificate of calibration', statutoryReference: 'RSA s.55E: Presumption requires device "has been properly maintained"' }); } return { defects }; }; const checkDocumentFormalities = (contentA, contentB) => { const defects = []; const signaturesA = contentA.match(/signed|signature|sworn|declared/gi); const signaturesB = contentB.match(/signed|signature|sworn|declared/gi); if (!signaturesA) { defects.push({ defectId: 'B4', title: 'Document A: Missing Signature Evidence', description: 'No indication Document A is signed, sworn, or declared', severity: 'MEDIUM', legalConsequence: 'Unsigned document may not be admissible as sworn evidence', evidence: 'No reference to signature, oath, or affirmation in Document A', remedy: 'Verify document properly executed and signed per Evidence Act requirements' }); } const datesA = contentA.match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}/gi); const datesB = contentB.match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}/gi); if (!datesA || datesA.length === 0) { defects.push({ defectId: 'B4a', title: 'Document A: Missing Date', description: 'No date identified in Document A', severity: 'MEDIUM', legalConsequence: 'Undated document raises authenticity and reliability concerns', evidence: 'No date found in Document A', remedy: 'Document should be dated when created/signed' }); } if (!datesB || datesB.length === 0) { defects.push({ defectId: 'B4b', title: 'Document B: Missing Date', description: 'No date identified in Document B', severity: 'MEDIUM', legalConsequence: 'Undated document raises authenticity and reliability concerns', evidence: 'No date found in Document B', remedy: 'Document should be dated when created/signed' }); } return defects; }; const checkServiceEvidence = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; const serviceIndicators = combined.match(/served|service|provided.*copy|delivered|received/gi); if (!serviceIndicators) { defects.push({ defectId: 'B5', title: 'Missing Evidence of Service', description: 'No evidence documents served on accused/defendant', severity: 'MEDIUM', legalConsequence: 'Procedural irregularity - accused must be properly served per CPA', evidence: 'No mention of service, delivery, or provision of documents', remedy: 'Prosecution must prove service per CPA Part 2.4 (ss.28-35)' }); } return { defects }; }; const identifyHearsayDefects = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; <div style={{ backgroundColor: '#eff6ff', borderLeft: '4px solid #2563eb', padding: '16px', marginBottom: '24px' }}><h3 style={{ fontWeight: '600', color: '#1e3a8a', marginBottom: '8px' }}>System Capabilities:</h3><ul style={{ fontSize: '14px', color: '#1e40af', listStyle: 'none', padding: 0 }}><li style={{ marginBottom: '4px' }}>‚Ä¢ Phase A: Multi-preset forensic examination using {interpretivePresets.length} interpretive frameworks</li><li style={{ marginBottom: '4px' }}>‚Ä¢ Phase B: Statutory framework identification and cross-reference analysis</li><li style={{ marginBottom: '4px' }}>‚Ä¢ Phase C: Comprehensive statutory interpretation applying modern purposive approach</li><li style={{ marginBottom: '4px' }}>‚Ä¢ Identifies legal flaws, factual inconsistencies, and procedural defects</li><li style={{ marginBottom: '4px', fontWeight: '600' }}>‚Ä¢ üìä Learning System: Tracks defect patterns, compliance trends, and generates process improvements</li><li style={{ fontWeight: '600' }}>‚Ä¢ üîç Cross-Analysis Intelligence: Identifies recurring issues and novel defects across all analyses</li></ul></div> hearsayIndicators.forEach(indicator => { const matches = combined.match(indicator.pattern); if (matches && matches.length> 0) { defects.push({ defectId: 'C1', title: 'Potential Hearsay Evidence', description: `Document contains ${indicator.description}`, severity: 'HIGH', legalConsequence: 'Hearsay inadmissible unless exception applies - Evidence Act s.59', evidence: matches.slice(0, 2).join('; '), remedy: 'Prosecution must identify applicable hearsay exception (ss.60-75) or call original source as witness', statutoryReference: 'Evidence Act 2008 s.59: Hearsay rule - evidence of previous representation inadmissible to prove asserted fact' }); } }); return defects; }; const identifyOpinionDefects = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; const opinionIndicators = /appears to|seemed|looked like|in my opinion|I believe|my view/gi; const expertiseIndicators = /qualified|expert|specialist|training|experience.*years/gi; const opinions = combined.match(opinionIndicators); const expertise = combined.match(expertiseIndicators); if (opinions && opinions.length> 0 && (!expertise || expertise.length === 0)) { defects.push({ defectId: 'C2', title: 'Opinion Evidence Without Expertise Foundation', description: 'Document contains opinion evidence without establishing expertise', severity: 'MEDIUM', legalConsequence: 'Opinion evidence inadmissible without proof of expertise - Evidence Act ss.76-79', evidence: opinions.slice(0, 3).join('; '), remedy: 'Witness must be qualified as expert (s.79) or opinion must be lay opinion based on perception (s.78)', statutoryReference: 'Evidence Act 2008 s.76: Opinion rule - opinion evidence inadmissible unless exception' }); } return defects; }; const checkImproperlyObtainedEvidence = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; const improperIndicators = [ 'unlawful', 'illegal.*obtained', 'warrant.*expired', 'without.*consent', 'improper', 'unlawfully', 'breach.*of.*rights' ]; improperIndicators.forEach(indicator => { const pattern = new RegExp(indicator, 'gi'); const matches = combined.match(pattern); if (matches) { defects.push({ defectId: 'C3', title: 'Potential Improperly Obtained Evidence', description: `Reference to ${indicator} in documents`, severity: 'CRITICAL', legalConsequence: 'Evidence may be excluded under Evidence Act s.138 discretion', evidence: matches.slice(0, 2).join('; '), remedy: 'Defence should apply to exclude under s.138 - court must weigh probative value vs public interest', statutoryReference: 'Evidence Act 2008 s.138: Discretion to exclude improperly or illegally obtained evidence' }); } }); return { defects }; }; const checkUnfairlyPrejudicialEvidence = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; const prejudicialIndicators = [ 'criminal.*history', 'prior.*conviction', 'bad.*character', 'previous.*offense', 'similar.*fact' ]; prejudicialIndicators.forEach(indicator => { const pattern = new RegExp(indicator, 'gi'); const matches = combined.match(pattern); if (matches) { defects.push({ defectId: 'C4', title: 'Potential Unfairly Prejudicial Evidence', description: `Reference to ${indicator} may be prejudicial`, severity: 'MEDIUM', legalConsequence: 'Evidence may be excluded if probative value outweighed by prejudicial effect - Evidence Act s.137', evidence: matches.slice(0, 2).join('; '), remedy: 'Defence should apply under s.137 for exclusion if evidence unfairly prejudicial', statutoryReference: 'Evidence Act 2008 s.137: Mandatory exclusion if probative value outweighed by unfair prejudice' }); } }); return defects; }; const checkAuthentication = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; const certificateIndicators = combined.match(/certificate|certify|certified|sworn.*statement/gi); const breathTestRefs = combined.match(/breath.*test|breath.*analysis|evidentiary.*test/gi); if (breathTestRefs && breathTestRefs.length> 0 && (!certificateIndicators || certificateIndicators.length === 0)) { defects.push({ defectId: 'C5', title: 'Missing s.48 Certificate for Breath Test', description: 'Breath test referenced but no s.48 certificate mentioned', severity: 'CRITICAL', legalConsequence: 'Breath test result inadmissible without s.48 certificate - fundamental requirement', evidence: 'Breath test mentioned but no reference to certificate', remedy: 'Prosecution must tender s.48 certificate signed by testing officer', statutoryReference: 'RSA s.48: Certificate in prescribed form is evidence of facts stated - mandatory for evidentiary tests' }); } return defects; }; const checkProperPerformanceEvidence = (contentA, contentB) => { const defects = []; const combined = contentA + contentB; const performanceElements = { calibration: combined.match(/calibrat|calibration|accuracy.*check/gi), testing: combined.match(/test.*device|device.*test|self.*test/gi), certification: combined.match(/certifi.*device|device.*certified/gi), errorChecks: combined.match(/error.*message|fault|malfunction/gi) }; if (!performanceElements.calibration && !performanceElements.testing) { defects.push({ defectId: 'C6', title: 'Insufficient Proper Performance Evidence (s.55E)', description: 'No evidence of device calibration, testing, or accuracy verification', severity: 'HIGH', legalConsequence: 'Cannot establish s.55E presumption without proper performance evidence', evidence: 'No mention of calibration, testing, or device performance verification', remedy: 'Prosecution should provide calibration records, testing protocols, or maintenance logs', statutoryReference: 'RSA s.55E: Proper performance presumption requires evidence device maintained and working' }); } return defects; }; const identifyTimelineContradictions = (contentA, contentB) => { const defects = []; const timePattern = /\d{1,2}:\d{2}\s*(?:am|pm)?|\d{1,2}\s*(?:am|pm)/gi; const timesA = contentA.match(timePattern) || []; const timesB = contentB.match(timePattern) || []; if (timesA.length> 0 && timesB.length> 0) { const uniqueTimesA = [...new Set(timesA.map(t => t.toLowerCase()))]; const uniqueTimesB = [...new Set(timesB.map(t => t.toLowerCase()))]; const commonTimes = uniqueTimesA.filter(t => uniqueTimesB.includes(t)); if (commonTimes.length === 0 && timesA.length> 0 && timesB.length> 0) { defects.push({ defectId: 'D1', title: 'Timeline Discrepancy Between Documents', description: 'Documents contain different times with no common timepoints', severity: 'MEDIUM', legalConsequence: 'Timeline inconsistencies may affect credibility and reliability of evidence', evidence: `Document A times: ${uniqueTimesA.slice(0, 3).join(', ')}; Document B times: ${uniqueTimesB.slice(0, 3).join(', ')}`, remedy: 'Reconcile timeline through cross-examination or explanatory evidence' }); } } const sequenceIndicators = ['first', 'then', 'next', 'after', 'before', 'finally', 'subsequently']; const hasSequenceA = sequenceIndicators.some(ind => new RegExp('\\b' + ind + '\\b', 'i').test(contentA)); const hasSequenceB = sequenceIndicators.some(ind => new RegExp('\\b' + ind + '\\b', 'i').test(contentB)); if (hasSequenceA && hasSequenceB) { defects.push({ defectId: 'D1a', title: 'Potential Event Sequence Inconsistency', description: 'Both documents describe sequences of events - verify consistency', severity: 'LOW', legalConsequence: 'Sequence inconsistencies may undermine narrative reliability', evidence: 'Sequential indicators found in both documents', remedy: 'Compare event sequences in detail to identify any contradictions' }); } return defects; }; const identifyMissingCriticalFacts = (contentA, contentB) => { const defects = []; // Critical facts for criminal matters const criticalElements = [ { element: 'location', pattern: /\bat\b.*(?:street|road|avenue|court|place|location|address)/gi, description: 'Location/venue of alleged offense' }, { element: 'date', pattern: /\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}/gi, description: 'Date of alleged offense' }, { element: 'accused identification', pattern: /accused|defendant|charged|suspect|named/gi, description: 'Identification of accused person' }, { element: 'offense description', pattern: /offense|offence|charge|alleged|committed/gi, description: 'Description of alleged offense' } ]; const combined = contentA + contentB; criticalElements.forEach(elem => { const found = combined.match(elem.pattern); if (!found || found.length === 0) { defects.push({ defectId: 'D3', title: `Missing Critical Element: ${elem.description}`, description: `Neither document clearly establishes ${elem.element}`, severity: 'HIGH', legalConsequence: 'Prosecution must prove all elements of offense - gaps may be fatal to case', evidence: `No clear reference to ${elem.element} found`, remedy: `Prosecution must provide evidence of ${elem.element}` }); } }); return defects; }; const checkMagistratesCourtProcedure = (content, defectCategories) => { const procedureStages = { contestMention: { stage: 'Contest Mention', requirements: [ { item: 'Charge sheet filed', status: checkRequirement(content, /charge.*sheet|information.*filed/gi) }, { item: 'Disclosure provided (s.186 CPA)', status: checkRequirement(content, /disclosure|witness.*statement/gi) }, { item: 'Plea indicated', status: checkRequirement(content, /plea|not guilty|guilty/gi) }, { item: 'Notice of defences (s.185 CPA)', status: checkRequirement(content, /notice|alibi|defence/gi) } ], overallCompliance: 'PARTIAL' }, summaryCaseConference: { stage: 'Summary Case Conference', requirements: [ { item: 'Issues identified and narrowed', status: checkRequirement(content, /issue|dispute|contention/gi) }, { item: 'Admissions made', status: checkRequirement(content, /admission|admit|agreed/gi) }, { item: 'Disclosure complete', status: checkRequirement(content, /complete.*disclosure|disclosure.*complete/gi) } ], overallCompliance: 'UNKNOWN' }, summaryHearing: { stage: 'Summary Hearing', requirements: [ { item: 'Case outline filed', status: checkRequirement(content, /outline|summary.*case/gi) }, { item: 'Witness availability confirmed', status: checkRequirement(content, /witness.*available|subpoena/gi) }, { item: 'Voir dire applications foreshadowed', status: checkRequirement(content, /voir dire|admissibility|object/gi) } ], overallCompliance: 'NOT_COMMENCED' } }; let totalReqs = 0; let satisfiedReqs = 0; Object.values(procedureStages).forEach(stage => { stage.requirements.forEach(req => { totalReqs++; if (req.status === 'SATISFIED') satisfiedReqs++; }); }); const compliancePercentage = totalReqs> 0 ? Math.round((satisfiedReqs / totalReqs) * 100) : 0; return { stages: procedureStages, summary: { totalRequirements: totalReqs, satisfied: satisfiedReqs, compliancePercentage: compliancePercentage, assessment: compliancePercentage> 70 ? 'GOOD' : compliancePercentage> 40 ? 'PARTIAL' : 'POOR' } }; }; const checkRequirement = (content, pattern) => { const matches = content.match(pattern); return matches && matches.length> 0 ? 'SATISFIED' : 'NOT_SATISFIED'; }; const performRSAChecklist = (content) => { const checklist = { preliminaryTestChain: { section: 'Preliminary Test Chain (s.49-55E)', items: [ { requirement: 'Officer had "reason to believe" (s.49)', checked: /reason to believe/gi.test(content), mandatory: true, consequence: 'Preliminary test unlawful without statutory basis' }, { requirement: 'Belief based on specified indicators (s.49(1)(a)-(h))', checked: /smell|bloodshot|slurred|unsteady|accident|random/gi.test(content), mandatory: true, consequence: 'Must identify specific circumstance authorizing test' }, { requirement: 'Preliminary test authorized device (s.49)', checked: /approved.*device|authorized.*device/gi.test(content), mandatory: true, consequence: 'Device must be approved - test invalid otherwise' }, { requirement: 'Test "in accordance with directions" (s.55D(1))', checked: /in accordance with|followed.*directions/gi.test(content), mandatory: true, consequence: 'Test inadmissible without compliance with directions' }, { requirement: 'Directions given (oral if literate, written if not) (s.55D(2))', checked: /directions.*given|oral.*directions|written.*directions/gi.test(content), mandatory: true, consequence: 'Failure to give proper directions vitiates test' }, { requirement: 'Device approved for use', checked: /approved|authorized/gi.test(content), mandatory: true, consequence: 'Cannot rely on s.55E presumption' }, { requirement: 'Used as designed', checked: /designed|proper.*use|correct.*procedure/gi.test(content), mandatory: true, consequence: 'Improper use defeats presumption' }, { requirement: 'In working order', checked: /working|functioning|operational/gi.test(content), mandatory: true, consequence: 'Malfunctioning device produces unreliable results' }, { requirement: 'Properly maintained', checked: /maintained|maintenance|calibrat/gi.test(content), mandatory: false, consequence: 'Lack of maintenance evidence weakens reliability' }, { requirement: 'Result indicated presence of alcohol/drug', checked: /positive|detected|present|reading/gi.test(content), mandatory: true, consequence: 'Must have positive result to proceed to evidentiary test' } ] }, evidentiaryTestChain: { section: 'Evidentiary Test Chain (s.55)', items: [ { requirement: 'Conducted at approved location', checked: /police station|approved.*location/gi.test(content), mandatory: true, consequence: 'Test at unapproved location may be invalid' }, { requirement: 'Approved device used', checked: /approved.*device|breath.*analyzer/gi.test(content), mandatory: true, consequence: 'Device must be approved under RSA' }, { requirement: 'Proper performance established', checked: /working.*order|properly.*maintained|calibrat/gi.test(content), mandatory: true, consequence: 'Must establish s.55E proper performance presumption' }, { requirement: 'Certificate completed (s.48)', checked: /certificate|certify/gi.test(content), mandatory: true, consequence: 'Result inadmissible without s.48 certificate' } ] } }; const allItems = [...checklist.preliminaryTestChain.items, ...checklist.evidentiaryTestChain.items]; const mandatoryItems = allItems.filter(item => item.mandatory); const satisfiedMandatory = mandatoryItems.filter(item => item.checked).length; const totalSatisfied = allItems.filter(item => item.checked).length; checklist.summary = { totalItems: allItems.length, mandatoryItems: mandatoryItems.length, satisfiedMandatory: satisfiedMandatory, totalSatisfied: totalSatisfied, mandatoryCompliance: Math.round((satisfiedMandatory / mandatoryItems.length) * 100), overallCompliance: Math.round((totalSatisfied / allItems.length) * 100), assessment: satisfiedMandatory === mandatoryItems.length ? 'FULL_COMPLIANCE' : satisfiedMandatory> mandatoryItems.length * 0.7 ? 'PARTIAL_COMPLIANCE' : 'NON_COMPLIANT' }; return checklist; }; const checkDisclosureCompliance = (content) => { const matrix = { prosecutionDisclosure: { title: 'Mandatory Prosecution Disclosure (CPA s.187)', requirements: [ { item: 'Copy of informant statement (s.187(1)(a))', status: /informant.*statement/gi.test(content) ? 'PROVIDED' : 'MISSING', mandatory: true, timing: 'Before contest mention', consequence: 'Breach of s.187 - matter may be adjourned or struck out' }, { item: 'Copies of all witness statements (s.187(1)(b))', status: /witness.*statement/gi.test(content) ? 'PROVIDED' : 'MISSING', mandatory: true, timing: 'Before contest mention', consequence: 'Breach of s.187 - procedural unfairness' }, { item: 'List of exhibits (s.187(1)(c))', status: /exhibit|list.*exhibit/gi.test(content) ? 'PROVIDED' : 'MISSING', mandatory: true, timing: 'Before contest mention', consequence: 'Defence cannot properly prepare without exhibit list' }, { item: 'Accused prior convictions (s.187(1)(d))', status: /prior.*conviction|criminal.*history/gi.test(content) ? 'PROVIDED' : 'MISSING', mandatory: true, timing: 'Before contest mention', consequence: 'Required for plea and sentence indications' }, { item: 'Any exculpatory material', status: /exculpatory|favourable|inconsistent.*statement/gi.test(content) ? 'PROVIDED' : 'UNKNOWN', mandatory: true, timing: 'As soon as practicable', consequence: 'Prosecution duty to disclose - breach may result in stay or exclusion' } ] }, defenceDisclosure: { title: 'Defence Disclosure (CPA s.185)', requirements: [ { item: 'Alibi notice (if applicable)', status: /alibi/gi.test(content) ? 'PROVIDED' : 'NOT_APPLICABLE', mandatory: false, timing: '14 days before hearing', consequence: 'Alibi evidence may be excluded if notice not given' }, { item: 'Expert evidence notice', status: /expert|specialist.*report/gi.test(content) ? 'PROVIDED' : 'UNKNOWN', mandatory: false, timing: '21 days before hearing', consequence: 'Expert evidence inadmissible without notice' }, { item: 'Witnesses to be called', status: /witness.*list|witnesses.*called/gi.test(content) ? 'PROVIDED' : 'UNKNOWN', mandatory: false, timing: 'Before hearing', consequence: 'Procedural fairness to prosecution' } ] }, timingCompliance: { title: 'Timing Requirements (CPA s.186)', status: /within.*time|timely|timeframe/gi.test(content) ? 'SATISFIED' : 'UNKNOWN', requirement: 'Prosecution disclosure within timeframes under s.186', consequence: 'Late disclosure may result in adjournment with costs or other sanctions' } }; const allReqs = [...matrix.prosecutionDisclosure.requirements, ...matrix.defenceDisclosure.requirements]; const mandatoryReqs = allReqs.filter(req => req.mandatory); const satisfiedMandatory = mandatoryReqs.filter(req => req.status === 'PROVIDED' || req.status === 'SATISFIED').length; matrix.summary = { totalMandatory: mandatoryReqs.length, satisfiedMandatory: satisfiedMandatory, complianceRate: Math.round((satisfiedMandatory / mandatoryReqs.length) * 100), assessment: satisfiedMandatory === mandatoryReqs.length ? 'FULL_COMPLIANCE' : satisfiedMandatory> 0 ? 'PARTIAL_COMPLIANCE' : 'NON_COMPLIANT', risk: satisfiedMandatory <mandatoryReqs.length ? 'HIGH' : 'LOW' }; return matrix; }; const generateCourtReadySubmissions = (defectCategories, rsaCompliance, disclosureCompliance) => { const submissions = []; // Generate submissions for each critical defect defectCategories.categoryA_Jurisdictional.forEach(defect => { if (defect.severity === 'CRITICAL' || defect.severity === 'HIGH') { submissions.push(generateSubmission(defect, 'JURISDICTIONAL')); } }); defectCategories.categoryB_Procedural.forEach(defect => { if (defect.defectId.startsWith('B2') || defect.defectId.startsWith('B3')) { submissions.push(generateSubmission(defect, 'RSA_PROCEDURAL')); } }); defectCategories.categoryC_Evidentiary.forEach(defect => { if (defect.severity === 'CRITICAL' || defect.severity === 'HIGH') { submissions.push(generateSubmission(defect, 'EVIDENTIARY')); } }); if (disclosureCompliance.summary.assessment !== 'FULL_COMPLIANCE') { submissions.push(generateDisclosureSubmission(disclosureCompliance)); } return { submissions: submissions, count: submissions.length, summary: `${submissions.length} court-ready skeleton submissions generated based on identified defects` }; }; const generateSubmission = (defect, category) => { let applicableLaw = ''; let authorities = []; if (category === 'JURISDICTIONAL') { applicableLaw = 'The Magistrates\' Court derives its jurisdiction from statute. Any action taken without statutory authority, outside prescribed time limits, or beyond the court\'s summary jurisdiction is void ab initio.'; authorities = [ 'Principle: Jurisdictional error renders decision void (Craig v South Australia (1995) 184 CLR 163)', 'Principle: Strict compliance with time limits jurisdictional (various Victorian authorities)', 'Principle: Court cannot confer jurisdiction on itself' ]; } else if (category === 'RSA_PROCEDURAL') { applicableLaw = defect.statutoryReference || 'Road Safety Act 1986 provisions are mandatory and must be strictly complied with.'; authorities = [ 'Principle: Strict compliance with RSA testing procedures required', 'Principle: Failure to follow prescribed procedure may vitiate test', 'Principle: Prosecution bears onus of proving compliance with RSA requirements' ]; } else if (category === 'EVIDENTIARY') { applicableLaw = 'The Evidence Act 2008 provides strict rules governing admissibility of evidence. The prosecution bears the onus of proving admissibility.'; authorities = [ 'Principle: Hearsay inadmissible unless exception (s.59)', 'Principle: Opinion evidence inadmissible without expertise (s.76)', 'Principle: Court has discretion to exclude improperly obtained evidence (s.138)', 'Principle: Mandatory exclusion if unfairly prejudicial (s.137)' ]; } return { title: `SUBMISSION ON ${defect.title.toUpperCase()}`, defectId: defect.defectId, structure: { applicableLaw: { heading: 'Applicable Law', content: [ defect.statutoryReference || applicableLaw, defect.legalConsequence ] }, facts: { heading: 'Facts', content: [ `Document Evidence: "${defect.evidence}"`, `Issue: ${defect.description}` ] }, analysis: { heading: 'Analysis', content: [ `The documents reveal the following deficiency: ${defect.description}`, `This constitutes a ${defect.severity.toLowerCase()} defect because ${defect.legalConsequence.toLowerCase()}`, defect.remedy ] }, defectIdentified: { heading: 'Defect Identified', content: defect.title }, legalConsequence: { heading: 'Legal Consequence', content: defect.legalConsequence }, reliefSought: { heading: 'Relief Sought', content: determineReliefSought(defect, category) }, authorities: { heading: 'Authorities', content: authorities } }, formattedSubmission: formatSubmissionText(defect, applicableLaw, authorities, category) }; }; const generateDisclosureSubmission = (disclosureCompliance) => { const missingItems = disclosureCompliance.prosecutionDisclosure.requirements .filter(req => req.status === 'MISSING' && req.mandatory); return { title: 'SUBMISSION ON DISCLOSURE NON-COMPLIANCE', defectId: 'DISCLOSURE', structure: { applicableLaw: { heading: 'Applicable Law', content: [ 'Criminal Procedure Act 2009 Part 3.3 (ss.185-187) mandates disclosure by prosecution.', 'Section 187(1) requires prosecution to provide: (a) informant statement; (b) witness statements; (c) exhibit list; (d) prior convictions.', 'Section 186 specifies timing for disclosure.', 'Failure to comply may result in adjournment, costs, or striking out of charge.' ] }, facts: { heading: 'Facts', content: [ `${missingItems.length} mandatory disclosure item(s) not provided`, ...missingItems.map(item => `Missing: ${item.item}`) ] }, analysis: { heading: 'Analysis', content: [ 'Prosecution disclosure is mandatory, not discretionary.', 'Defence cannot properly prepare without complete disclosure.', 'Proceeding without disclosure would breach procedural fairness.', 'Court has power to enforce compliance through adjournment or costs orders.' ] }, defectIdentified: { heading: 'Defect Identified', content: 'Non-compliance with mandatory prosecution disclosure obligations under CPA Part 3.3' }, legalConsequence: { heading: 'Legal Consequence', content: 'Breach of procedural fairness; accused unable to properly prepare defence; potential for miscarriage of justice' }, reliefSought: { heading: 'Relief Sought', content: [ '1. Order that prosecution provide complete disclosure within 7 days', '2. Adjournment of proceedings pending compliance', '3. Costs of adjournment be borne by prosecution', '4. In default of compliance, charge be struck out' ].join('\n') }, authorities: { heading: 'Authorities', content: [ 'Criminal Procedure Act 2009 ss.185-187', 'Principle: Prosecution disclosure mandatory (various Victorian authorities)', 'Principle: Procedural fairness requires adequate disclosure', 'Principle: Court has inherent power to prevent abuse of process' ] } }, formattedSubmission: formatDisclosureSubmission(missingItems) }; }; const determineReliefSought = (defect, category) => { if (category === 'JURISDICTIONAL') { return 'Order that charge be struck out for want of jurisdiction / Order that proceedings be dismissed for jurisdictional defect'; } else if (category === 'RSA_PROCEDURAL') { return 'Order that preliminary test result be ruled inadmissible and excluded from evidence / Order that evidentiary test result be excluded'; } else if (category === 'EVIDENTIARY') { if (defect.defectId === 'C1') { return 'Order that hearsay evidence be ruled inadmissible and excluded pursuant to Evidence Act s.59'; } else if (defect.defectId === 'C3') { return 'Order that improperly obtained evidence be excluded in exercise of discretion under Evidence Act s.138'; } else if (defect.defectId === 'C4') { return 'Order that unfairly prejudicial evidence be excluded pursuant to Evidence Act s.137'; } else { return 'Order that inadmissible evidence be excluded'; } } return 'Order providing appropriate remedy for identified defect'; }; const formatSubmissionText = (defect, applicableLaw, authorities, category) => { return `SUBMISSION ON ${defect.title.toUpperCase()} Applicable Law: ${defect.statutoryReference || applicableLaw} ${defect.legalConsequence} Facts: Document evidence: "${defect.evidence}" Issue identified: ${defect.description} Analysis: The documents reveal the following deficiency: ${defect.description} This constitutes a ${defect.severity.toLowerCase()} defect because ${defect.legalConsequence.toLowerCase()} ${defect.remedy} Defect Identified: ${defect.title} Legal Consequence: ${defect.legalConsequence} Relief Sought: ${determineReliefSought(defect, category)} Authorities: ${authorities.join('\n')}`; }; const formatDisclosureSubmission = (missingItems) => { return `SUBMISSION ON DISCLOSURE NON-COMPLIANCE Applicable Law: Criminal Procedure Act 2009 Part 3.3 (ss.185-187) mandates prosecution disclosure. Section 187(1) requires prosecution to provide: (a) copy of informant's statement (b) copies of all witness statements (c) list of exhibits (d) accused's prior convictions (e) any exculpatory material Section 186 specifies timing for disclosure. Failure to comply may result in adjournment, costs, or striking out of charge. Facts: The following mandatory disclosure items have not been provided: ${missingItems.map(item => `‚Ä¢ ${item.item}`).join('\n')} Analysis: Prosecution disclosure under Part 3.3 is mandatory, not discretionary. Defence cannot properly prepare without complete disclosure. Proceeding without disclosure would breach procedural fairness requirements. The Court has power to enforce compliance through adjournment or costs orders, and in egregious cases may strike out the charge. Defect Identified: Non-compliance with mandatory prosecution disclosure obligations under Criminal Procedure Act 2009 Part 3.3 Legal Consequence: Breach of procedural fairness; accused unable to properly prepare defence; potential for miscarriage of justice if matter proceeds without disclosure Relief Sought: 1. Order that prosecution provide complete disclosure within 7 days 2. Adjournment of proceedings pending compliance with disclosure obligations 3. Costs of adjournment be borne by prosecution 4. In default of compliance within ordered timeframe, charge be struck out Authorities: ‚Ä¢ Criminal Procedure Act 2009 ss.185-187 ‚Ä¢ Principle: Prosecution disclosure mandatory (various Victorian authorities) ‚Ä¢ Principle: Procedural fairness requires adequate disclosure to accused ‚Ä¢ Principle: Court has inherent power to prevent abuse of process`; }; const analyzeCasePatterns = (defectCategories) => { const allDefects = [ ...defectCategories.categoryA_Jurisdictional, ...defectCategories.categoryB_Procedural, ...defectCategories.categoryC_Evidentiary, ...defectCategories.categoryD_Factual ]; const defectsByType = {}; const defectsBySeverity = { CRITICAL: [], HIGH: [], MEDIUM: [], LOW: [] }; allDefects.forEach(defect => { const typeKey = defect.defectId.substring(0, 2); if (!defectsByType[typeKey]) { defectsByType[typeKey] = []; } defectsByType[typeKey].push(defect); if (defectsBySeverity[defect.severity]) { defectsBySeverity[defect.severity].push(defect); } }); const insights = { totalDefects: allDefects.length, criticalDefects: defectsBySeverity.CRITICAL.length, highDefects: defectsBySeverity.HIGH.length, defectDistribution: { jurisdictional: defectCategories.categoryA_Jurisdictional.length, procedural: defectCategories.categoryB_Procedural.length, evidentiary: defectCategories.categoryC_Evidentiary.length, factual: defectCategories.categoryD_Factual.length }, commonPatterns: identifyCommonPatterns(allDefects), recommendations: generateRecommendations(defectsByType, defectsBySeverity), learningPoints: [ 'Pattern detection enabled - system will learn from outcomes', 'Track which defects lead to successful exclusion applications', 'Monitor typical judicial responses to each defect type', 'Build knowledge base of successful remediation strategies', 'User should provide feedback after court outcomes to enhance learning' ], feedbackPrompt: 'After court proceedings, please provide outcome feedback to enhance future analysis accuracy' }; return insights; }; const identifyCommonPatterns = (defects) => { const patterns = []; const rsaDefects = defects.filter(d => d.defectId.startsWith('B2') || d.defectId.startsWith('B3')); if (rsaDefects.length> 0) { patterns.push({ pattern: 'Road Safety Act Procedural Non-Compliance', frequency: rsaDefects.length, significance: 'HIGH', description: 'Multiple RSA 1986 procedural defects identified - systematic compliance issues apparent' }); } const disclosureDefects = defects.filter(d => d.defectId === 'B1' || d.title.includes('Disclosure')); if (disclosureDefects.length> 0) { patterns.push({ pattern: 'Disclosure Non-Compliance', frequency: disclosureDefects.length, significance: 'HIGH', description: 'Prosecution disclosure obligations not fully met - procedural fairness concerns' }); } const evidentiaryDefects = defects.filter(d => d.defectId.startsWith('C')); if (evidentiaryDefects.length>= 3) { patterns.push({ pattern: 'Multiple Evidentiary Admissibility Issues', frequency: evidentiaryDefects.length, significance: 'HIGH', description: 'Significant evidentiary defects - multiple exclusion applications warranted' }); } return patterns; }; const generateRecommendations = (defectsByType, defectsBySeverity) => { const recommendations = []; if (defectsBySeverity.CRITICAL.length> 0) { recommendations.push({ priority: 'URGENT', action: 'Address Critical Defects Immediately', details: `${defectsBySeverity.CRITICAL.length} critical defect(s) identified that may be fatal to prosecution case. Prepare submissions for immediate presentation to court.` }); } if (defectsByType['B2'] || defectsByType['B3']) { recommendations.push({ priority: 'HIGH', action: 'RSA Compliance Review', details: 'Road Safety Act procedural defects identified. Consider comprehensive admissibility challenge to breath test evidence.' }); } if (defectsByType['C1'] || defectsByType['C2'] || defectsByType['C3']) { recommendations.push({ priority: 'HIGH', action: 'Evidence Exclusion Applications', details: 'Multiple evidentiary defects warrant voir dire applications under Evidence Act. Prepare s.137/s.138 applications.' }); } if (defectsByType['A']) { recommendations.push({ priority: 'CRITICAL', action: 'Jurisdictional Challenge', details: 'Jurisdictional defects identified. Consider preliminary application to challenge court\'s jurisdiction before proceeding to hearing.' }); } recommendations.push({ priority: 'MEDIUM', action: 'Comprehensive Case Review', details: 'Review all identified defects with instructing solicitor and prepare detailed submissions for each substantive defect.' }); return recommendations; }; const generateExecutiveSummary = (phaseA, phaseB, phaseC, phaseD) => { const totalIssuesA = phaseA.fileA.reduce((sum, analysis) => sum + analysis.findings.potentialIssues.length, 0); const totalIssuesB = phaseA.fileB.reduce((sum, analysis) => sum + analysis.findings.potentialIssues.length, 0); const phaseDStats = phaseD ? { totalDefects: phaseD.learningInsights.totalDefects, critical: phaseD.learningInsights.criticalDefects, high: phaseD.learningInsights.highDefects, submissions: phaseD.courtSubmissions.count, rsaCompliance: phaseD.rsaCompliance.summary.mandatoryCompliance, disclosureCompliance: phaseD.disclosureCompliance.summary.complianceRate } : null; return { overallAssessment: totalIssuesA + totalIssuesB === 0 ? 'No Critical Issues Identified' : 'Issues Requiring Attention Identified', criticalFindings: [ `File A: ${totalIssuesA} potential issues identified across ${interpretivePresets.length} analytical presets`, `File B: ${totalIssuesB} potential issues identified across ${interpretivePresets.length} analytical presets`, `Cross-reference analysis: ${phaseB.discrepancies.length} discrepancies, ${phaseB.omissions.length} omissions`, `Governing framework: ${phaseB.governingFramework.length} statutory instruments identified`, ...(phaseDStats ? [ `Magistrates' Court Analysis: ${phaseDStats.totalDefects} defects identified (${phaseDStats.critical} critical, ${phaseDStats.high} high priority)`, `RSA 1986 Compliance: ${phaseDStats.rsaCompliance}% of mandatory requirements satisfied`, `Disclosure Compliance: ${phaseDStats.disclosureCompliance}% (CPA Part 3.3)`, `Court-ready submissions: ${phaseDStats.submissions} skeleton arguments generated` ] : []) ], recommendations: [ 'Review all identified discrepancies for potential procedural defects', 'Verify compliance with mandatory statutory requirements', 'Consider extrinsic materials for ambiguity resolution where necessary', 'Cross-check all statutory references against current legislation', 'Ensure harmonious interpretation between documents where possible', ...(phaseDStats && phaseDStats.critical> 0 ? [ `URGENT: Address ${phaseDStats.critical} critical defects immediately - may be fatal to prosecution case` ] : []), ...(phaseDStats && phaseDStats.rsaCompliance <100 ? [ 'Review RSA 1986 procedural compliance - consider admissibility challenges' ] : []), ...(phaseDStats && phaseDStats.disclosureCompliance <100 ? [ 'Seek complete disclosure under CPA Part 3.3 - apply for adjournment if necessary' ] : []) ], nextSteps: [ 'Detailed review of high-severity issues', 'Consultation of relevant case law for interpretative guidance', 'Preparation of submissions addressing identified defects', 'Verification of all factual assertions against evidence', ...(phaseDStats && phaseDStats.submissions> 0 ? [ `Review ${phaseDStats.submissions} court-ready submissions in Phase D section`, 'Adapt skeleton arguments to specific case circumstances', 'Identify applicable Victorian case law authorities', 'Prepare voir dire applications for evidentiary defects' ] : []) ] }; }; const toggleSection = (sectionId) => { setExpandedSections(prev => ({ ...prev, [sectionId]: !prev[sectionId] })); }; const exportReport = () => { if (!analysisResults) return; const report = { timestamp: new Date().toISOString(), files: { fileA: files.fileA?.name, fileB: files.fileB?.name }, analysis: analysisResults }; const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `forensic-analysis-${Date.now()}.json`; a.click(); }; const ProgressBar = ({ progress, label, showPercentage = true }) => ( <div style={{ width: '100%', marginBottom: '12px' }}> {label && ( <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '6px', fontSize: '13px', color: '#374151' }}><span>{label}</span> {showPercentage && <span>{progress}%</span>} </div> )} <div style={{ width: '100%', height: '8px', backgroundColor: '#e5e7eb', borderRadius: '4px', overflow: 'hidden', position: 'relative' }}><div className="fade-in" style={{ width: `${progress}%`, height: '100%', background: 'linear-gradient(to right, #2563eb, #1d4ed8)', borderRadius: '4px', transition: 'width 0.3s ease-in-out', position: 'relative', overflow: 'hidden' }}><div style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, background: 'linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent)', animation: 'shimmer 1.5s infinite' }} /></div></div></div> ); const SkeletonLoader = ({ width = '100%', height = '20px', style = {} }) => ( <div className="skeleton" style={{ width, height, ...style }} /> ); const Badge = ({ children, variant = 'default', size = 'md' }) => { const variants = { default: { bg: '#f3f4f6', color: '#374151' }, success: { bg: '#dcfce7', color: '#166534' }, warning: { bg: '#fef3c7', color: '#92400e' }, error: { bg: '#fee2e2', color: '#991b1b' }, info: { bg: '#dbeafe', color: '#1e40af' }, primary: { bg: '#eff6ff', color: '#1e40af' } }; const sizes = { sm: { padding: '2px 6px', fontSize: '11px' }, md: { padding: '4px 10px', fontSize: '12px' }, lg: { padding: '6px 14px', fontSize: '14px' } }; const variantStyle = variants[variant] || variants.default; const sizeStyle = sizes[size] || sizes.md; return ( <span style={{ display: 'inline-block', ...sizeStyle, backgroundColor: variantStyle.bg, color: variantStyle.color, borderRadius: '9999px', fontWeight: '600', whiteSpace: 'nowrap' }}> {children} </span> ); }; const FileUploadZone = ({ fileKey, label }) => ( <div style={{ backgroundColor: 'white', borderRadius: '8px', boxShadow: '0 1px 3px rgba(0,0,0,0.12)', padding: '24px', border: '2px dashed #d1d5db', transition: 'border-color 0.2s' }}><div style={{ textAlign: 'center' }}><div style={{ fontSize: '48px', marginBottom: '16px' }}>üìÑ</div><h3 style={{ fontSize: '18px', fontWeight: '600', marginBottom: '8px' }}>{label}</h3> {isUploading[fileKey] ? ( <div className="fade-in" style={{ padding: '16px' }}><div style={{ fontSize: '32px', marginBottom: '16px', textAlign: 'center', className: 'pulse' }}>üì§</div><ProgressBar progress={uploadProgress[fileKey]} label="Uploading file..." showPercentage={true} /></div> ) : !files[fileKey] ? ( <><div onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, fileKey)} style={{ marginBottom: '16px', padding: '32px', backgroundColor: '#f9fafb', borderRadius: '8px' }}><p style={{ fontSize: '14px', color: '#6b7280', marginBottom: '8px' }}>Drag and drop file here</p><p style={{ fontSize: '12px', color: '#9ca3af' }}>or</p></div><button onClick={() => fileKey === 'fileA' ? fileInputA.current.click() : fileInputB.current.click()} style={{ backgroundColor: '#2563eb', color: 'white', padding: '8px 16px', borderRadius: '8px', border: 'none', cursor: 'pointer', width: '100%', marginBottom: '8px', fontSize: '14px', fontWeight: '500' }}> ‚¨ÜÔ∏è Choose File </button><p style={{ fontSize: '11px', color: '#6b7280', textAlign: 'center', marginBottom: '8px', lineHeight: '1.4' }}> Supports: PDF, Images (OCR), Text files </p><div style={{ marginTop: '16px' }}><input type="text" placeholder="Or paste URL to document" style={{ width: '100%', padding: '8px 12px', border: '1px solid #d1d5db', borderRadius: '8px', fontSize: '14px' }} onKeyPress={(e) => { if (e.key === 'Enter' && e.target.value) { handleUrlUpload(e.target.value, fileKey); } }} /></div><input type="file" ref={fileKey === 'fileA' ? fileInputA : fileInputB} onChange={(e) => handleFileUpload(e.target.files[0], fileKey)} style={{ display: 'none' }} accept=".txt,.doc,.docx,.pdf,.png,.jpg,.jpeg,.gif,.bmp,.tiff,image/*" /></> ) : ( <div className="fade-in" style={{ backgroundColor: '#f0fdf4', padding: '16px', borderRadius: '8px', border: '1px solid #bbf7d0' }}><div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '8px' }}><div style={{ display: 'flex', alignItems: 'center', flex: 1 }}><span style={{ fontSize: '20px', marginRight: '8px' }}>‚úÖ</span><div style={{ flex: 1 }}><div style={{ fontSize: '14px', fontWeight: '600', color: '#166534', marginBottom: '4px' }}> {files[fileKey].name} </div> {files[fileKey].documentType && ( <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}><Badge variant="success" size="sm"> {files[fileKey].documentType} </Badge> {files[fileKey].size && ( <span style={{ fontSize: '11px', color: '#6b7280' }}> {(files[fileKey].size / 1024).toFixed(1)} KB </span> )} </div> )} </div></div><button onClick={() => { setFiles(prev => ({ ...prev, [fileKey]: null })); setFileContents(prev => ({ ...prev, [fileKey]: '' })); }} style={{ color: '#dc2626', fontSize: '13px', background: 'none', border: 'none', cursor: 'pointer', padding: '4px 8px', fontWeight: '500' }} aria-label={`Remove ${files[fileKey].name}`}> ‚úï Remove </button></div></div> )} </div></div> ); const AnalysisSection = ({ title, children, sectionId }) => { const isExpanded = expandedSections[sectionId]; return ( <div className="fade-in" style={{ backgroundColor: 'white', borderRadius: '8px', boxShadow: '0 1px 3px rgba(0,0,0,0.12)', marginBottom: '16px', overflow: 'hidden' }}><button onClick={() => toggleSection(sectionId)} style={{ width: '100%', padding: '24px', display: 'flex', alignItems: 'center', justifyContent: 'space-between', background: isExpanded ? '#f9fafb' : 'none', border: 'none', cursor: 'pointer', fontSize: '18px', fontWeight: '600', textAlign: 'left' }} aria-expanded={isExpanded} aria-controls={`section-${sectionId}`} role="button" tabIndex={0} onKeyPress={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleSection(sectionId); } }}><span>{title}</span><span style={{ fontSize: '14px', transition: 'transform 0.2s ease-in-out', transform: isExpanded ? 'rotate(0deg)' : 'rotate(-90deg)' }}> ‚ñº </span></button> {isExpanded && ( <div id={`section-${sectionId}`} className="fade-in" style={{ padding: '0 24px 24px', borderTop: '1px solid #e5e7eb' }} role="region" aria-labelledby={`section-${sectionId}-title`}> {children} </div> )} </div> ); }; return ( <div style={{ minHeight: '100vh', background: darkMode ? 'linear-gradient(to bottom right, #111827, #1f2937)' : 'linear-gradient(to bottom right, #eff6ff, #f3f4f6)', padding: '24px', transition: 'background 0.3s ease' }} className={printMode ? 'print-mode' : ''}><div style={{ maxWidth: '1280px', margin: '0 auto' }}> {/* Top Navigation Bar */} <div style={{ backgroundColor: darkMode ? 'var(--bg-secondary)' : 'white', borderRadius: '12px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)', padding: '16px 24px', marginBottom: '16px', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '12px' }}> {/* View Mode Switcher */} <div style={{ display: 'flex', gap: '8px' }}><button onClick={() => setViewMode('analysis')} style={{ padding: '8px 16px', borderRadius: '6px', border: 'none', background: viewMode === 'analysis' ? 'var(--color-primary)' : 'var(--color-gray-200)', color: viewMode === 'analysis' ? 'white' : 'var(--text-primary)', fontWeight: '600', cursor: 'pointer', fontSize: '14px' }}><Icon name="FileText" /> Analysis </button><button onClick={() => setViewMode('dashboard')} style={{ padding: '8px 16px', borderRadius: '6px', border: 'none', background: viewMode === 'dashboard' ? 'var(--color-primary)' : 'var(--color-gray-200)', color: viewMode === 'dashboard' ? 'white' : 'var(--text-primary)', fontWeight: '600', cursor: 'pointer', fontSize: '14px' }}><Icon name="BarChart" /> Dashboard </button><button onClick={() => setViewMode('comparison')} style={{ padding: '8px 16px', borderRadius: '6px', border: 'none', background: viewMode === 'comparison' ? 'var(--color-primary)' : 'var(--color-gray-200)', color: viewMode === 'comparison' ? 'white' : 'var(--text-primary)', fontWeight: '600', cursor: 'pointer', fontSize: '14px' }}><Icon name="Compare" /> Compare </button></div> {/* Actions */} <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}><button onClick={() => setDarkMode(!darkMode)} style={{ padding: '8px', borderRadius: '6px', border: 'none', background: 'var(--color-gray-200)', color: 'var(--text-primary)', cursor: 'pointer', fontSize: '18px' }} title={darkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}><Icon name={darkMode ? 'Sun' : 'Moon'} /></button><button onClick={() => setPrintMode(!printMode)} style={{ padding: '8px 12px', borderRadius: '6px', border: 'none', background: printMode ? 'var(--color-primary)' : 'var(--color-gray-200)', color: printMode ? 'white' : 'var(--text-primary)', cursor: 'pointer', fontSize: '14px' }} title="Toggle Print-Friendly View"><Icon name="Print" /></button><button onClick={() => setShowSettings(!showSettings)} style={{ padding: '8px 12px', borderRadius: '6px', border: 'none', background: showSettings ? 'var(--color-primary)' : 'var(--color-gray-200)', color: showSettings ? 'white' : 'var(--text-primary)', cursor: 'pointer', fontSize: '14px' }} title="Settings"><Icon name="Settings" /></button></div></div> {/* Settings Panel */} {showSettings && ( <div style={{ backgroundColor: darkMode ? 'var(--bg-secondary)' : 'white', borderRadius: '12px', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', padding: '24px', marginBottom: '16px' }}><h2 style={{ fontSize: '20px', fontWeight: 'bold', color: 'var(--text-primary)', marginBottom: '16px' }}> Settings <Icon name="Settings" /></h2><div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '16px' }}><div><label style={{ display: 'block', marginBottom: '8px', color: 'var(--text-primary)', fontWeight: '600' }}> Export Format Preference </label><select value={settings.exportFormat} onChange={(e) => setSettings({ ...settings, exportFormat: e.target.value })} style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid var(--border-color)', background: darkMode ? 'var(--bg-primary)' : 'white', color: 'var(--text-primary)' }}><option value="pdf">PDF</option><option value="word">Word</option><option value="json">JSON</option><option value="csv">CSV</option></select></div><div><label style={{ display: 'block', marginBottom: '8px', color: 'var(--text-primary)', fontWeight: '600' }}> Auto-Save Frequency (minutes) </label><input type="number" value={settings.autoSaveFrequency} onChange={(e) => setSettings({ ...settings, autoSaveFrequency: parseInt(e.target.value) })} style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid var(--border-color)', background: darkMode ? 'var(--bg-primary)' : 'white', color: 'var(--text-primary)' }} min="1" max="60" /></div><div><label style={{ display: 'block', marginBottom: '8px', color: 'var(--text-primary)', fontWeight: '600' }}> Data Retention (days) </label><input type="number" value={settings.dataRetentionDays} onChange={(e) => setSettings({ ...settings, dataRetentionDays: parseInt(e.target.value) })} style={{ width: '100%', padding: '8px', borderRadius: '6px', border: '1px solid var(--border-color)', background: darkMode ? 'var(--bg-primary)' : 'white', color: 'var(--text-primary)' }} min="7" max="365" /></div></div></div> )} {/* Main Content Area - Conditional based on viewMode */} {viewMode === 'analysis' && ( <div style={{ backgroundColor: darkMode ? 'var(--bg-secondary)' : 'white', borderRadius: '12px', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', padding: '32px', marginBottom: '24px' }}><div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '24px' }}><div><h1 style={{ fontSize: '30px', fontWeight: 'bold', color: 'var(--text-primary)', marginBottom: '8px' }}> Forensic Legal Document Analyzer </h1><p style={{ color: 'var(--text-secondary)' }}> Multi-Layered Interpretive Analysis System for Evidentiary Documents </p></div><div style={{ fontSize: '48px' }}>üëÅÔ∏è</div></div><div style={{ backgroundColor: darkMode ? 'var(--bg-primary)' : '#eff6ff', borderLeft: '4px solid #2563eb', padding: '16px', marginBottom: '24px' }}><h3 style={{ fontWeight: '600', color: darkMode ? 'var(--color-primary)' : '#1e3a8a', marginBottom: '8px' }}> System Capabilities: <HelpTooltip content="This system performs comprehensive multi-phase analysis of legal documents using Victorian legal standards and statutes."><span style={{ marginLeft: '8px', fontSize: '16px', cursor: 'help' }}><Icon name="Help" /></span></HelpTooltip></h3><ul style={{ fontSize: '14px', color: darkMode ? 'var(--text-secondary)' : '#1e40af', listStyle: 'none', padding: 0 }}><li style={{ marginBottom: '4px', display: 'flex', alignItems: 'center', gap: '8px' }}> ‚Ä¢ Phase A: Multi-preset forensic examination using {interpretivePresets.length} interpretive frameworks <HelpTooltip content="Phase A analyzes documents using 8 different legal frameworks including evidentiary defects, statutory compliance, and procedural accuracy."><span style={{ fontSize: '14px' }}><Icon name="Help" /></span></HelpTooltip></li><li style={{ marginBottom: '4px', display: 'flex', alignItems: 'center', gap: '8px' }}> ‚Ä¢ Phase B: Statutory framework identification and cross-reference analysis <HelpTooltip content="Phase B identifies inconsistencies between documents and validates statutory references across Victorian legislation."><span style={{ fontSize: '14px' }}><Icon name="Help" /></span></HelpTooltip></li><li style={{ marginBottom: '4px', display: 'flex', alignItems: 'center', gap: '8px' }}> ‚Ä¢ Phase C: Comprehensive statutory interpretation applying modern purposive approach <HelpTooltip content="Phase C applies modern purposive interpretation methods to ensure compliance with Victorian statutory requirements and legislative intent."><span style={{ fontSize: '14px' }}><Icon name="Help" /></span></HelpTooltip></li><li style={{ marginBottom: '4px', display: 'flex', alignItems: 'center', gap: '8px' }}> ‚Ä¢ Phase D: Victorian Magistrates' Court criminal procedure analysis with court-ready submissions <HelpTooltip content="Phase D specifically analyzes criminal procedure compliance for Victorian Magistrates' Court, identifying jurisdictional and procedural defects."><span style={{ fontSize: '14px' }}><Icon name="Help" /></span></HelpTooltip></li><li>‚Ä¢ Identifies legal flaws, factual inconsistencies, and procedural defects</li></ul></div><div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '24px', marginBottom: '24px' }}><FileUploadZone fileKey="fileA" label="Document A (Primary Exhibit)" /><FileUploadZone fileKey="fileB" label="Document B (Comparative Exhibit)" /></div><div><button onClick={simulateAnalysis} disabled={!files.fileA || !files.fileB || analysisState === 'analyzing'} style={{ width: '100%', background: (!files.fileA || !files.fileB || analysisState === 'analyzing') ? '#9ca3af' : 'linear-gradient(to right, #2563eb, #1d4ed8)', color: 'white', padding: '16px', borderRadius: '8px', fontSize: '18px', fontWeight: '600', border: 'none', cursor: (!files.fileA || !files.fileB || analysisState === 'analyzing') ? 'not-allowed' : 'pointer', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', marginBottom: analysisState === 'analyzing' ? '12px' : '0' }} aria-label={analysisState === 'analyzing' ? 'Analysis in progress' : 'Start forensic analysis'}> {analysisState === 'analyzing' ? ( <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }}><span className="spin">‚åõ</span><span>{currentPhase}</span></div> ) : ( <>‚ö†Ô∏è Commence Forensic Analysis</> )} </button> {analysisState === 'analyzing' && ( <div className="fade-in"><ProgressBar progress={analysisProgress} showPercentage={true} /></div> )} </div></div> {analysisResults && ( <div><div style={{ backgroundColor: darkMode ? 'var(--bg-secondary)' : 'white', borderRadius: '12px', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', padding: '24px', marginBottom: '16px' }}><div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '16px', flexWrap: 'wrap', gap: '12px' }}><h2 style={{ fontSize: '24px', fontWeight: 'bold', color: 'var(--text-primary)' }}> Analysis Report {defectCounter> 0 && ( <span style={{ marginLeft: '12px', fontSize: '14px', backgroundColor: 'var(--color-error)', color: 'white', padding: '4px 12px', borderRadius: '12px', fontWeight: '600' }}> {defectCounter} Defects </span> )} </h2> {/* Export Options Dropdown */} <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}><button onClick={() => ExportUtils.exportAsJSON(analysisResults)} style={{ padding: '8px 12px', backgroundColor: 'var(--color-info)', color: 'white', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '13px', fontWeight: '600' }} title="Export as JSON"><Icon name="Download" /> JSON </button><button onClick={() => ExportUtils.exportAsPDF(analysisResults)} style={{ padding: '8px 12px', backgroundColor: 'var(--color-error)', color: 'white', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '13px', fontWeight: '600' }} title="Export as PDF Report"><Icon name="Download" /> PDF </button><button onClick={() => ExportUtils.exportAsWord(analysisResults)} style={{ padding: '8px 12px', backgroundColor: 'var(--color-primary)', color: 'white', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '13px', fontWeight: '600' }} title="Export as Word Document"><Icon name="Download" /> Word </button><button onClick={() => ExportUtils.exportAsCSV(analysisResults)} style={{ padding: '8px 12px', backgroundColor: 'var(--color-success)', color: 'white', borderRadius: '6px', border: 'none', cursor: 'pointer', fontSize: '13px', fontWeight: '600' }} title="Export Defects as CSV"><Icon name="Download" /> CSV </button></div></div> {/* Search and Filter Bar */} <div style={{ display: 'flex', gap: '12px', marginBottom: '16px', flexWrap: 'wrap' }}><div style={{ flex: '1', minWidth: '200px' }}><input type="text" placeholder="Search statutory references, findings..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} style={{ width: '100%', padding: '10px', borderRadius: '6px', border: '1px solid var(--border-color)', background: darkMode ? 'var(--bg-primary)' : 'white', color: 'var(--text-primary)', fontSize: '14px' }} /></div><select value={filterSeverity} onChange={(e) => setFilterSeverity(e.target.value)} style={{ padding: '10px', borderRadius: '6px', border: '1px solid var(--border-color)', background: darkMode ? 'var(--bg-primary)' : 'white', color: 'var(--text-primary)', fontSize: '14px', cursor: 'pointer' }}><option value="all">All Severities</option><option value="critical">Critical Only</option><option value="high">High Only</option><option value="medium+">Medium & Above</option></select></div><div style={{ backgroundColor: '#fef3c7', borderLeft: '4px solid #f59e0b', padding: '16px', marginBottom: '24px' }}><h3 style={{ fontWeight: '600', color: '#78350f', marginBottom: '8px' }}>Executive Summary</h3><p style={{ fontSize: '14px', color: '#92400e', marginBottom: '12px' }}><strong>Overall Assessment:</strong> {analysisResults.summary.overallAssessment} </p><div style={{ fontSize: '14px', color: '#92400e' }}><strong>Critical Findings:</strong><ul style={{ marginTop: '8px', paddingLeft: '20px' }}> {analysisResults.summary.criticalFindings.map((finding, idx) => ( <li key={idx} style={{ marginBottom: '4px' }}>{finding}</li> ))} </ul></div></div> {/* Visual Statistics Dashboard */} <div className="fade-in" style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '16px', marginBottom: '24px' }}> {(() => { const countIssuesBySeverity = (severity) => { let count = 0; ['fileA', 'fileB'].forEach(fileKey => { if (analysisResults.phaseA[fileKey]) { analysisResults.phaseA[fileKey].forEach(preset => { const issues = preset.findings.potentialIssues; if (Array.isArray(issues)) { count += issues.filter(i => i.severity === severity).length; } }); } }); return count; }; const totalIssues = ['critical', 'high', 'medium', 'low'] .reduce((sum, severity) => sum + countIssuesBySeverity(severity), 0); const stats = [ { label: 'Critical Issues', value: countIssuesBySeverity('critical'), icon: 'üî¥', color: '#fee2e2', textColor: '#991b1b' }, { label: 'High Priority', value: countIssuesBySeverity('high'), icon: 'üü°', color: '#fef3c7', textColor: '#92400e' }, { label: 'Medium Priority', value: countIssuesBySeverity('medium'), icon: 'üîµ', color: '#dbeafe', textColor: '#1e40af' }, { label: 'Total Issues', value: totalIssues, icon: 'üìä', color: '#f3f4f6', textColor: '#374151' } ]; return stats.map((stat, idx) => ( <div key={idx} style={{ backgroundColor: stat.color, padding: '20px', borderRadius: '12px', border: '1px solid rgba(0,0,0,0.1)', textAlign: 'center' }}><div style={{ fontSize: '32px', marginBottom: '8px' }}> {stat.icon} </div><div style={{ fontSize: '28px', fontWeight: 'bold', color: stat.textColor, marginBottom: '4px' }}> {stat.value} </div><div style={{ fontSize: '13px', fontWeight: '500', color: stat.textColor, opacity: 0.8 }}> {stat.label} </div></div> )); })()} </div></div><AnalysisSection title="Phase A: Multi-Preset Forensic Examination" sectionId="phaseA"><div style={{ marginTop: '16px' }}><div><h4 style={{ fontWeight: '600', fontSize: '18px', marginBottom: '12px' }}>Document A Analysis</h4> {analysisResults.phaseA.fileA.map((analysis, idx) => ( <div key={idx} style={{ backgroundColor: '#f9fafb', padding: '16px', borderRadius: '8px', marginBottom: '12px' }}><h5 style={{ fontWeight: '500', color: '#1e40af', marginBottom: '8px' }}>{analysis.preset}</h5><div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '16px', fontSize: '14px' }}><div><p style={{ color: '#6b7280' }}><strong>Word Count:</strong> {analysis.findings.wordCount}</p><p style={{ color: '#6b7280' }}><strong>Line Count:</strong> {analysis.findings.lineCount}</p><p style={{ color: '#6b7280' }}><strong>Key Terms:</strong> {analysis.findings.keyTermsIdentified.length}</p></div><div><p style={{ color: '#6b7280' }}><strong>Legal References:</strong> {analysis.findings.legalReferences.length}</p><p style={{ color: '#6b7280' }}><strong>Procedural Elements:</strong> {analysis.findings.proceduralElements.length}</p><p style={{ color: '#6b7280' }}><strong>Potential Issues:</strong> {analysis.findings.potentialIssues.length}</p></div></div> {analysis.findings.potentialIssues.length> 0 && ( <div style={{ marginTop: '12px', padding: '12px', backgroundColor: '#fef2f2', borderRadius: '4px', borderLeft: '4px solid #dc2626' }}><strong style={{ color: '#7f1d1d' }}>Issues Identified:</strong><ul style={{ marginTop: '8px', fontSize: '14px', color: '#991b1b', paddingLeft: '20px' }}> {analysis.findings.potentialIssues.map((issue, i) => ( <li key={i} style={{ marginBottom: '4px' }}> [{issue.severity.toUpperCase()}] {issue.type}: {issue.description} </li> ))} </ul></div> )} </div> ))} </div><div style={{ marginTop: '24px' }}><h4 style={{ fontWeight: '600', fontSize: '18px', marginBottom: '12px' }}>Document B Analysis</h4> {analysisResults.phaseA.fileB.map((analysis, idx) => ( <div key={idx} style={{ backgroundColor: '#f9fafb', padding: '16px', borderRadius: '8px', marginBottom: '12px' }}><h5 style={{ fontWeight: '500', color: '#1e40af', marginBottom: '8px' }}>{analysis.preset}</h5><div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '16px', fontSize: '14px' }}><div><p style={{ color: '#6b7280' }}><strong>Word Count:</strong> {analysis.findings.wordCount}</p><p style={{ color: '#6b7280' }}><strong>Line Count:</strong> {analysis.findings.lineCount}</p><p style={{ color: '#6b7280' }}><strong>Key Terms:</strong> {analysis.findings.keyTermsIdentified.length}</p></div><div><p style={{ color: '#6b7280' }}><strong>Legal References:</strong> {analysis.findings.legalReferences.length}</p><p style={{ color: '#6b7280' }}><strong>Procedural Elements:</strong> {analysis.findings.proceduralElements.length}</p><p style={{ color: '#6b7280' }}><strong>Potential Issues:</strong> {analysis.findings.potentialIssues.length}</p></div></div> {analysis.findings.potentialIssues.length> 0 && ( <div style={{ marginTop: '12px', padding: '12px', backgroundColor: '#fef2f2', borderRadius: '4px', borderLeft: '4px solid #dc2626' }}><strong style={{ color: '#7f1d1d' }}>Issues Identified:</strong><ul style={{ marginTop: '8px', fontSize: '14px', color: '#991b1b', paddingLeft: '20px' }}> {analysis.findings.potentialIssues.map((issue, i) => ( <li key={i} style={{ marginBottom: '4px' }}> [{issue.severity.toUpperCase()}] {issue.type}: {issue.description} </li> ))} </ul></div> )} </div> ))} </div></div></AnalysisSection><AnalysisSection title="Phase B: Victorian Criminal Compliance & Statutory Cross-Reference Analysis" sectionId="phaseB"><div style={{ marginTop: '16px' }}><div style={{ backgroundColor: '#eff6ff', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#1e40af', marginBottom: '12px' }}>Governing Statutory Framework</h4> {analysisResults.phaseB.governingFramework.length> 0 ? ( <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}> {analysisResults.phaseB.governingFramework.map((framework, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '12px', borderRadius: '4px', fontSize: '14px' }}><p style={{ fontWeight: '500', color: '#111827' }}>{framework.statute}</p><p style={{ color: '#6b7280' }}> Source: {framework.source} | {framework.applicability} </p></div> ))} </div> ) : ( <p style={{ fontSize: '14px', color: '#6b7280' }}> No explicit statutory framework identified in documents </p> )} </div> {analysisResults.phaseB.discrepancies.length> 0 && ( <div style={{ backgroundColor: '#fef2f2', padding: '16px', borderRadius: '8px', borderLeft: '4px solid #dc2626', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#7f1d1d', marginBottom: '12px' }}>Discrepancies Identified</h4><ul style={{ paddingLeft: '20px' }}> {analysisResults.phaseB.discrepancies.map((disc, idx) => ( <li key={idx} style={{ fontSize: '14px', color: '#991b1b', marginBottom: '8px' }}><strong>[{disc.severity?.toUpperCase()}]</strong> {disc.type}: {disc.description} </li> ))} </ul></div> )} {analysisResults.phaseB.omissions.length> 0 && ( <div style={{ backgroundColor: '#fef3c7', padding: '16px', borderRadius: '8px', borderLeft: '4px solid #f59e0b', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#78350f', marginBottom: '12px' }}>Omissions Detected</h4><ul style={{ paddingLeft: '20px' }}> {analysisResults.phaseB.omissions.slice(0, 10).map((omission, idx) => ( <li key={idx} style={{ fontSize: '14px', color: '#92400e', marginBottom: '8px' }}> {omission.type}: <strong>{omission.element}</strong> - {omission.status} </li> ))} </ul></div> )} {analysisResults.phaseB.consistencies.length> 0 && ( <div style={{ backgroundColor: '#f0fdf4', padding: '16px', borderRadius: '8px', borderLeft: '4px solid #16a34a', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#14532d', marginBottom: '12px' }}>Consistencies Confirmed</h4><ul style={{ paddingLeft: '20px' }}> {analysisResults.phaseB.consistencies.map((cons, idx) => ( <li key={idx} style={{ fontSize: '14px', color: '#166534', marginBottom: '8px' }}> {cons.type}: <strong>{cons.element}</strong> - {cons.status} </li> ))} </ul></div> )} {/* Victorian Criminal Summary Matters Compliance */} {analysisResults.phaseB.victorianCompliance && ( <div style={{ backgroundColor: '#f5f3ff', padding: '16px', borderRadius: '8px', borderLeft: '4px solid #7c3aed', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#5b21b6', marginBottom: '12px' }}>Victorian Criminal Summary Matters Compliance</h4><p style={{ fontSize: '13px', color: '#6b21a8', marginBottom: '16px', fontStyle: 'italic' }}> Comprehensive checks for CPA 2009 Part 3.3, RSA 1986, and Evidence Act 2008 (Vic) </p> {/* Document A Compliance */} <div style={{ marginBottom: '16px' }}><h5 style={{ fontWeight: '600', color: '#1e40af', fontSize: '14px', marginBottom: '8px' }}>Document A Compliance Issues</h5> {analysisResults.phaseB.victorianCompliance.fileA.length> 0 ? ( <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}> {analysisResults.phaseB.victorianCompliance.fileA.map((issue, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '12px', borderRadius: '4px', borderLeft: `4px solid ${ issue.severity === 'critical' ? '#dc2626' : issue.severity === 'high' ? '#ea580c' : issue.severity === 'medium' ? '#f59e0b' : '#84cc16' }` }}><p style={{ fontSize: '13px', fontWeight: '600', color: issue.severity === 'critical' ? '#7f1d1d' : issue.severity === 'high' ? '#9a3412' : issue.severity === 'medium' ? '#78350f' : '#365314', marginBottom: '4px' }}> [{issue.severity.toUpperCase()}] {issue.statute} </p><p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}><strong>Section:</strong> {issue.section} </p><p style={{ fontSize: '12px', color: '#374151', marginBottom: '4px' }}><strong>Defect:</strong> {issue.defect} </p><p style={{ fontSize: '12px', color: '#4b5563' }}><strong>Remediation:</strong> {issue.remediation} </p></div> ))} </div> ) : ( <p style={{ fontSize: '13px', color: '#10b981' }}> ‚úÖ No compliance issues detected in Document A </p> )} </div> {/* Document B Compliance */} <div><h5 style={{ fontWeight: '600', color: '#1e40af', fontSize: '14px', marginBottom: '8px' }}>Document B Compliance Issues</h5> {analysisResults.phaseB.victorianCompliance.fileB.length> 0 ? ( <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}> {analysisResults.phaseB.victorianCompliance.fileB.map((issue, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '12px', borderRadius: '4px', borderLeft: `4px solid ${ issue.severity === 'critical' ? '#dc2626' : issue.severity === 'high' ? '#ea580c' : issue.severity === 'medium' ? '#f59e0b' : '#84cc16' }` }}><p style={{ fontSize: '13px', fontWeight: '600', color: issue.severity === 'critical' ? '#7f1d1d' : issue.severity === 'high' ? '#9a3412' : issue.severity === 'medium' ? '#78350f' : '#365314', marginBottom: '4px' }}> [{issue.severity.toUpperCase()}] {issue.statute} </p><p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}><strong>Section:</strong> {issue.section} </p><p style={{ fontSize: '12px', color: '#374151', marginBottom: '4px' }}><strong>Defect:</strong> {issue.defect} </p><p style={{ fontSize: '12px', color: '#4b5563' }}><strong>Remediation:</strong> {issue.remediation} </p></div> ))} </div> ) : ( <p style={{ fontSize: '13px', color: '#10b981' }}> ‚úÖ No compliance issues detected in Document B </p> )} </div></div> )} {/* Enhanced Omissions Report */} {analysisResults.phaseB.omissionsReport && ( <div style={{ backgroundColor: '#fff7ed', padding: '16px', borderRadius: '8px', borderLeft: '4px solid #ea580c', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#9a3412', marginBottom: '12px' }}>Comprehensive Omissions Report: Doc A vs Doc B</h4> {/* Critical Victorian Criminal Requirements Omissions */} {analysisResults.phaseB.omissionsReport.criticalOmissions.victorianCriminalRequirements.length> 0 && ( <div style={{ marginBottom: '16px' }}><h5 style={{ fontWeight: '600', color: '#dc2626', fontSize: '14px', marginBottom: '8px' }}>üî¥ CRITICAL: Victorian Criminal Requirements</h5><div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}> {analysisResults.phaseB.omissionsReport.criticalOmissions.victorianCriminalRequirements.map((omission, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '12px', borderRadius: '4px', borderLeft: '4px solid #dc2626' }}><p style={{ fontSize: '13px', fontWeight: '600', color: '#7f1d1d', marginBottom: '4px' }}> {omission.element} </p><p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}><strong>Statute:</strong> {omission.statute} </p><p style={{ fontSize: '12px', color: '#374151', marginBottom: '4px' }}><strong>Present in:</strong> {omission.inDocument} | <strong>Omitted from:</strong> {omission.omittedFrom} </p><p style={{ fontSize: '12px', color: '#991b1b' }}><strong>Impact:</strong> {omission.impact} </p></div> ))} </div></div> )} {/* Statutory References Omissions */} {(analysisResults.phaseB.omissionsReport.statutoryReferences.inANotInB.length> 0 || analysisResults.phaseB.omissionsReport.statutoryReferences.inBNotInA.length> 0) && ( <div style={{ marginBottom: '16px' }}><h5 style={{ fontWeight: '600', color: '#ea580c', fontSize: '14px', marginBottom: '8px' }}>üìã Statutory References</h5> {analysisResults.phaseB.omissionsReport.statutoryReferences.inANotInB.length> 0 && ( <div style={{ marginBottom: '8px' }}><p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}> In Doc A but not Doc B: </p><ul style={{ paddingLeft: '20px', margin: 0 }}> {analysisResults.phaseB.omissionsReport.statutoryReferences.inANotInB.map((ref, idx) => ( <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}> {ref.element} </li> ))} </ul></div> )} {analysisResults.phaseB.omissionsReport.statutoryReferences.inBNotInA.length> 0 && ( <div><p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}> In Doc B but not Doc A: </p><ul style={{ paddingLeft: '20px', margin: 0 }}> {analysisResults.phaseB.omissionsReport.statutoryReferences.inBNotInA.map((ref, idx) => ( <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}> {ref.element} </li> ))} </ul></div> )} </div> )} {/* Procedural Elements Omissions */} {(analysisResults.phaseB.omissionsReport.proceduralElements.inANotInB.length> 0 || analysisResults.phaseB.omissionsReport.proceduralElements.inBNotInA.length> 0) && ( <div><h5 style={{ fontWeight: '600', color: '#ea580c', fontSize: '14px', marginBottom: '8px' }}>‚öñÔ∏è Procedural Elements</h5> {analysisResults.phaseB.omissionsReport.proceduralElements.inANotInB.length> 0 && ( <div style={{ marginBottom: '8px' }}><p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}> In Doc A but not Doc B: </p><ul style={{ paddingLeft: '20px', margin: 0 }}> {analysisResults.phaseB.omissionsReport.proceduralElements.inANotInB.map((elem, idx) => ( <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}> {elem.element} </li> ))} </ul></div> )} {analysisResults.phaseB.omissionsReport.proceduralElements.inBNotInA.length> 0 && ( <div><p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}> In Doc B but not Doc A: </p><ul style={{ paddingLeft: '20px', margin: 0 }}> {analysisResults.phaseB.omissionsReport.proceduralElements.inBNotInA.map((elem, idx) => ( <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}> {elem.element} </li> ))} </ul></div> )} </div> )} </div> )} {/* Compliance Matrix Table */} {analysisResults.phaseB.complianceMatrix && analysisResults.phaseB.complianceMatrix.length> 0 && ( <div style={{ backgroundColor: 'white', padding: '16px', borderRadius: '8px', boxShadow: '0 1px 3px rgba(0,0,0,0.12)', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#111827', marginBottom: '12px' }}>üìä Statutory Compliance Matrix: Doc A vs Doc B</h4><p style={{ fontSize: '13px', color: '#6b7280', marginBottom: '12px' }}><span style={{ display: 'inline-block', padding: '2px 8px', borderRadius: '4px', backgroundColor: '#d1fae5', color: '#065f46', marginRight: '8px', fontSize: '11px' }}>GREEN = Compliant</span><span style={{ display: 'inline-block', padding: '2px 8px', borderRadius: '4px', backgroundColor: '#fef3c7', color: '#78350f', marginRight: '8px', fontSize: '11px' }}>YELLOW = Unclear</span><span style={{ display: 'inline-block', padding: '2px 8px', borderRadius: '4px', backgroundColor: '#fee2e2', color: '#991b1b', fontSize: '11px' }}>RED = Non-Compliant</span></p><div style={{ overflowX: 'auto' }}><table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '13px' }}><thead><tr style={{ backgroundColor: '#f3f4f6', borderBottom: '2px solid #e5e7eb' }}><th style={{ padding: '12px', textAlign: 'left', fontWeight: '600' }}> Statutory Provision </th><th style={{ padding: '12px', textAlign: 'center', fontWeight: '600' }}> Doc A Compliance </th><th style={{ padding: '12px', textAlign: 'center', fontWeight: '600' }}> Doc B Compliance </th><th style={{ padding: '12px', textAlign: 'left', fontWeight: '600' }}> Discrepancies </th><th style={{ padding: '12px', textAlign: 'left', fontWeight: '600' }}> Action Required </th></tr></thead><tbody> {analysisResults.phaseB.complianceMatrix.map((row, idx) => ( <tr key={idx} style={{ borderBottom: '1px solid #e5e7eb' }}><td style={{ padding: '12px', verticalAlign: 'top' }}><strong>{row.statute}</strong><br /><span style={{ fontSize: '11px', color: '#6b7280' }}> {row.section} </span></td><td style={{ padding: '12px', textAlign: 'center', verticalAlign: 'top' }}><span style={{ display: 'inline-block', padding: '4px 12px', borderRadius: '12px', fontSize: '11px', fontWeight: '600', backgroundColor: row.docACompliance === 'compliant' ? '#d1fae5' : row.docACompliance === 'unclear' ? '#fef3c7' : '#fee2e2', color: row.docACompliance === 'compliant' ? '#065f46' : row.docACompliance === 'unclear' ? '#78350f' : '#991b1b' }}> {row.docACompliance === 'compliant' ? '‚úÖ Compliant' : row.docACompliance === 'unclear' ? '‚ö†Ô∏è Unclear' : '‚ùå Non-Compliant'} </span></td><td style={{ padding: '12px', textAlign: 'center', verticalAlign: 'top' }}><span style={{ display: 'inline-block', padding: '4px 12px', borderRadius: '12px', fontSize: '11px', fontWeight: '600', backgroundColor: row.docBCompliance === 'compliant' ? '#d1fae5' : row.docBCompliance === 'unclear' ? '#fef3c7' : '#fee2e2', color: row.docBCompliance === 'compliant' ? '#065f46' : row.docBCompliance === 'unclear' ? '#78350f' : '#991b1b' }}> {row.docBCompliance === 'compliant' ? '‚úÖ Compliant' : row.docBCompliance === 'unclear' ? '‚ö†Ô∏è Unclear' : '‚ùå Non-Compliant'} </span></td><td style={{ padding: '12px', verticalAlign: 'top', fontSize: '12px', color: '#374151' }}> {row.discrepancies.length> 0 ? ( row.discrepancies.map((disc, dIdx) => ( <div key={dIdx} style={{ marginBottom: '4px' }}> ‚ö†Ô∏è {disc} </div> )) ) : ( <span style={{ color: '#6b7280' }}>No discrepancies</span> )} </td><td style={{ padding: '12px', verticalAlign: 'top', fontSize: '12px' }}><span style={{ color: row.actionRequired.includes('URGENT') ? '#991b1b' : row.actionRequired.includes('Review') ? '#92400e' : '#166534' }}> {row.actionRequired} </span></td></tr> ))} </tbody></table></div></div> )} </div></AnalysisSection><AnalysisSection title="üîó Cross-Reference Matrix" sectionId="crossReference"><CrossReferenceMatrix analysis={analysisResults} /></AnalysisSection><AnalysisSection title="Phase C: Statutory Interpretation & Legislative Purpose" sectionId="phaseC"><div style={{ marginTop: '16px' }}> {/* INTERPRETATION ACT 1984 (VIC) ANALYSIS */} {analysisResults.phaseC.interpretationAct1984 && ( <div style={{ backgroundColor: '#dcfce7', border: '2px solid #16a34a', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#14532d', marginBottom: '16px', fontSize: '16px' }}>‚öñÔ∏è INTERPRETATION ACT 1984 (VIC) - VICTORIAN STATUTORY INTERPRETATION</h4> {/* Section 35(a) - Purposive Construction */} <div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px', borderLeft: '4px solid #16a34a' }}><h5 style={{ fontWeight: '600', color: '#166534', marginBottom: '12px' }}>Section 35(a) - Purposive Construction Analysis</h5> {analysisResults.phaseC.interpretationAct1984.section35aPurposive.map((analysis, idx) => ( <div key={idx} style={{ backgroundColor: '#f9fafb', padding: '12px', borderRadius: '4px', marginBottom: '10px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#111827', marginBottom: '8px' }}> üìã Provision: {analysis.provision} </p><div style={{ marginLeft: '12px' }}><p style={{ marginBottom: '6px' }}><strong style={{ color: '#1e40af' }}>Parliamentary Intention:</strong><br/><span style={{ color: '#374151' }}>{analysis.parliamentaryIntention}</span></p><p style={{ marginBottom: '6px' }}><strong style={{ color: '#7c2d12' }}>Mischief Addressed:</strong><br/><span style={{ color: '#374151' }}>{analysis.mischiefAddressed}</span></p><p style={{ marginBottom: '6px' }}><strong style={{ color: '#166534' }}>Purpose Advanced:</strong><br/><span style={{ color: '#374151' }}>{analysis.purposeAdvanced}</span></p><p style={{ backgroundColor: '#fef3c7', padding: '8px', borderRadius: '4px', marginTop: '8px' }}><strong style={{ color: '#78350f' }}>‚ö° Recommendation:</strong><br/><span style={{ color: '#78350f' }}>{analysis.recommendation}</span></p></div></div> ))} </div> {/* Section 36 - Extrinsic Materials */} {analysisResults.phaseC.interpretationAct1984.section36ExtrinsicMaterials.length> 0 && ( <div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', borderLeft: '4px solid #7c3aed' }}><h5 style={{ fontWeight: '600', color: '#5b21b6', marginBottom: '12px' }}>Section 36 - Extrinsic Materials Analysis</h5> {analysisResults.phaseC.interpretationAct1984.section36ExtrinsicMaterials.map((ext, idx) => ( <div key={idx} style={{ backgroundColor: '#f5f3ff', padding: '12px', borderRadius: '4px', marginBottom: '10px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#6b21a8', marginBottom: '6px' }}> üîç Ambiguous Phrase: "{ext.provision}" </p><p style={{ marginBottom: '6px' }}><strong>Ambiguity Type:</strong><Badge variant="warning" size="sm">{ext.ambiguityType}</Badge></p><p style={{ marginBottom: '8px', color: '#374151' }}><strong>Application Guidance:</strong><br/> {ext.applicationGuidance} </p><div style={{ backgroundColor: 'white', padding: '10px', borderRadius: '4px' }}><p style={{ fontWeight: '600', marginBottom: '6px', fontSize: '12px' }}> üìö Suggested Extrinsic Materials: </p><ul style={{ paddingLeft: '20px', fontSize: '12px', color: '#6b7280' }}> {ext.suggestedMaterials.map((mat, midx) => ( <li key={midx} style={{ marginBottom: '4px' }}>{mat}</li> ))} </ul></div></div> ))} </div> )} </div> )} {/* COMMON LAW MAXIMS */} {analysisResults.phaseC.commonLawMaxims && ( <div style={{ backgroundColor: '#fef3c7', border: '2px solid #f59e0b', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#78350f', marginBottom: '16px', fontSize: '16px' }}>üìö COMMON LAW INTERPRETATION MAXIMS APPLIED</h4> {/* Noscitur a sociis */} <div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px' }}><h5 style={{ fontWeight: '600', color: '#92400e', marginBottom: '10px' }}>Noscitur a sociis (Words Known by Company)</h5> {analysisResults.phaseC.commonLawMaxims.nosciturASociis.map((maxim, idx) => ( <div key={idx} style={{ backgroundColor: '#fefce8', padding: '10px', borderRadius: '4px', marginBottom: '8px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#854d0e' }}>"{maxim.phrase}"</p><p style={{ marginTop: '6px', color: '#374151' }}><strong>Context:</strong> {maxim.surroundingContext} </p><p style={{ marginTop: '4px', color: '#374151' }}><strong>Interpretation:</strong> {maxim.interpretation} </p><p style={{ marginTop: '6px', padding: '6px', backgroundColor: 'white', borderRadius: '4px', color: '#78350f' }}><strong>‚öñÔ∏è Application:</strong> {maxim.application} </p></div> ))} </div> {/* Expressio unius est exclusio alterius */} <div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px' }}><h5 style={{ fontWeight: '600', color: '#92400e', marginBottom: '10px' }}>Expressio unius est exclusio alterius (Express Mention Excludes Others)</h5> {analysisResults.phaseC.commonLawMaxims.expressioUnius.map((maxim, idx) => ( <div key={idx} style={{ backgroundColor: '#fef2f2', padding: '10px', borderRadius: '4px', marginBottom: '8px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#991b1b', marginBottom: '8px' }}> ‚úÖ Expressly Included: </p><ul style={{ paddingLeft: '20px', marginBottom: '8px', fontSize: '12px' }}> {maxim.expresslyIncluded.map((item, iidx) => ( <li key={iidx} style={{ color: '#374151', marginBottom: '3px' }}>{item}</li> ))} </ul><p style={{ fontWeight: '600', color: '#991b1b', marginBottom: '4px' }}> ‚ùå Impliedly Excluded: </p><p style={{ color: '#374151', marginBottom: '8px', fontStyle: 'italic' }}> {maxim.impliedlyExcluded} </p><p style={{ backgroundColor: '#fee2e2', padding: '6px', borderRadius: '4px', color: '#7f1d1d' }}><strong>‚ö†Ô∏è Legal Consequence:</strong> {maxim.legalConsequence} </p><p style={{ marginTop: '6px', fontSize: '12px', color: '#6b7280' }}> {maxim.example} </p></div> ))} </div> {/* Generalia specialibus non derogant */} <div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px' }}><h5 style={{ fontWeight: '600', color: '#92400e', marginBottom: '10px' }}>Generalia specialibus non derogant (Specific Prevails Over General)</h5> {analysisResults.phaseC.commonLawMaxims.generaliaSpecialibus.map((maxim, idx) => ( <div key={idx} style={{ backgroundColor: '#eff6ff', padding: '10px', borderRadius: '4px', fontSize: '13px' }}><p style={{ color: '#374151', marginBottom: '6px' }}><strong>General Provision:</strong> {maxim.generalProvision} </p><p style={{ color: '#374151', marginBottom: '6px' }}><strong>Specific Provision:</strong> {maxim.specificProvision} </p><p style={{ backgroundColor: '#dbeafe', padding: '8px', borderRadius: '4px', fontWeight: '600', color: '#1e40af', marginBottom: '6px' }}> ‚öñÔ∏è Which Prevails: {maxim.whichPrevails} </p><p style={{ color: '#374151', marginBottom: '6px' }}><strong>Reasoning:</strong> {maxim.reasoning} </p><p style={{ color: '#374151' }}><strong>Practical Effect:</strong> {maxim.practicalEffect} </p></div> ))} </div> {/* Ejusdem generis */} <div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px' }}><h5 style={{ fontWeight: '600', color: '#92400e', marginBottom: '10px' }}>Ejusdem generis (Of the Same Kind)</h5> {analysisResults.phaseC.commonLawMaxims.ejusdemGeneris.map((maxim, idx) => ( <div key={idx} style={{ backgroundColor: '#f0fdf4', padding: '10px', borderRadius: '4px', fontSize: '13px' }}><p style={{ color: '#374151', marginBottom: '6px' }}><strong>Specific Items:</strong> {maxim.specificItems.join(', ')} </p><p style={{ color: '#374151', marginBottom: '6px' }}><strong>General Term:</strong> {maxim.generalTerm} </p><p style={{ color: '#166534', fontWeight: '500' }}> {maxim.interpretation} </p></div> ))} </div></div> )} {/* COMPREHENSIVE AMBIGUITY RESOLVER */} {analysisResults.phaseC.ambiguityResolver && analysisResults.phaseC.ambiguityResolver.length> 0 && ( <div style={{ backgroundColor: '#f0f9ff', border: '2px solid #0284c7', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#075985', marginBottom: '16px', fontSize: '16px' }}>üîç COMPREHENSIVE AMBIGUITY RESOLUTION</h4> {analysisResults.phaseC.ambiguityResolver.map((resolution, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '16px', borderRadius: '8px', marginBottom: '14px', border: '1px solid #bae6fd' }}><h5 style={{ fontWeight: '700', color: '#0c4a6e', marginBottom: '14px', fontSize: '15px', backgroundColor: '#e0f2fe', padding: '10px', borderRadius: '6px' }}> üéØ Ambiguous Phrase: "{resolution.ambiguousPhrase}" </h5> {/* Three Interpretations */} <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '12px', marginBottom: '14px' }}> {/* Literal Interpretation */} <div style={{ backgroundColor: '#eff6ff', padding: '12px', borderRadius: '6px', borderLeft: '4px solid #2563eb' }}><h6 style={{ fontWeight: '600', color: '#1e40af', marginBottom: '8px' }}> üìñ Literal Interpretation </h6><p style={{ fontSize: '13px', marginBottom: '6px' }}><strong>Meaning:</strong> {resolution.literalInterpretation.meaning} </p><p style={{ fontSize: '13px', marginBottom: '6px' }}><strong>Analysis:</strong> {resolution.literalInterpretation.analysis} </p><p style={{ fontSize: '12px', color: '#16a34a', marginBottom: '4px' }}> ‚úÖ <strong>Strengths:</strong> {resolution.literalInterpretation.strengths} </p><p style={{ fontSize: '12px', color: '#dc2626' }}> ‚ùå <strong>Weaknesses:</strong> {resolution.literalInterpretation.weaknesses} </p></div> {/* Contextual Interpretation */} <div style={{ backgroundColor: '#f5f3ff', padding: '12px', borderRadius: '6px', borderLeft: '4px solid #7c3aed' }}><h6 style={{ fontWeight: '600', color: '#5b21b6', marginBottom: '8px' }}> üîó Contextual Interpretation </h6><p style={{ fontSize: '13px', marginBottom: '6px' }}><strong>Meaning:</strong> {resolution.contextualInterpretation.meaning} </p><p style={{ fontSize: '13px', marginBottom: '6px' }}><strong>Analysis:</strong> {resolution.contextualInterpretation.analysis} </p><p style={{ fontSize: '13px', marginBottom: '6px', backgroundColor: 'white', padding: '8px', borderRadius: '4px' }}><strong>Statutory Scheme:</strong> {resolution.contextualInterpretation.statutoryScheme} </p><p style={{ fontSize: '12px', color: '#16a34a', marginBottom: '4px' }}> ‚úÖ <strong>Strengths:</strong> {resolution.contextualInterpretation.strengths} </p><p style={{ fontSize: '12px', color: '#dc2626' }}> ‚ùå <strong>Weaknesses:</strong> {resolution.contextualInterpretation.weaknesses} </p></div> {/* Purposive Interpretation */} <div style={{ backgroundColor: '#f0fdf4', padding: '12px', borderRadius: '6px', borderLeft: '4px solid #16a34a' }}><h6 style={{ fontWeight: '600', color: '#166534', marginBottom: '8px' }}> üéØ Purposive Interpretation (Vic s.35a) </h6><p style={{ fontSize: '13px', marginBottom: '6px' }}><strong>Meaning:</strong> {resolution.purposiveInterpretation.meaning} </p><p style={{ fontSize: '13px', marginBottom: '6px' }}><strong>Analysis:</strong> {resolution.purposiveInterpretation.analysis} </p><p style={{ fontSize: '13px', marginBottom: '6px', backgroundColor: 'white', padding: '8px', borderRadius: '4px' }}><strong>Legislative Purpose:</strong> {resolution.purposiveInterpretation.legislativePurpose} </p><p style={{ fontSize: '13px', marginBottom: '6px', backgroundColor: 'white', padding: '8px', borderRadius: '4px' }}><strong>Mischief Rule:</strong> {resolution.purposiveInterpretation.mischiefRule} </p><p style={{ fontSize: '12px', color: '#16a34a', marginBottom: '4px' }}> ‚úÖ <strong>Strengths:</strong> {resolution.purposiveInterpretation.strengths} </p><p style={{ fontSize: '12px', color: '#dc2626' }}> ‚ùå <strong>Weaknesses:</strong> {resolution.purposiveInterpretation.weaknesses} </p></div></div> {/* Court Preference and Recommendation */} <div style={{ backgroundColor: '#fef3c7', padding: '12px', borderRadius: '6px', marginBottom: '10px' }}><p style={{ fontWeight: '700', color: '#78350f', marginBottom: '6px' }}> ‚öñÔ∏è Victorian Court Preference: </p><p style={{ fontSize: '14px', color: '#92400e' }}> {resolution.victorianCourtPreference} </p></div><div style={{ backgroundColor: '#dcfce7', padding: '12px', borderRadius: '6px', marginBottom: '10px', border: '2px solid #16a34a' }}><p style={{ fontWeight: '700', color: '#166534', marginBottom: '6px' }}> ‚úÖ RECOMMENDED INTERPRETATION: </p><p style={{ fontSize: '14px', color: '#14532d' }}> {resolution.recommendedInterpretation} </p></div> {/* Case Law Principles */} <div style={{ backgroundColor: '#f9fafb', padding: '10px', borderRadius: '6px' }}><p style={{ fontWeight: '600', fontSize: '13px', marginBottom: '6px', color: '#374151' }}> üìö Applicable Case Law Principles: </p><ul style={{ paddingLeft: '20px', fontSize: '12px', color: '#6b7280' }}> {resolution.caseLawPrinciples.map((principle, pidx) => ( <li key={pidx} style={{ marginBottom: '4px' }}>{principle}</li> ))} </ul></div></div> ))} </div> )} {/* HARMONIZATION ANALYSIS */} {analysisResults.phaseC.harmonization && analysisResults.phaseC.harmonization.length> 0 && ( <div style={{ backgroundColor: '#fef2f2', border: '2px solid #dc2626', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#991b1b', marginBottom: '16px', fontSize: '16px' }}>‚öîÔ∏è DOCUMENT HARMONIZATION & CONFLICT RESOLUTION</h4> {analysisResults.phaseC.harmonization.map((harm, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '14px', borderRadius: '8px', marginBottom: '12px', border: '1px solid #fecaca' }}><h5 style={{ fontWeight: '600', color: '#7f1d1d', marginBottom: '12px', backgroundColor: '#fee2e2', padding: '10px', borderRadius: '6px' }}> ‚ö†Ô∏è Conflict: {harm.conflict} </h5><div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', marginBottom: '12px' }}><div style={{ backgroundColor: '#dbeafe', padding: '10px', borderRadius: '6px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#1e40af', marginBottom: '6px' }}> üìÑ File A Position: </p><p style={{ color: '#374151' }}>{harm.fileAPosition}</p></div><div style={{ backgroundColor: '#f3e8ff', padding: '10px', borderRadius: '6px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#6b21a8', marginBottom: '6px' }}> üìÑ File B Position: </p><p style={{ color: '#374151' }}>{harm.fileBPosition}</p></div></div><div style={{ backgroundColor: '#f9fafb', padding: '12px', borderRadius: '6px', marginBottom: '10px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#111827', marginBottom: '6px' }}> üîÑ Reconciliation Attempt: </p><p style={{ color: '#374151' }}>{harm.reconciliationAttempt}</p></div><div style={{ marginBottom: '10px' }}><Badge variant={harm.isReconcilable ? 'success' : 'error'}> {harm.isReconcilable ? '‚úÖ Reconcilable' : '‚ùå Irreconcilable Conflict'} </Badge></div><div style={{ backgroundColor: '#fffbeb', padding: '12px', borderRadius: '6px', marginBottom: '10px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#78350f', marginBottom: '6px' }}> ‚öñÔ∏è Which Prevails: </p><p style={{ color: '#92400e' }}>{harm.whichPrevails}</p></div><div style={{ backgroundColor: '#f0f9ff', padding: '12px', borderRadius: '6px', marginBottom: '10px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#075985', marginBottom: '6px' }}> üìã Statutory Support: </p><p style={{ color: '#374151' }}>{harm.statutorySupport}</p></div><div style={{ backgroundColor: '#fee2e2', padding: '12px', borderRadius: '6px', marginBottom: '10px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#991b1b', marginBottom: '6px' }}> ‚ö†Ô∏è Legal Consequence: </p><p style={{ color: '#7f1d1d' }}>{harm.legalConsequence}</p></div><div style={{ backgroundColor: '#dcfce7', padding: '12px', borderRadius: '6px', border: '2px solid #16a34a', fontSize: '13px' }}><p style={{ fontWeight: '700', color: '#166534', marginBottom: '6px' }}> üíº ARGUMENT APPROACH: </p><p style={{ color: '#14532d', fontWeight: '500' }}>{harm.argumentApproach}</p></div></div> ))} </div> )} {/* STATUTORY PROVISION REPORTS */} {analysisResults.phaseC.provisionReports && analysisResults.phaseC.provisionReports.length> 0 && ( <div style={{ backgroundColor: '#f0fdf4', border: '2px solid #16a34a', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#166534', marginBottom: '16px', fontSize: '16px' }}>üìã DETAILED STATUTORY PROVISION INTERPRETATION REPORTS</h4> {analysisResults.phaseC.provisionReports.map((report, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '16px', borderRadius: '8px', marginBottom: '14px', border: '2px solid #bbf7d0' }}><h5 style={{ fontWeight: '700', color: '#14532d', marginBottom: '14px', fontSize: '15px', backgroundColor: '#dcfce7', padding: '12px', borderRadius: '6px' }}> ‚öñÔ∏è {report.provision} </h5><div style={{ backgroundColor: '#f9fafb', padding: '12px', borderRadius: '6px', marginBottom: '12px', fontSize: '13px', fontFamily: 'monospace' }}><p style={{ fontWeight: '600', color: '#111827', marginBottom: '8px' }}> üìú Plain Text of Provision: </p><p style={{ color: '#374151', lineHeight: '1.6' }}>{report.plainText}</p></div><div style={{ backgroundColor: '#eff6ff', padding: '12px', borderRadius: '6px', marginBottom: '12px', fontSize: '13px' }}><p style={{ fontWeight: '600', color: '#1e40af', marginBottom: '8px' }}> üîç Application to Facts in Documents: </p><pre style={{ color: '#374151', whiteSpace: 'pre-wrap', fontFamily: 'inherit', margin: 0 }}>{report.applicationToFacts}</pre></div><div style={{ backgroundColor: report.requirementsSatisfied?.includes('NOT SATISFIED') ? '#fee2e2' : report.requirementsSatisfied?.includes('UNCLEAR') ? '#fef3c7' : report.requirementsSatisfied?.includes('POTENTIALLY') ? '#e0f2fe' : '#dcfce7', padding: '12px', borderRadius: '6px', marginBottom: '12px', border: '2px solid ' + ( report.requirementsSatisfied?.includes('NOT SATISFIED') ? '#dc2626' : report.requirementsSatisfied?.includes('UNCLEAR') ? '#f59e0b' : '#16a34a' ) }}><p style={{ fontWeight: '700', color: report.requirementsSatisfied?.includes('NOT SATISFIED') ? '#991b1b' : report.requirementsSatisfied?.includes('UNCLEAR') ? '#78350f' : '#166534', fontSize: '14px' }}> {report.requirementsSatisfied?.includes('NOT SATISFIED') ? '‚ùå' : report.requirementsSatisfied?.includes('UNCLEAR') ? '‚ö†Ô∏è' : report.requirementsSatisfied?.includes('POTENTIALLY') ? '‚ö†Ô∏è' : '‚úÖ'} {' '}Requirements Satisfied: {report.requirementsSatisfied || 'UNKNOWN'} </p></div> {report.deficiencies && report.deficiencies.length> 0 && ( <div style={{ backgroundColor: '#fee2e2', padding: '12px', borderRadius: '6px', marginBottom: '12px', border: '2px solid #dc2626' }}><p style={{ fontWeight: '700', color: '#991b1b', marginBottom: '8px', fontSize: '14px' }}> üö® Deficiencies Identified: </p><ul style={{ paddingLeft: '20px', fontSize: '13px', color: '#7f1d1d' }}> {report.deficiencies.map((def, didx) => ( <li key={didx} style={{ marginBottom: '6px', fontWeight: '500' }}>{def}</li> ))} </ul></div> )} {report.legalConsequences && report.legalConsequences.length> 0 && ( <div style={{ backgroundColor: '#fef3c7', padding: '12px', borderRadius: '6px', marginBottom: '12px' }}><p style={{ fontWeight: '700', color: '#78350f', marginBottom: '8px', fontSize: '14px' }}> ‚öñÔ∏è Legal Consequences: </p><ul style={{ paddingLeft: '20px', fontSize: '13px', color: '#92400e' }}> {report.legalConsequences.map((cons, cidx) => ( <li key={cidx} style={{ marginBottom: '6px' }}>{cons}</li> ))} </ul></div> )} <div style={{ backgroundColor: '#dcfce7', padding: '14px', borderRadius: '6px', border: '3px solid #16a34a' }}><p style={{ fontWeight: '700', color: '#166534', marginBottom: '10px', fontSize: '14px' }}> üíº RECOMMENDED ARGUMENT APPROACH: </p><p style={{ color: '#14532d', fontSize: '14px', lineHeight: '1.6', fontWeight: '500' }}> {report.recommendedArgument} </p></div></div> ))} </div> )} {/* LEGACY INTERPRETATION SUMMARY (for backward compatibility) */} <div style={{ backgroundColor: '#f9fafb', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#111827', marginBottom: '12px' }}>Summary of Interpretive Approaches</h4><div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}><div style={{ backgroundColor: 'white', padding: '12px', borderRadius: '4px', borderLeft: '4px solid #2563eb', fontSize: '13px' }}><h5 style={{ fontWeight: '500', color: '#1e40af', marginBottom: '6px' }}> {analysisResults.phaseC.literalInterpretation.approach} </h5><p style={{ color: '#374151' }}>{analysisResults.phaseC.literalInterpretation.findings}</p></div><div style={{ backgroundColor: 'white', padding: '12px', borderRadius: '4px', borderLeft: '4px solid #7c3aed', fontSize: '13px' }}><h5 style={{ fontWeight: '500', color: '#5b21b6', marginBottom: '6px' }}> {analysisResults.phaseC.contextualInterpretation.approach} </h5><p style={{ color: '#374151' }}>{analysisResults.phaseC.contextualInterpretation.findings}</p></div><div style={{ backgroundColor: 'white', padding: '12px', borderRadius: '4px', borderLeft: '4px solid #16a34a', fontSize: '13px' }}><h5 style={{ fontWeight: '500', color: '#14532d', marginBottom: '6px' }}> {analysisResults.phaseC.purposiveInterpretation.approach} </h5><p style={{ color: '#374151' }}>{analysisResults.phaseC.purposiveInterpretation.findings}</p></div></div></div> {/* INTERPRETIVE PRINCIPLES */} <div style={{ backgroundColor: '#eff6ff', padding: '16px', borderRadius: '8px' }}><h4 style={{ fontWeight: '600', color: '#1e40af', marginBottom: '12px' }}>All Interpretive Principles Applied</h4><div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}> {analysisResults.phaseC.interpretativePrinciples.map((principle, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '10px', borderRadius: '4px', fontSize: '13px' }}><p style={{ fontWeight: '500', color: '#111827' }}>{principle.principle}</p><p style={{ color: '#6b7280', marginTop: '4px', fontSize: '12px' }}>{principle.application}</p></div> ))} </div></div></div></AnalysisSection><AnalysisSection title="Recommendations & Next Steps" sectionId="recommendations"><div style={{ marginTop: '16px' }}><div style={{ backgroundColor: '#eff6ff', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#1e40af', marginBottom: '12px' }}>Strategic Recommendations</h4><ul style={{ fontSize: '14px', color: '#1e40af', paddingLeft: '20px' }}> {analysisResults.summary.recommendations.map((rec, idx) => ( <li key={idx} style={{ marginBottom: '8px' }}>{rec}</li> ))} </ul></div><div style={{ backgroundColor: '#f0fdf4', padding: '16px', borderRadius: '8px' }}><h4 style={{ fontWeight: '600', color: '#14532d', marginBottom: '12px' }}>Proposed Next Steps</h4><ol style={{ fontSize: '14px', color: '#166534', paddingLeft: '20px' }}> {analysisResults.summary.nextSteps.map((step, idx) => ( <li key={idx} style={{ marginBottom: '8px' }}>{step}</li> ))} </ol></div></div></AnalysisSection> {/* PHASE D: VICTORIAN MAGISTRATES' COURT CRIMINAL PROCEDURE ANALYSIS */} {analysisResults.phaseD && ( <AnalysisSection title="‚öñÔ∏è Phase D: Victorian Magistrates' Court Criminal Procedure Analysis" sectionId="phaseD"><div style={{ marginTop: '16px' }}> {/* OVERVIEW CARD */} <div style={{ backgroundColor: '#eff6ff', border: '2px solid #2563eb', padding: '16px', borderRadius: '8px', marginBottom: '20px' }}><h4 style={{ fontWeight: '700', color: '#1e40af', marginBottom: '12px', fontSize: '16px' }}> üèõÔ∏è MAGISTRATES' COURT COMPLIANCE OVERVIEW </h4><div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '12px' }}><div style={{ backgroundColor: 'white', padding: '12px', borderRadius: '6px' }}><div style={{ fontSize: '24px', fontWeight: '700', color: '#dc2626' }}> {analysisResults.phaseD.learningInsights.totalDefects} </div><div style={{ fontSize: '12px', color: '#6b7280' }}>Total Defects</div></div><div style={{ backgroundColor: 'white', padding: '12px', borderRadius: '6px' }}><div style={{ fontSize: '24px', fontWeight: '700', color: '#ea580c' }}> {analysisResults.phaseD.learningInsights.criticalDefects} </div><div style={{ fontSize: '12px', color: '#6b7280' }}>Critical Priority</div></div><div style={{ backgroundColor: 'white', padding: '12px', borderRadius: '6px' }}><div style={{ fontSize: '24px', fontWeight: '700', color: '#2563eb' }}> {analysisResults.phaseD.courtSubmissions.count} </div><div style={{ fontSize: '12px', color: '#6b7280' }}>Court Submissions</div></div><div style={{ backgroundColor: 'white', padding: '12px', borderRadius: '6px' }}><div style={{ fontSize: '24px', fontWeight: '700', color: '#16a34a' }}> {analysisResults.phaseD.rsaCompliance.summary.mandatoryCompliance}% </div><div style={{ fontSize: '12px', color: '#6b7280' }}>RSA Compliance</div></div></div></div> {/* CATEGORY A: JURISDICTIONAL DEFECTS */} {analysisResults.phaseD.defectCategories.categoryA_Jurisdictional.length> 0 && ( <div style={{ backgroundColor: '#fef2f2', border: '2px solid #dc2626', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#991b1b', marginBottom: '12px', fontSize: '15px' }}> üö® CATEGORY A: JURISDICTIONAL DEFECTS (Court lacks authority) </h4> {analysisResults.phaseD.defectCategories.categoryA_Jurisdictional.map((defect, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px', borderLeft: `4px solid ${defect.severity === 'CRITICAL' ? '#dc2626' : '#ea580c'}` }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}><span style={{ fontWeight: '700', color: '#111827', fontSize: '14px' }}> [{defect.defectId}] {defect.title} </span><span style={{ backgroundColor: defect.severity === 'CRITICAL' ? '#fee2e2' : '#fed7aa', color: defect.severity === 'CRITICAL' ? '#991b1b' : '#92400e', padding: '2px 8px', borderRadius: '4px', fontSize: '11px', fontWeight: '600' }}> {defect.severity} </span></div><p style={{ fontSize: '13px', color: '#374151', marginBottom: '8px' }}><strong>Issue:</strong> {defect.description} </p><p style={{ fontSize: '13px', color: '#374151', marginBottom: '8px' }}><strong>Evidence:</strong> {defect.evidence} </p><p style={{ fontSize: '13px', backgroundColor: '#fef3c7', padding: '8px', borderRadius: '4px', marginBottom: '8px' }}><strong style={{ color: '#78350f' }}>Legal Consequence:</strong><br/> {defect.legalConsequence} </p><p style={{ fontSize: '13px', color: '#166534' }}><strong>Remedy:</strong> {defect.remedy} </p></div> ))} </div> )} {/* CATEGORY B: PROCEDURAL DEFECTS */} {analysisResults.phaseD.defectCategories.categoryB_Procedural.length> 0 && ( <div style={{ backgroundColor: '#fff7ed', border: '2px solid #ea580c', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#9a3412', marginBottom: '12px', fontSize: '15px' }}> ‚ö†Ô∏è CATEGORY B: PROCEDURAL DEFECTS (Process not followed) </h4> {analysisResults.phaseD.defectCategories.categoryB_Procedural.map((defect, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px', borderLeft: `4px solid ${defect.severity === 'CRITICAL' ? '#dc2626' : defect.severity === 'HIGH' ? '#ea580c' : '#f59e0b'}` }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}><span style={{ fontWeight: '700', color: '#111827', fontSize: '14px' }}> [{defect.defectId}] {defect.title} </span><span style={{ backgroundColor: defect.severity === 'CRITICAL' ? '#fee2e2' : defect.severity === 'HIGH' ? '#fed7aa' : '#fef3c7', color: defect.severity === 'CRITICAL' ? '#991b1b' : defect.severity === 'HIGH' ? '#92400e' : '#78350f', padding: '2px 8px', borderRadius: '4px', fontSize: '11px', fontWeight: '600' }}> {defect.severity} </span></div><p style={{ fontSize: '13px', color: '#374151', marginBottom: '8px' }}><strong>Issue:</strong> {defect.description} </p> {defect.statutoryReference && ( <p style={{ fontSize: '12px', color: '#1e40af', marginBottom: '8px', fontStyle: 'italic' }}> üìú {defect.statutoryReference} </p> )} <p style={{ fontSize: '13px', color: '#374151', marginBottom: '8px' }}><strong>Evidence:</strong> {defect.evidence} </p><p style={{ fontSize: '13px', backgroundColor: '#fef3c7', padding: '8px', borderRadius: '4px', marginBottom: '8px' }}><strong style={{ color: '#78350f' }}>Legal Consequence:</strong><br/> {defect.legalConsequence} </p><p style={{ fontSize: '13px', color: '#166534' }}><strong>Remedy:</strong> {defect.remedy} </p></div> ))} </div> )} {/* CATEGORY C: EVIDENTIARY DEFECTS */} {analysisResults.phaseD.defectCategories.categoryC_Evidentiary.length> 0 && ( <div style={{ backgroundColor: '#fef3c7', border: '2px solid #f59e0b', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#92400e', marginBottom: '12px', fontSize: '15px' }}> üìã CATEGORY C: EVIDENTIARY DEFECTS (Evidence inadmissible/weak) </h4> {analysisResults.phaseD.defectCategories.categoryC_Evidentiary.map((defect, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px', borderLeft: `4px solid ${defect.severity === 'CRITICAL' ? '#dc2626' : defect.severity === 'HIGH' ? '#ea580c' : '#f59e0b'}` }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}><span style={{ fontWeight: '700', color: '#111827', fontSize: '14px' }}> [{defect.defectId}] {defect.title} </span><span style={{ backgroundColor: defect.severity === 'CRITICAL' ? '#fee2e2' : defect.severity === 'HIGH' ? '#fed7aa' : '#fef3c7', color: defect.severity === 'CRITICAL' ? '#991b1b' : defect.severity === 'HIGH' ? '#92400e' : '#78350f', padding: '2px 8px', borderRadius: '4px', fontSize: '11px', fontWeight: '600' }}> {defect.severity} </span></div><p style={{ fontSize: '13px', color: '#374151', marginBottom: '8px' }}><strong>Issue:</strong> {defect.description} </p> {defect.statutoryReference && ( <p style={{ fontSize: '12px', color: '#1e40af', marginBottom: '8px', fontStyle: 'italic' }}> üìú {defect.statutoryReference} </p> )} <p style={{ fontSize: '13px', color: '#374151', marginBottom: '8px' }}><strong>Evidence:</strong> {defect.evidence} </p><p style={{ fontSize: '13px', backgroundColor: '#dbeafe', padding: '8px', borderRadius: '4px', marginBottom: '8px' }}><strong style={{ color: '#1e40af' }}>Legal Consequence:</strong><br/> {defect.legalConsequence} </p><p style={{ fontSize: '13px', color: '#166534' }}><strong>Remedy:</strong> {defect.remedy} </p></div> ))} </div> )} {/* CATEGORY D: FACTUAL DEFECTS */} {analysisResults.phaseD.defectCategories.categoryD_Factual.length> 0 && ( <div style={{ backgroundColor: '#e0f2fe', border: '2px solid #0284c7', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#0c4a6e', marginBottom: '12px', fontSize: '15px' }}> üìä CATEGORY D: FACTUAL DEFECTS (Factual inconsistencies) </h4> {analysisResults.phaseD.defectCategories.categoryD_Factual.map((defect, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px', borderLeft: `4px solid #0284c7` }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}><span style={{ fontWeight: '700', color: '#111827', fontSize: '14px' }}> [{defect.defectId}] {defect.title} </span><span style={{ backgroundColor: '#e0f2fe', color: '#0c4a6e', padding: '2px 8px', borderRadius: '4px', fontSize: '11px', fontWeight: '600' }}> {defect.severity} </span></div><p style={{ fontSize: '13px', color: '#374151', marginBottom: '8px' }}><strong>Issue:</strong> {defect.description} </p><p style={{ fontSize: '13px', color: '#374151', marginBottom: '8px' }}><strong>Evidence:</strong> {defect.evidence} </p><p style={{ fontSize: '13px', backgroundColor: '#fef3c7', padding: '8px', borderRadius: '4px', marginBottom: '8px' }}><strong style={{ color: '#78350f' }}>Legal Consequence:</strong><br/> {defect.legalConsequence} </p><p style={{ fontSize: '13px', color: '#166534' }}><strong>Remedy:</strong> {defect.remedy} </p></div> ))} </div> )} {/* RSA 1986 CHECKLIST */} <div style={{ backgroundColor: '#f0fdf4', border: '2px solid #16a34a', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#14532d', marginBottom: '12px', fontSize: '15px' }}> ‚úÖ RSA 1986 COMPLIANCE CHECKLIST </h4><div style={{ marginBottom: '16px', padding: '12px', backgroundColor: 'white', borderRadius: '6px' }}><div style={{ fontSize: '13px', marginBottom: '8px' }}><strong>Mandatory Compliance:</strong> {analysisResults.phaseD.rsaCompliance.summary.mandatoryCompliance}% ({analysisResults.phaseD.rsaCompliance.summary.satisfiedMandatory}/{analysisResults.phaseD.rsaCompliance.summary.mandatoryItems} requirements) </div><div style={{ backgroundColor: analysisResults.phaseD.rsaCompliance.summary.assessment === 'FULL_COMPLIANCE' ? '#dcfce7' : analysisResults.phaseD.rsaCompliance.summary.assessment === 'PARTIAL_COMPLIANCE' ? '#fef3c7' : '#fee2e2', color: analysisResults.phaseD.rsaCompliance.summary.assessment === 'FULL_COMPLIANCE' ? '#166534' : analysisResults.phaseD.rsaCompliance.summary.assessment === 'PARTIAL_COMPLIANCE' ? '#92400e' : '#991b1b', padding: '8px', borderRadius: '4px', fontWeight: '600', fontSize: '13px' }}> Assessment: {analysisResults.phaseD.rsaCompliance.summary.assessment.replace(/_/g, ' ')} </div></div><div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px' }}><h5 style={{ fontWeight: '600', color: '#166534', marginBottom: '10px' }}> Preliminary Test Chain (s.49-55E) </h5> {analysisResults.phaseD.rsaCompliance.preliminaryTestChain.items.map((item, idx) => ( <div key={idx} style={{ display: 'flex', alignItems: 'start', padding: '8px', marginBottom: '6px', backgroundColor: '#f9fafb', borderRadius: '4px', fontSize: '12px' }}><span style={{ marginRight: '8px', fontSize: '16px', color: item.checked ? '#16a34a' : '#dc2626' }}> {item.checked ? '‚úÖ' : '‚ùå'} </span><div style={{ flex: 1 }}><div style={{ fontWeight: '600', marginBottom: '4px' }}> {item.requirement} {item.mandatory && <span style={{ color: '#dc2626' }}>*</span>} </div> {!item.checked && ( <div style={{ color: '#dc2626', fontSize: '11px' }}> ‚ö†Ô∏è {item.consequence} </div> )} </div></div> ))} </div><div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px' }}><h5 style={{ fontWeight: '600', color: '#166534', marginBottom: '10px' }}> Evidentiary Test Chain (s.55) </h5> {analysisResults.phaseD.rsaCompliance.evidentiaryTestChain.items.map((item, idx) => ( <div key={idx} style={{ display: 'flex', alignItems: 'start', padding: '8px', marginBottom: '6px', backgroundColor: '#f9fafb', borderRadius: '4px', fontSize: '12px' }}><span style={{ marginRight: '8px', fontSize: '16px', color: item.checked ? '#16a34a' : '#dc2626' }}> {item.checked ? '‚úÖ' : '‚ùå'} </span><div style={{ flex: 1 }}><div style={{ fontWeight: '600', marginBottom: '4px' }}> {item.requirement} </div> {!item.checked && ( <div style={{ color: '#dc2626', fontSize: '11px' }}> ‚ö†Ô∏è {item.consequence} </div> )} </div></div> ))} </div></div> {/* DISCLOSURE COMPLIANCE MATRIX */} <div style={{ backgroundColor: '#fef3c7', border: '2px solid #f59e0b', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#92400e', marginBottom: '12px', fontSize: '15px' }}> üìë DISCLOSURE COMPLIANCE MATRIX (CPA 2009 Part 3.3) </h4><div style={{ marginBottom: '16px', padding: '12px', backgroundColor: 'white', borderRadius: '6px' }}><div style={{ fontSize: '13px', marginBottom: '8px' }}><strong>Compliance Rate:</strong> {analysisResults.phaseD.disclosureCompliance.summary.complianceRate}% </div><div style={{ backgroundColor: analysisResults.phaseD.disclosureCompliance.summary.assessment === 'FULL_COMPLIANCE' ? '#dcfce7' : analysisResults.phaseD.disclosureCompliance.summary.assessment === 'PARTIAL_COMPLIANCE' ? '#fef3c7' : '#fee2e2', color: analysisResults.phaseD.disclosureCompliance.summary.assessment === 'FULL_COMPLIANCE' ? '#166534' : analysisResults.phaseD.disclosureCompliance.summary.assessment === 'PARTIAL_COMPLIANCE' ? '#92400e' : '#991b1b', padding: '8px', borderRadius: '4px', fontWeight: '600', fontSize: '13px' }}> Risk Level: {analysisResults.phaseD.disclosureCompliance.summary.risk} </div></div><div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px' }}><h5 style={{ fontWeight: '600', color: '#92400e', marginBottom: '10px' }}> Prosecution Disclosure (s.187) </h5> {analysisResults.phaseD.disclosureCompliance.prosecutionDisclosure.requirements.map((req, idx) => ( <div key={idx} style={{ padding: '10px', marginBottom: '8px', backgroundColor: '#f9fafb', borderRadius: '4px', fontSize: '12px', borderLeft: `3px solid ${req.status === 'PROVIDED' ? '#16a34a' : '#dc2626'}` }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}><span style={{ fontWeight: '600' }}>{req.item}</span><span style={{ backgroundColor: req.status === 'PROVIDED' ? '#dcfce7' : '#fee2e2', color: req.status === 'PROVIDED' ? '#166534' : '#991b1b', padding: '2px 6px', borderRadius: '3px', fontSize: '10px' }}> {req.status} </span></div><div style={{ fontSize: '11px', color: '#6b7280' }}> Timing: {req.timing} </div> {req.status !== 'PROVIDED' && ( <div style={{ fontSize: '11px', color: '#dc2626', marginTop: '4px' }}> ‚ö†Ô∏è {req.consequence} </div> )} </div> ))} </div><div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px' }}><h5 style={{ fontWeight: '600', color: '#92400e', marginBottom: '10px' }}> Defence Disclosure (s.185) </h5> {analysisResults.phaseD.disclosureCompliance.defenceDisclosure.requirements.map((req, idx) => ( <div key={idx} style={{ padding: '10px', marginBottom: '8px', backgroundColor: '#f9fafb', borderRadius: '4px', fontSize: '12px' }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}><span style={{ fontWeight: '600' }}>{req.item}</span><span style={{ backgroundColor: '#e0f2fe', color: '#0c4a6e', padding: '2px 6px', borderRadius: '3px', fontSize: '10px' }}> {req.status} </span></div><div style={{ fontSize: '11px', color: '#6b7280' }}> Timing: {req.timing} </div></div> ))} </div></div> {/* MAGISTRATES' COURT PROCEDURE STAGES */} <div style={{ backgroundColor: '#f5f3ff', border: '2px solid #7c3aed', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#5b21b6', marginBottom: '12px', fontSize: '15px' }}> üèõÔ∏è MAGISTRATES' COURT PROCEDURE STAGES </h4><div style={{ marginBottom: '16px', padding: '12px', backgroundColor: 'white', borderRadius: '6px' }}><div style={{ fontSize: '13px', fontWeight: '600', marginBottom: '8px' }}> Overall Procedural Compliance: {analysisResults.phaseD.procedureCompliance.summary.compliancePercentage}% </div><div style={{ fontSize: '12px', color: '#6b7280' }}> {analysisResults.phaseD.procedureCompliance.summary.satisfied} of {analysisResults.phaseD.procedureCompliance.summary.totalRequirements} requirements satisfied </div></div> {Object.values(analysisResults.phaseD.procedureCompliance.stages).map((stage, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px' }}><h5 style={{ fontWeight: '600', color: '#5b21b6', marginBottom: '10px' }}> {stage.stage} </h5> {stage.requirements.map((req, reqIdx) => ( <div key={reqIdx} style={{ display: 'flex', alignItems: 'center', padding: '8px', marginBottom: '6px', backgroundColor: '#f9fafb', borderRadius: '4px', fontSize: '12px' }}><span style={{ marginRight: '8px', fontSize: '14px', color: req.status === 'SATISFIED' ? '#16a34a' : '#dc2626' }}> {req.status === 'SATISFIED' ? '‚úÖ' : '‚ùå'} </span><span>{req.item}</span></div> ))} </div> ))} </div> {/* COURT-READY SUBMISSIONS */} {analysisResults.phaseD.courtSubmissions.submissions.length> 0 && ( <div style={{ backgroundColor: '#eff6ff', border: '2px solid #2563eb', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h4 style={{ fontWeight: '700', color: '#1e40af', marginBottom: '12px', fontSize: '15px' }}> üìù COURT-READY SKELETON SUBMISSIONS ({analysisResults.phaseD.courtSubmissions.count}) </h4><p style={{ fontSize: '13px', color: '#374151', marginBottom: '16px' }}> {analysisResults.phaseD.courtSubmissions.summary} </p> {analysisResults.phaseD.courtSubmissions.submissions.map((submission, idx) => ( <details key={idx} style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px', cursor: 'pointer' }}><summary style={{ fontWeight: '600', color: '#1e40af', marginBottom: '10px', cursor: 'pointer' }}> {submission.title} </summary><pre style={{ backgroundColor: '#f9fafb', padding: '16px', borderRadius: '6px', fontSize: '12px', fontFamily: 'monospace', whiteSpace: 'pre-wrap', marginTop: '12px', overflowX: 'auto' }}> {submission.formattedSubmission} </pre></details> ))} </div> )} {/* LEARNING INSIGHTS & RECOMMENDATIONS */} <div style={{ backgroundColor: '#dcfce7', border: '2px solid #16a34a', padding: '16px', borderRadius: '8px' }}><h4 style={{ fontWeight: '700', color: '#14532d', marginBottom: '12px', fontSize: '15px' }}> üéØ STRATEGIC RECOMMENDATIONS </h4> {analysisResults.phaseD.learningInsights.commonPatterns.length> 0 && ( <div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px', marginBottom: '12px' }}><h5 style={{ fontWeight: '600', color: '#166534', marginBottom: '10px' }}>Common Patterns Detected</h5> {analysisResults.phaseD.learningInsights.commonPatterns.map((pattern, idx) => ( <div key={idx} style={{ padding: '10px', marginBottom: '8px', backgroundColor: '#f0fdf4', borderRadius: '4px', fontSize: '12px', borderLeft: '3px solid #16a34a' }}><div style={{ fontWeight: '600', marginBottom: '4px' }}> {pattern.pattern} <span style={{ fontSize: '10px', color: '#6b7280' }}>(Frequency: {pattern.frequency})</span></div><div style={{ color: '#374151' }}>{pattern.description}</div></div> ))} </div> )} <div style={{ backgroundColor: 'white', padding: '14px', borderRadius: '6px' }}><h5 style={{ fontWeight: '600', color: '#166534', marginBottom: '10px' }}>Recommended Actions</h5> {analysisResults.phaseD.learningInsights.recommendations.map((rec, idx) => ( <div key={idx} style={{ padding: '10px', marginBottom: '8px', backgroundColor: rec.priority === 'URGENT' || rec.priority === 'CRITICAL' ? '#fee2e2' : rec.priority === 'HIGH' ? '#fed7aa' : '#f9fafb', borderRadius: '4px', fontSize: '12px', borderLeft: `3px solid ${rec.priority === 'URGENT' || rec.priority === 'CRITICAL' ? '#dc2626' : rec.priority === 'HIGH' ? '#ea580c' : '#6b7280'}` }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '6px' }}><span style={{ fontWeight: '600', color: '#111827' }}>{rec.action}</span><span style={{ backgroundColor: rec.priority === 'URGENT' || rec.priority === 'CRITICAL' ? '#dc2626' : rec.priority === 'HIGH' ? '#ea580c' : '#6b7280', color: 'white', padding: '2px 6px', borderRadius: '3px', fontSize: '10px', fontWeight: '600' }}> {rec.priority} </span></div><div style={{ color: '#374151' }}>{rec.details}</div></div> ))} </div><div style={{ backgroundColor: '#fef3c7', padding: '12px', borderRadius: '6px', marginTop: '12px', fontSize: '12px' }}><div style={{ fontWeight: '600', color: '#78350f', marginBottom: '8px' }}> üí° Case Learning Framework </div><ul style={{ marginLeft: '20px', color: '#92400e' }}> {analysisResults.phaseD.learningInsights.learningPoints.map((point, idx) => ( <li key={idx} style={{ marginBottom: '4px' }}>{point}</li> ))} </ul><div style={{ marginTop: '10px', padding: '8px', backgroundColor: '#fed7aa', borderRadius: '4px', fontStyle: 'italic', color: '#78350f' }}> üì© {analysisResults.phaseD.learningInsights.feedbackPrompt} </div></div></div> {/* NEW: INTEGRATED COURT COMPLIANCE ANALYSIS */} {analysisResults.phaseD.courtCompliance && ( <div style={{ backgroundColor: '#f0f9ff', border: '3px solid #0284c7', padding: '20px', borderRadius: '12px', marginTop: '24px' }}><h4 style={{ fontWeight: '700', color: '#075985', marginBottom: '16px', fontSize: '17px', display: 'flex', alignItems: 'center', gap: '8px' }}> ‚öñÔ∏è INTEGRATED COURT COMPLIANCE ANALYSIS {!analysisResults.phaseD.courtCompliance.overallCompliant && ( <span style={{ backgroundColor: '#fee2e2', color: '#991b1b', padding: '4px 12px', borderRadius: '6px', fontSize: '13px', fontWeight: '700' }}> ‚ö†Ô∏è COMPLIANCE ISSUES DETECTED </span> )} </h4> {/* Overall Compliance Status */} <div style={{ backgroundColor: analysisResults.phaseD.courtCompliance.overallCompliant ? '#f0fdf4' : '#fef2f2', padding: '12px', borderRadius: '8px', marginBottom: '16px', borderLeft: `4px solid ${analysisResults.phaseD.courtCompliance.overallCompliant ? '#16a34a' : '#dc2626'}` }}><div style={{ fontWeight: '600', fontSize: '14px', marginBottom: '8px' }}> {analysisResults.phaseD.courtCompliance.overallCompliant ? '‚úÖ Overall Compliance: SATISFIED' : '‚ùå Overall Compliance: NON-COMPLIANT'} </div> {analysisResults.phaseD.courtCompliance.criticalDefects.length> 0 && ( <div style={{ fontSize: '13px', color: '#991b1b' }}> {analysisResults.phaseD.courtCompliance.criticalDefects.length} critical defect(s) identified </div> )} </div> {/* Disclosure Compliance */} {analysisResults.phaseD.courtCompliance.disclosure && ( <div style={{ backgroundColor: 'white', border: '2px solid #6366f1', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h5 style={{ fontWeight: '700', color: '#4338ca', marginBottom: '12px', fontSize: '15px' }}> üìã DISCLOSURE COMPLIANCE (CPA ss.185-187) </h5> {/* Prosecution Disclosure */} <div style={{ marginBottom: '12px' }}><div style={{ fontWeight: '600', fontSize: '14px', marginBottom: '8px', color: analysisResults.phaseD.courtCompliance.disclosure.prosecutionDisclosure.compliant ? '#166534' : '#991b1b' }}> Prosecution Disclosure (CPA s.187): { analysisResults.phaseD.courtCompliance.disclosure.prosecutionDisclosure.compliant ? '‚úÖ Compliant' : '‚ùå Non-Compliant' } </div> {analysisResults.phaseD.courtCompliance.disclosure.prosecutionDisclosure.missing.length> 0 && ( <div style={{ backgroundColor: '#fef2f2', padding: '10px', borderRadius: '6px' }}><div style={{ fontSize: '13px', fontWeight: '600', color: '#7f1d1d', marginBottom: '6px' }}> Missing Items: </div><ul style={{ margin: 0, paddingLeft: '20px', fontSize: '13px', color: '#991b1b' }}> {analysisResults.phaseD.courtCompliance.disclosure.prosecutionDisclosure.missing.map((item, idx) => ( <li key={idx}> {item.item} ({item.section}) {item.mandatory && <strong> - MANDATORY</strong>} </li> ))} </ul></div> )} {analysisResults.phaseD.courtCompliance.disclosure.prosecutionDisclosure.present.length> 0 && ( <div style={{ backgroundColor: '#f0fdf4', padding: '10px', borderRadius: '6px', marginTop: '8px' }}><div style={{ fontSize: '13px', fontWeight: '600', color: '#14532d', marginBottom: '6px' }}> Present Items: </div><ul style={{ margin: 0, paddingLeft: '20px', fontSize: '13px', color: '#166534' }}> {analysisResults.phaseD.courtCompliance.disclosure.prosecutionDisclosure.present.map((item, idx) => ( <li key={idx}>{item.item} ({item.section})</li> ))} </ul></div> )} </div></div> )} {/* RSA Compliance */} {analysisResults.phaseD.courtCompliance.rsaCompliance && ( <div style={{ backgroundColor: 'white', border: '2px solid #dc2626', padding: '16px', borderRadius: '8px', marginBottom: '16px' }}><h5 style={{ fontWeight: '700', color: '#991b1b', marginBottom: '12px', fontSize: '15px' }}> üöó RSA 1986 COMPLIANCE (Preliminary Breath Test) </h5><div style={{ fontWeight: '600', fontSize: '14px', marginBottom: '12px', color: analysisResults.phaseD.courtCompliance.rsaCompliance.compliant ? '#166534' : '#991b1b' }}> {analysisResults.phaseD.courtCompliance.rsaCompliance.compliant ? '‚úÖ RSA Compliant' : '‚ùå RSA Non-Compliant'} </div> {/* Checklist */} <div style={{ backgroundColor: '#fef3c7', padding: '12px', borderRadius: '6px', marginBottom: '12px' }}><div style={{ fontSize: '13px', fontWeight: '600', color: '#78350f', marginBottom: '8px' }}> Compliance Checklist: </div><div style={{ fontSize: '12px' }}> {Object.entries(analysisResults.phaseD.courtCompliance.rsaCompliance.checklist).map(([key, value]) => ( <div key={key} style={{ marginBottom: '4px', color: value ? '#166534' : '#991b1b' }}> {value ? '‚úÖ' : '‚ùå'} {key.replace(/_/g, ' ').toUpperCase()} </div> ))} </div></div> {/* Critical Defects */} {analysisResults.phaseD.courtCompliance.rsaCompliance.criticalDefects.length> 0 && ( <div style={{ backgroundColor: '#fee2e2', padding: '12px', borderRadius: '6px' }}><div style={{ fontSize: '13px', fontWeight: '600', color: '#7f1d1d', marginBottom: '8px' }}> Critical Defects: </div> {analysisResults.phaseD.courtCompliance.rsaCompliance.criticalDefects.map((defect, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '10px', borderRadius: '4px', marginBottom: '8px', borderLeft: '4px solid #dc2626' }}><div style={{ fontSize: '13px', fontWeight: '600', color: '#111827', marginBottom: '4px' }}> {defect.element} </div><div style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}> {defect.consequence} </div><div style={{ fontSize: '12px', color: '#166534', fontWeight: '600' }}> Remedy: {defect.remedy} </div></div> ))} </div> )} </div> )} {/* Court Submission Preview */} {analysisResults.phaseD.courtCompliance.courtSubmission && ( <div style={{ backgroundColor: '#fef3c7', border: '2px solid #f59e0b', padding: '16px', borderRadius: '8px' }}><h5 style={{ fontWeight: '700', color: '#92400e', marginBottom: '12px', fontSize: '15px' }}> üìù COURT SUBMISSION DRAFT </h5><div style={{ fontSize: '13px', color: '#78350f', marginBottom: '12px' }}> A court-ready submission has been generated based on the compliance defects identified. </div><div style={{ fontSize: '13px', color: '#92400e', marginBottom: '12px' }}><strong>Sections:</strong> {analysisResults.phaseD.courtCompliance.courtSubmission.sections.length} </div><button onClick={async () => { try { const exportManager = new window.ExportManager(); await exportManager.exportCourtSubmission( analysisResults, `court-submission-${new Date().toISOString().split('T')[0]}.docx` ); } catch (error) { console.error('Export failed:', error); alert('Export failed: ' + error.message); } }} style={{ backgroundColor: '#f59e0b', color: 'white', padding: '10px 20px', borderRadius: '6px', border: 'none', fontSize: '14px', fontWeight: '600', cursor: 'pointer' }}> ‚¨áÔ∏è Export as Court Submission (DOCX) </button></div> )} </div> )} </div></AnalysisSection> )} {/* Learning Insights Panel */} {contextualInsights?.learningInsights && ( <div className="fade-in" style={{ marginBottom: '24px' }}><LearningInsightsPanel insights={contextualInsights.learningInsights} currentDefects={contextualInsights.crossIntelligence} /></div> )} {/* Cross-Analysis Intelligence */} {contextualInsights?.crossIntelligence && contextualInsights.crossIntelligence.length> 0 && ( <div className="fade-in" style={{ marginBottom: '24px' }}><CrossAnalysisIntelligence intelligence={contextualInsights.crossIntelligence} /></div> )} {historicalAnalyses.length> 0 && ( <AnalysisSection title="üìä Defect Evolution Timeline" sectionId="timeline"><DefectTimeline analyses={historicalAnalyses} /></AnalysisSection> )} {detectedPatterns && detectedPatterns.recurring.length> 0 && ( <AnalysisSection title="üîç Pattern Recognition Analysis" sectionId="patterns"><div style={{ marginTop: '16px' }}><div style={{ backgroundColor: '#fef2f2', padding: '16px', borderRadius: '8px', borderLeft: '4px solid #dc2626', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#7f1d1d', marginBottom: '12px' }}>Recurring Issues Detected</h4><p style={{ fontSize: '14px', color: '#991b1b', marginBottom: '12px' }}> The following issues have occurred multiple times across your analyses, indicating systematic problems that require attention: </p> {detectedPatterns.recurring.map((pattern, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '16px', borderRadius: '8px', marginBottom: '12px', border: '1px solid #fecaca' }}><div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '8px' }}><h5 style={{ fontWeight: '600', color: '#991b1b', fontSize: '16px' }}>{pattern.type}</h5><span style={{ backgroundColor: '#dc2626', color: 'white', padding: '4px 12px', borderRadius: '12px', fontSize: '12px', fontWeight: '600' }}> {pattern.frequency}x </span></div><p style={{ fontSize: '14px', color: '#6b7280', marginBottom: '8px' }}> {pattern.description} </p><div style={{ display: 'flex', gap: '16px', fontSize: '12px', color: '#6b7280', marginBottom: '12px' }}><div><strong>First Seen:</strong> {new Date(pattern.firstSeen).toLocaleDateString()} </div><div><strong>Last Seen:</strong> {new Date(pattern.lastSeen).toLocaleDateString()} </div></div><div style={{ backgroundColor: '#fffbeb', padding: '12px', borderRadius: '4px', borderLeft: '4px solid #f59e0b' }}><strong style={{ color: '#78350f', fontSize: '13px' }}>üí° Recommendation:</strong><p style={{ fontSize: '13px', color: '#92400e', marginTop: '4px' }}> {pattern.recommendation} </p></div></div> ))} </div> {detectedPatterns.recurring.length === 0 && ( <div style={{ backgroundColor: '#f0fdf4', padding: '16px', borderRadius: '8px', borderLeft: '4px solid #16a34a' }}><p style={{ fontSize: '14px', color: '#166534' }}> ‚úÖ No recurring patterns detected. Continue monitoring future analyses for emerging trends. </p></div> )} </div></AnalysisSection> )} {contextualInsights && ( <AnalysisSection title="üß† Contextual Intelligence & Trend Analysis" sectionId="contextual"><div style={{ marginTop: '16px' }}> {/* Severity Comparison */} <div style={{ backgroundColor: contextualInsights.severity.status === 'worse' ? '#fef2f2' : contextualInsights.severity.status === 'better' ? '#f0fdf4' : '#eff6ff', padding: '16px', borderRadius: '8px', borderLeft: `4px solid ${ contextualInsights.severity.status === 'worse' ? '#dc2626' : contextualInsights.severity.status === 'better' ? '#16a34a' : '#2563eb' }`, marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: contextualInsights.severity.status === 'worse' ? '#7f1d1d' : contextualInsights.severity.status === 'better' ? '#14532d' : '#1e40af', marginBottom: '12px' }}>üìä Severity Comparison</h4><p style={{ fontSize: '14px', color: contextualInsights.severity.status === 'worse' ? '#991b1b' : contextualInsights.severity.status === 'better' ? '#166534' : '#1e40af', marginBottom: '8px' }}> {contextualInsights.severity.message} </p> {contextualInsights.severity.data && ( <div style={{ fontSize: '12px', color: '#6b7280', marginTop: '8px' }}> Current: {contextualInsights.severity.data.current} | Historical Average: {contextualInsights.severity.data.average} </div> )} </div> {/* Trend Analysis */} <div style={{ backgroundColor: contextualInsights.trend.direction === 'worsening' ? '#fef2f2' : contextualInsights.trend.direction === 'improving' ? '#f0fdf4' : '#eff6ff', padding: '16px', borderRadius: '8px', borderLeft: `4px solid ${ contextualInsights.trend.direction === 'worsening' ? '#dc2626' : contextualInsights.trend.direction === 'improving' ? '#16a34a' : '#2563eb' }`, marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: contextualInsights.trend.direction === 'worsening' ? '#7f1d1d' : contextualInsights.trend.direction === 'improving' ? '#14532d' : '#1e40af', marginBottom: '12px' }}>üìà Trend Analysis</h4><p style={{ fontSize: '14px', color: contextualInsights.trend.direction === 'worsening' ? '#991b1b' : contextualInsights.trend.direction === 'improving' ? '#166534' : '#1e40af' }}> {contextualInsights.trend.message} </p> {contextualInsights.trend.data && ( <div style={{ fontSize: '12px', color: '#6b7280', marginTop: '8px' }}> Based on {contextualInsights.trend.data.samples} recent analyses </div> )} </div> {/* Smart Recommendations */} {contextualInsights.recommendations && contextualInsights.recommendations.length> 0 && ( <div style={{ backgroundColor: '#fffbeb', padding: '16px', borderRadius: '8px', borderLeft: '4px solid #f59e0b', marginBottom: '16px' }}><h4 style={{ fontWeight: '600', color: '#78350f', marginBottom: '12px' }}>üí° Smart Recommendations</h4><p style={{ fontSize: '13px', color: '#92400e', marginBottom: '12px' }}> Based on analysis of current and historical data, here are intelligent recommendations: </p> {contextualInsights.recommendations.map((rec, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '12px', borderRadius: '4px', marginBottom: '8px', border: '1px solid #fde68a' }}><div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '8px' }}><strong style={{ fontSize: '14px', color: '#78350f' }}>{rec.category}</strong><span style={{ padding: '2px 8px', borderRadius: '8px', fontSize: '11px', fontWeight: '600', backgroundColor: rec.priority === 'high' ? '#fee2e2' : rec.priority === 'medium' ? '#fef3c7' : '#dbeafe', color: rec.priority === 'high' ? '#991b1b' : rec.priority === 'medium' ? '#92400e' : '#1e40af' }}> {rec.priority.toUpperCase()} </span></div><p style={{ fontSize: '13px', color: '#374151', marginBottom: '6px' }}> {rec.recommendation} </p><p style={{ fontSize: '12px', color: '#6b7280', fontStyle: 'italic' }}> Expected Impact: {rec.impact} </p></div> ))} </div> )} {/* Novel Issues */} {contextualInsights.novelIssues && contextualInsights.novelIssues.length> 0 && ( <div style={{ backgroundColor: '#fef3c7', padding: '16px', borderRadius: '8px', borderLeft: '4px solid #f59e0b' }}><h4 style={{ fontWeight: '600', color: '#78350f', marginBottom: '12px' }}>üÜï Novel Issues Detected</h4><p style={{ fontSize: '13px', color: '#92400e', marginBottom: '12px' }}> The following issue types have not been seen in previous analyses: </p> {contextualInsights.novelIssues.map((issue, idx) => ( <div key={idx} style={{ backgroundColor: 'white', padding: '10px', borderRadius: '4px', marginBottom: '8px', border: '1px solid #fde68a' }}><div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}><span style={{ padding: '2px 8px', borderRadius: '8px', fontSize: '11px', fontWeight: '600', backgroundColor: getColorForSeverity(issue.severity), border: '1px solid #e5e7eb' }}> {issue.severity.toUpperCase()} </span><strong style={{ fontSize: '13px', color: '#111827' }}> {issue.type} </strong></div><p style={{ fontSize: '12px', color: '#6b7280' }}> {issue.description} </p><p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '4px' }}> Detected in: {issue.preset} </p></div> ))} </div> )} </div></AnalysisSection> )} </div> )} {/* Dashboard View */} {viewMode === 'dashboard' && ( <div style={{ backgroundColor: darkMode ? 'var(--bg-secondary)' : 'white', borderRadius: '12px', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', padding: '32px', marginBottom: '24px' }}><h1 style={{ fontSize: '30px', fontWeight: 'bold', color: 'var(--text-primary)', marginBottom: '24px' }}><Icon name="BarChart" /> Analysis Dashboard </h1> {/* Summary Statistics */} <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '16px', marginBottom: '32px' }}><div style={{ backgroundColor: darkMode ? 'var(--bg-primary)' : 'var(--color-gray-50)', padding: '20px', borderRadius: '12px', borderLeft: '4px solid var(--color-primary)' }}><div style={{ fontSize: '36px', fontWeight: 'bold', color: 'var(--color-primary)' }}> {historicalAnalyses.length} </div><div style={{ color: 'var(--text-secondary)', marginTop: '8px' }}> Total Analyses </div></div><div style={{ backgroundColor: darkMode ? 'var(--bg-primary)' : 'var(--color-gray-50)', padding: '20px', borderRadius: '12px', borderLeft: '4px solid var(--color-error)' }}><div style={{ fontSize: '36px', fontWeight: 'bold', color: 'var(--color-error)' }}> {analysisResults ? ExportUtils.extractAllDefects(analysisResults).filter(d => d.severity === 'Critical').length : 0} </div><div style={{ color: 'var(--text-secondary)', marginTop: '8px' }}> Critical Issues </div></div><div style={{ backgroundColor: darkMode ? 'var(--bg-primary)' : 'var(--color-gray-50)', padding: '20px', borderRadius: '12px', borderLeft: '4px solid var(--color-success)' }}><div style={{ fontSize: '36px', fontWeight: 'bold', color: 'var(--color-success)' }}> {analysisResults ? new Date(analysisResults.timestamp || Date.now()).toLocaleDateString() : 'N/A'} </div><div style={{ color: 'var(--text-secondary)', marginTop: '8px' }}> Most Recent </div></div><div style={{ backgroundColor: darkMode ? 'var(--bg-primary)' : 'var(--color-gray-50)', padding: '20px', borderRadius: '12px', borderLeft: '4px solid var(--color-warning)' }}><div style={{ fontSize: '36px', fontWeight: 'bold', color: 'var(--color-warning)' }}> {analysisResults ? ExportUtils.extractAllDefects(analysisResults).length : 0} </div><div style={{ color: 'var(--text-secondary)', marginTop: '8px' }}> Total Defects </div></div></div> {/* Quick Actions */} <div style={{ marginBottom: '32px' }}><h2 style={{ fontSize: '20px', fontWeight: 'bold', color: 'var(--text-primary)', marginBottom: '16px' }}> Quick Actions </h2><div style={{ display: 'flex', gap: '12px', flexWrap: 'wrap' }}><button onClick={() => setViewMode('analysis')} style={{ padding: '12px 24px', backgroundColor: 'var(--color-primary)', color: 'white', borderRadius: '8px', border: 'none', cursor: 'pointer', fontSize: '14px', fontWeight: '600' }}><Icon name="FileText" /> New Analysis </button><button onClick={() => setViewMode('comparison')} disabled={historicalAnalyses.length <2} style={{ padding: '12px 24px', backgroundColor: historicalAnalyses.length <2 ? 'var(--color-gray-300)' : 'var(--color-secondary)', color: 'white', borderRadius: '8px', border: 'none', cursor: historicalAnalyses.length <2 ? 'not-allowed' : 'pointer', fontSize: '14px', fontWeight: '600' }}><Icon name="Compare" /> Compare Analyses </button> {analysisResults && ( <button onClick={() => ExportUtils.exportAsPDF(analysisResults)} style={{ padding: '12px 24px', backgroundColor: 'var(--color-success)', color: 'white', borderRadius: '8px', border: 'none', cursor: 'pointer', fontSize: '14px', fontWeight: '600' }}><Icon name="Download" /> Export Latest Report </button> )} </div></div> {/* Historical Analyses */} {historicalAnalyses.length> 0 && ( <div><h2 style={{ fontSize: '20px', fontWeight: 'bold', color: 'var(--text-primary)', marginBottom: '16px' }}> Recent Analyses </h2><div style={{ display: 'grid', gap: '12px' }}> {historicalAnalyses.slice(0, 10).map((analysis, idx) => ( <div key={idx} style={{ backgroundColor: darkMode ? 'var(--bg-primary)' : 'var(--color-gray-50)', padding: '16px', borderRadius: '8px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}><div><div style={{ fontWeight: '600', color: 'var(--text-primary)' }}> {analysis.fileAName || 'Document A'} vs {analysis.fileBName || 'Document B'} </div><div style={{ fontSize: '12px', color: 'var(--text-secondary)', marginTop: '4px' }}> {new Date(analysis.timestamp).toLocaleString()} </div></div><div style={{ display: 'flex', gap: '8px' }}><span style={{ backgroundColor: 'var(--color-error-light)', color: 'var(--color-error)', padding: '4px 12px', borderRadius: '12px', fontSize: '12px', fontWeight: '600' }}> {analysis.defects?.length || 0} Defects </span></div></div> ))} </div></div> )} {historicalAnalyses.length === 0 && ( <div style={{ textAlign: 'center', padding: '48px', color: 'var(--text-secondary)' }}><div style={{ fontSize: '48px', marginBottom: '16px' }}>üìä</div><p>No analyses yet. Upload documents to get started.</p></div> )} </div> )} {/* Comparison View */} {viewMode === 'comparison' && ( <div style={{ backgroundColor: darkMode ? 'var(--bg-secondary)' : 'white', borderRadius: '12px', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', padding: '32px', marginBottom: '24px' }}><h1 style={{ fontSize: '30px', fontWeight: 'bold', color: 'var(--text-primary)', marginBottom: '24px' }}><Icon name="Compare" /> Comparison Mode </h1><p style={{ color: 'var(--text-secondary)', marginBottom: '24px' }}> Compare two analyses to track changes, improvements, and compliance trends over time. </p> {/* Analysis Selectors */} <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '16px', marginBottom: '32px' }}><div><label style={{ display: 'block', marginBottom: '8px', fontWeight: '600', color: 'var(--text-primary)' }}> First Analysis </label><select value={comparisonAnalyses[0]?.id || ''} onChange={(e) => { const selected = historicalAnalyses.find(a => a.id == e.target.value); setComparisonAnalyses([selected, comparisonAnalyses[1]]); }} style={{ width: '100%', padding: '10px', borderRadius: '6px', border: '1px solid var(--border-color)', background: darkMode ? 'var(--bg-primary)' : 'white', color: 'var(--text-primary)', fontSize: '14px' }}><option value="">Select an analysis...</option> {historicalAnalyses.map((analysis, idx) => ( <option key={idx} value={analysis.id}> {new Date(analysis.timestamp).toLocaleString()} - {analysis.defects?.length || 0} defects </option> ))} </select></div><div><label style={{ display: 'block', marginBottom: '8px', fontWeight: '600', color: 'var(--text-primary)' }}> Second Analysis </label><select value={comparisonAnalyses[1]?.id || ''} onChange={(e) => { const selected = historicalAnalyses.find(a => a.id == e.target.value); setComparisonAnalyses([comparisonAnalyses[0], selected]); }} style={{ width: '100%', padding: '10px', borderRadius: '6px', border: '1px solid var(--border-color)', background: darkMode ? 'var(--bg-primary)' : 'white', color: 'var(--text-primary)', fontSize: '14px' }}><option value="">Select an analysis...</option> {historicalAnalyses.map((analysis, idx) => ( <option key={idx} value={analysis.id}> {new Date(analysis.timestamp).toLocaleString()} - {analysis.defects?.length || 0} defects </option> ))} </select></div></div> {/* Comparison Results */} {comparisonAnalyses[0] && comparisonAnalyses[1] && ( <div><h2 style={{ fontSize: '20px', fontWeight: 'bold', color: 'var(--text-primary)', marginBottom: '16px' }}> Comparison Results </h2> {/* Side-by-Side Metrics */} <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '16px', marginBottom: '24px' }}> {['Total Defects', 'Critical Issues', 'High Priority', 'Medium Priority'].map((metric, idx) => { const keys = ['', 'Critical', 'High', 'Medium']; const val1 = keys[idx] === '' ? comparisonAnalyses[0].defects?.length || 0 : comparisonAnalyses[0].defects?.filter(d => d.severity === keys[idx]).length || 0; const val2 = keys[idx] === '' ? comparisonAnalyses[1].defects?.length || 0 : comparisonAnalyses[1].defects?.filter(d => d.severity === keys[idx]).length || 0; const diff = val2 - val1; const improved = diff <0; return ( <div key={idx} style={{ backgroundColor: darkMode ? 'var(--bg-primary)' : 'var(--color-gray-50)', padding: '16px', borderRadius: '8px', borderLeft: `4px solid ${improved ? 'var(--color-success)' : diff> 0 ? 'var(--color-error)' : 'var(--color-gray-400)'}` }}><div style={{ fontSize: '14px', fontWeight: '600', color: 'var(--text-primary)', marginBottom: '8px' }}> {metric} </div><div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}><div><div style={{ fontSize: '24px', fontWeight: 'bold', color: 'var(--text-primary)' }}> {val1} ‚Üí {val2} </div></div><div style={{ fontSize: '18px', fontWeight: 'bold', color: improved ? 'var(--color-success)' : diff> 0 ? 'var(--color-error)' : 'var(--text-secondary)' }}> {diff> 0 ? `+${diff}` : diff <0 ? diff : '0'} </div></div></div> ); })} </div> {/* Trend Analysis */} <div style={{ backgroundColor: comparisonAnalyses[1].defects?.length <comparisonAnalyses[0].defects?.length ? 'var(--color-success-light)' : comparisonAnalyses[1].defects?.length> comparisonAnalyses[0].defects?.length ? 'var(--color-error-light)' : 'var(--color-info-light)', padding: '16px', borderRadius: '8px', marginBottom: '24px' }}><h3 style={{ fontWeight: '600', marginBottom: '8px' }}> {comparisonAnalyses[1].defects?.length <comparisonAnalyses[0].defects?.length ? '‚úÖ Improvement Detected' : comparisonAnalyses[1].defects?.length> comparisonAnalyses[0].defects?.length ? '‚ö†Ô∏è Deterioration Detected' : '‚ÑπÔ∏è No Change'} </h3><p style={{ fontSize: '14px' }}> {comparisonAnalyses[1].defects?.length <comparisonAnalyses[0].defects?.length ? `Total defects decreased by ${comparisonAnalyses[0].defects?.length - comparisonAnalyses[1].defects?.length}. Document quality has improved.` : comparisonAnalyses[1].defects?.length> comparisonAnalyses[0].defects?.length ? `Total defects increased by ${comparisonAnalyses[1].defects?.length - comparisonAnalyses[0].defects?.length}. Additional issues identified.` : 'Defect count remains unchanged between analyses.'} </p></div></div> )} {(!comparisonAnalyses[0] || !comparisonAnalyses[1]) && ( <div style={{ textAlign: 'center', padding: '48px', color: 'var(--text-secondary)' }}><div style={{ fontSize: '48px', marginBottom: '16px' }}>‚öñÔ∏è</div><p>Select two analyses to compare</p></div> )} </div> )} </div></div> ); }; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<ForensicLegalAnalyzer />); </script></body></html> 
